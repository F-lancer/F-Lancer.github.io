<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2020%2F03%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构排序快速排序123456789101112131415161718192021var arr = [10,28,25,38,20,35,56]function quickSort (arr) &#123; if (arr.length&lt;=1) &#123; // 结束递归条件 return arr; &#125; let left = []; // 声明 左 let right = []; // 声明 右 let pivot = arr[0]; // 声明 基准数 for (let i=1;i&lt;arr.length;i++)&#123; if (arr[i]&lt;arr[0])&#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(pivot,quickSort(right)); // 递归 拼接&#125;quickSort(arr)/* 缺点：声明了两个数组，不是原地排序，增加了空间复杂度。*/ 阮一峰快速排序 去重暴力法12345678910111213141516171819202122232425var nums = [1,2,3,1];var containsDuplicate = function(nums) &#123; var res = []; var flag = true; for (var i = 0;i&lt;nums.length-1;i++) &#123; for(var j= i+1;j&lt;nums.length-1;j++)&#123; if (nums[i] == nums[j]) &#123; flag = false; break; &#125; &#125; if (flag === true) &#123; res.push(nums[i]); &#125; else &#123; flag = true; &#125; &#125; return res;&#125;;containsDuplicate(nums);/*break 跳出本次循环continue 跳出本次迭代 继续执行return 跳出函数返回函数值*/ 算法解密问题题目字符串解密问题，一个单词奇数位抽出来做前半部分，偶数位倒序后做后半部分，拼接起来，形成一个串，你要解密出原来的字符串。加密过程 Welcome—&gt; Wloe + mce，你要做加密算法 答案123456789101112131415var str = 'Welcome';function changeCode(str)&#123; var arr = str.split(''); // split('') 转为数组 var left = []; var right = []; for(var i = 0;i&lt;arr.length;i++)&#123; if((i%2) == 0)&#123; // 0、2、4...在奇位 left.push(arr[i]) // 尾部压入 W l o e &#125; else &#123; // 1、3、5...在偶位 right.unshift(arr[i]) // 头部写入 m c e &#125; &#125; return left.concat(right).join('') // 拼接转字符串&#125;changeCode(str) // "Wloemce" 三数之和题目给定一个包含 n 个整数的数组 arr，判断 arr 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 爬楼梯题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 答案12345678910function upStairs(n)&#123; if (n===1) &#123; // 结束递归条件 return 1 &#125; else if (n===2)&#123; // 结束递归条件 return 2 &#125; else if (n&gt;2)&#123; return upStairs(n-1) + upStairs(n-2) // 递归 &#125;&#125;upStair(8) // 34 割绳子题目总共有n条长度不等绳子，可以任意切割，不能拼接。要求切割后得到m条长度相等的绳子，求问得到的m条绳子长度L的最大值？ 思路：m*n 进行排序 圆桌分奖品题目圆桌n个人，每一个人有一个得分，相邻两人中得分高的人得到的奖品比得分低 的人多。每个人至少获得一个奖品，问一桌人至少需要准备多少奖品？ 思路：只有一个极小点 最多，极小点越少就越少。 字符串相加数组最大深度]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function 理解]]></title>
    <url>%2F2020%2F03%2F26%2FFunction%2F</url>
    <content type="text"><![CDATA[Function 函数Function 类型每一个函数都是 Function 类型的实例。 内部属性this、arguments、caller thisthis引用的是函数执行的环境对象。 arguments类数组对象，包含着传入函数的所有参数。这里指的是实参。 cellee其中的，cellee属性指向arguments对象的函数。 callerECMA 5。caller 中保存着调用当前函数的函数的引用。 函数属性函数是对象，因此函数也有属性和方法。其中，属性包括：length、prototype length表示函数希望接收到的命名参数的个数。即，形参个数 prototype保存着实例方法的真正所在。 函数方法函数是对象，因此函数也有属性和方法。其中，方法包括：call()，apply()、bind()。 call()在特定的作用域调用函数。不传参指向全局作用域，即：等于设置函数体内 this 对象的值。 apply()与 call() 功能相同，传参方式不同 bind()ECMA 5。不是立即调用的 创建函数使用Function构造函数、函数声明、函数表达式 使用Function构造函数只是为了理解。最后一个参数为 函数体 。 1var a = new Function("num1","num2","return num1 + num2"); 函数声明函数声明形式会存在 函数提升 1234function sum (num1,num2) &#123; return num1 + num2;&#125;sum(); 函数表达式不存在 函数提升 1234var sum = function () &#123; return num1 + num2;&#125;; // 像声明其它变量一样这里要有 ;sum(); 闭包闭包是指有权访问另一个函数作用域中的变量的函数。 作用域链步骤： 执行流进入执行的环境，会将执行环境压入环境栈中（先进后出）。 而在环境中执行时会有一个变量对象，这里存储着所在环境的所有的变量或者函数或其它可访问的数据。 如果执行环境是函数，会将活动对象作为变量对象。其中包括 arguments 对象。 作用域链被保存在内部的 [[Scope]] 属性中。 向上就近原则，即，向上查询变量名和函数名，找到后就停止。 注意： 使用 with 语句（不建议使用）和 try-catch 语句的 catch 语块 作用域链。 没有块级作用域。 if 语句变量声明会添加到当前执行环境。 for 执行结束依然存在外部执行环境。 var 声明的会添加到最近的环境。未声明的会添加到全局作用域 ES6： 引入了块级作用域。 引入了 let 、const 声明。 理解闭包函数在全局中执行，执行完毕后，局部作用域就会被销毁，内存中仅保存全局作用域。闭包是一个函数中定义了另一个函数，内部函数的作用域链就存在了三层：全局（全局变量）、外部函数（外部函数变量）、内部函数（活动对象，内部变量）。内部函数可以根据作用域链访问外部函数里的变量和函数就称为 闭包。 变量问题闭包只能取得外部函数中变量的最后一个值。 返回一个 函数数组 每个函数都返回自己的索引值。 1234567891011function createFunctions () &#123; var result = new Array(); for (var i=0;i&lt;10;i++)&#123; result[i] = function()&#123; return i; &#125; &#125; return result;&#125;createFunctions()// (10) [ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ] 都 return 10 解决：再创建闭包，并将值立即传入。 12345678910111213function createFunctions () &#123; var result = new Array(); for (var i=0;i&lt;10;i++)&#123; result[i] = function(num)&#123; return function ()&#123; return num; &#125;; &#125;(i) &#125; return result;&#125;createFunctions()// (10) [ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ] 各自 return 0~9 this问题this 指向调用它的函数的作用域。且在调用时就会取得这个指向当前调用的作用域的 this ,并将其放到自己的活动对象里去，在自己活动对象中找到后就不再继续向上查找了，因此 this 值是永远不可能向上查找的。 123456789101112 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; function c()&#123; console.log(this.b) console.dir(this) // Window 对象 &#125; c() &#125; &#125;object.a() // 全局作用域 解决：保存变量var that = this 12345678910111213 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; var that = this; function c()&#123; console.log(that.b) console.dir(that) // Object 实例对象 &#125; c() &#125; &#125;object.a() // 局部作用域 箭头函数123456789 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; return ()=&gt;&#123; console.log(this.b) &#125; &#125;&#125;object.a()() // 局部作用域 call()/apply()/bind()12345678910 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; return ()=&gt;&#123; console.log(this.b) &#125; &#125;&#125;object.a.call()() // 未传值 打印全局作用域object.a.call(object)(); // 局部作用域 内存泄漏垃圾回收机制原理JavaScript 具有自动垃圾回收机制。原理：垃圾收集器会按照固定的时间间隔，并周期性的执行，即，找出不再继续使用的变量，然后释放其占用的内存。 策略标记清除： 各个浏览器垃圾收集的时间间隔不同。 引用计数： 循环引用造成内存泄漏。 IE中BOM/DOM是COM对象，其采用的机制就是基于引用计数策略，当涉及COM对象，就会造成内存泄漏。 解决：在不使用时，将循环引用的变量置为空 null。 管理内存局部变量在其离开执行环境时会自动被解除引用。对于全局变量和全局对象我们需要手动将其置为 null，解除引用。 闭包中的内存泄漏问题1：IE 中闭包的作用域链中保存一个 HTML 元素，由于引用计数和循环引用，导致该元素无法被销毁。 解决： 将该元素副本保存在变量中，在闭包中引用该变量，解除循环引用。 使用结束后将该元素置为空，解除对DOM元素对象的引用。 问题2：内部函数引用外部函数，外部函数活动对象无法及时销毁。 解决：只有将 内部函数 设置为 null ，解除对内部函数的引用，通知垃圾回收机将其清除，才能够将整个作用域安全销毁，除了全局作用域。 递归自身调用自身。 12345678var factorial = (function f(num) &#123; if (num&lt;=1) &#123; return 1; &#125; else &#123; return num * f(num-1) &#125;&#125;)// 计算阶乘 模仿块级作用域ES5 中没有块级作用域（私有作用域），但是可以用 匿名函数来模仿。 123456789(function()&#123; // 这里是块级作用域&#125;)();// 理解var a = function()&#123; // 这里是块级作用域&#125;;a(); 使用场景12345678function outputNumbers (count) &#123; (function () &#123; for (var i=0;i&lt;count;i++) &#123; alert(i); &#125; &#125;)(); alert(i); // 报错&#125; 在函数内部，限制向全局作用域添加过多的变量和函数。 可以避免命名冲突而导致全的局污染。 可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。函数执行完毕，就立即清除了其作用域链。 私有变量在函数中定义的变量，称为私有变量。私有变量包括：函数参数、局部变量、函数中定义的其他函数。 特权方法有权访问私有变量和私有函数的公有方法称为特权方法。 构造函数中即，在构造函数中定义函数，根据闭包的原理访问私有变量。 静态私有变量通过在私有作用域中 定义私有变量或函数创建特权方法。 模块模式为 单例 创建私有变量和特权的方法。 增强的模块模式ES6中的变化 let const 声明 块级作用域 {} 箭头函数 高级函数函数的一些高级使用方法： 安全的类型检测、作用域安全的构造函数、惰性载入函数、函数绑定、函数柯里化 引用 《JavaScript 高级程序设计》 MDN 箭头函数 阮一峰ES6块级作用域 阮一峰ES6函数扩展 https://upload-images.jianshu.io/upload_images/8661291-f737c541d87566ee.png?imageMogr2/auto-orient/strip|imageView2/2/w/538/format/webp)]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>Function</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object 理解]]></title>
    <url>%2F2020%2F02%2F14%2FObject%2F</url>
    <content type="text"><![CDATA[Object 对象a person or thing to which a specified action or feeling is directed. 翻译：指定的动作或感觉针对的人或事物。 理解对象123456789101112var person = &#123; "name": "Nicholas", // 基本值 "age": "18", look: &#123; // 对象 "height": 182, "weight": "60kg" &#125;, sayName: function () &#123; // 函数 alert(this.name) &#125;&#125;;console.dir(person.age) 定义对象是 一组无序属性的集合。这里的属性可以包括 基本值、对象、函数。（ECMA-262） 属性类型而这些属性分为两种 数据属性，访问属性。它们拥有一些特性，用来给JS引擎解析，告诉浏览器这个对象可以进行哪些操作，这些特性均有默认值。 属性特性以下是它们的特性： 是否：[configurable]可删除及定义 [enumerable]枚举 [writable]更改 [value]值 [get]读取 [set]写入 数据属性 ：[configurable]、[enumerable]、[writable]、[value] 访问属性：[configurable]、[enumerable]、[get]、[set] 内置对象定义：对象是一组数据和功能的集合。 理解：数据类型：值类型(基本类型)7种：字符串（String）、数字(Number)、大整数（BigInt）、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（符号、代表）。 引用数据类型 Object此处列举了部分 内置对象 目的：提供这些原生的引用类型，是为了 方便开发人员实现常见的计算任务。 对象(Object)、数组(Array)、函数(Function)、日期（Date）、正则（RegExp）。 Object是一个基础类型，其他所有类型都从Object继承了基本行为。 基本包装类型（Boolean/Number/String）。 JavaScript 中的基本类型的值，可以被当做 对象 来访问。 单体内置对象（Global/Math）。 Global 全局对象，在浏览器中是window对象 Math 用于计算 就像其他基本数据类型一样，比如，字符串类型可以使用内置对象所有操作字符串的方法。同样，任何对象类型也都继承了所有 Object 的原型方法。而接下来讨论的 自定义对象 就讨论了它是如何实现的。 自定义对象顾名思义，定义自己的对象。 原始方法:原始方法1：使用 Object() 构造函数。 12var o = new Object();o.name = ... 原始方法2：使用 字面量 。 123456789101112var person = &#123; name: "Nicholas", // 基本值 age: "18", look: &#123; // 对象 height: 182, weight: "60kg" &#125;, sayName: function () &#123; // 方法 alert(this.name) &#125;&#125;;console.dir(person.age) 缺点：多次创建时，会产生许多重复代码。因此引入了函数（工厂模式） 工厂模式1234567function createPerson(name,age,&#123;height,weight&#125;)&#123; var o = new Object(); o.name = ... return o;&#125;var person1 = person("Nicholas","29",&#123;160,"60kg"&#125;)var person2 = person("Tom","18",&#123;182,"70kg"&#125;) 缺点：无法识别对象的类型。因此引入了 new 构造函数模式 构建函数模式构造函数模式（1）123456789function Person(name,age,&#123;height,weight&#125;)&#123; this.name = name this.age = ... this.sayName: function () &#123; // this.sayName = new Function("alert(this.name)") alert(this.name) &#125;&#125;var person1 = new Person("Nicholas","29",&#123;160,"60kg"&#125;)var person2 = new person("Tom","18",&#123;182,"70kg"&#125;) 当使用 new 操作符的时候，实际上进行了一下4个步骤： 创建一个新的对象。 将构造函数的作用域赋给了新的对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为新对象添加属性） 返回新对象 缺点：每次都要把构造函数中的方法在实例上再创建一遍。因此引入了（2）。 构造函数模式（2）123456789101112function Person(name,age,&#123;height,weight&#125;)&#123; this.name = name this.age = ... this.sayName = sayName;&#125;function sayName() &#123; alert(this.name)&#125; var person1 = new Person("Nicholas","29",&#123;160,"60kg"&#125;)var person2 = new person("Tom","18",&#123;182,"70kg"&#125;) 将函数挂载到全局，共享。 缺点：全局污染、没有封装性可言了。因此引入原型模式 原型模式原型模式（1）1234567891011function Person()&#123;&#125;Person.prototype.name = "Nicholas";...Person.prototype.sayName = function () &#123; alert(this.name)&#125;var person1 = new Person()alert(person1.name)var person2 = new person()person2.name = "Tom"alert(person2.name) 原型模式（2）简写： 12345function Person()&#123;&#125;Person.prototype= &#123; name:"Nicholas", ...&#125; 缺点：引用类型被共享，不利于部分数据私有化。引入混合模式 混合模式最常见的方式 12345678910function People(name,eye)&#123; this.name = name; this.eye = eye;&#125;People.prototype.say = function ()&#123; alert (this.name); console.log(this)&#125;var man4 = new People("Flancer一号","small");man4.say(); 其它除此之外还有，寄生构造函数模式、稳妥构造函数模式。 继承组合继承是如今最常见的继承方法。 1234567891011// 使用 混合模式 People 对象function People(name,eye)&#123; this.name = name; this.eye = eye;&#125;People.prototype.say = function ()&#123; alert (this.name); console.log(this)&#125;var man = new People("Flancer一号","small");man.say(); 使用 组合继承 123456789101112131415161718/* * 使用 混合模式 构建 Manman 对象 * 使用 组合继承 实现 Manman对象 继承 People对象*/function Man (name,eye,huzi) &#123; this.huzi = huzi; People.call(this,name,eye) // 属性继承&#125;Man.prototype = new People() // 原型继承Man.prototype.sayhuzi = function () &#123; alert(this.huzi) console.log(this)&#125;var boy = new Man("Flancer二号","big","胡子");boy.sayhuzi();boy.say(); 寄生组合传承12345function inserit(son, father) &#123; var obj = Object.create(father.prototype); son.prototype = obj; obj.constructor = son&#125; 123456789101112131415161718/* * 使用 混合模式 构建 Manman 对象 * 使用 组合继承 实现 Manman对象 继承 People对象*/function Man (name,eye,huzi) &#123; this.huzi = huzi; People.call(this,name,eye) // 属性继承&#125;inserit(Man,People) // 寄生继承 原型Man.prototype.sayhuzi = function () &#123; alert(this.huzi) console.log(this)&#125;var boy = new Man("Flancer二号","big","胡子");boy.sayhuzi();boy.say(); 关于原型链 任何对象在创建时都会有一个__proto__内置属性，它指向创建这个对象的构造函数的原型prototype = {}。除了 undefined 和 NULL，没有构造他们的东西。 任何 函数 (虽然只有函数，也就是除了基本数据类型的所有东西) 在创建时都会给予拥有一个名为prototype的属性，这个属性指向该函数的 原型对象。 在创建 prototype 的同时会在其内部放一个 constructor 指向它的构造函数。 高级技巧可以让开发人员定义 防篡改对象。 防篡改对象通过改变对象属性的特性来指定对象行为。一旦把对象定义为防篡改，就无法撤销了。 方案它们分别为，不可扩展对象、密封对象、冻结的对象。 ES6 中的对象Class一种建立在 原型链原理 上的语法糖。 12345678910111213141516171819202122232425262728293031323334class A &#123; static myMethod() &#123; // 静态方法 不会继承到实例，可以继承到子类，通过调用类调用 return 'hello'; &#125; constructor()&#123; // 构造函数 this.num = 1; &#125; toValue () &#123; // 原型 console.log(this.num) &#125;&#125;A.myMethod(); // 调用静态方法// 子类 B 继承 Aclass B extends A &#123; static myMethod() &#123; // 静态方法 super.myMethod(); // 继承父类静态方法，通过调用类调用，this指向子类而不是实例 &#125; constructor()&#123; super(); // 继承构造函数 this.num = 2; &#125; m () &#123; super.toValue() // 继承原型 &#125; &#125;// 子类 B 实例let b = new B();b.m() // 2 注意 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 方法后面不要加 逗号，会报错。 默认为严格模式。 不存在变量提升。 新扩展Object.assign方法 引用 《JavaScript 高级程序设计》 原型链图片 内存图]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F18%2Fvscode%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JS ”单词本“]]></title>
    <url>%2F2019%2F10%2F22%2Fprototype%2F</url>
    <content type="text"><![CDATA[简介：​ 此本意在随时可温故 原生 JS 可操作数据的方法，以简写的形式提醒自己 JS 都可以用来做什么，就像单词一样。当然有人就问了，现在好多都用 JQ 了，等等什么更强大的框架，但是万变不离其宗。又为什么是简写呢？，往细里说前端相当庞杂，“单词” 怎么拼写不重要，更重要的是要知道有这么个东西可以用，学习的东西渐渐多了就明白，“语言” 即 “工具”，以需求来驱动用什么工具。本文详情参考链接 Array.prototype 在浏览器控制台输入 Array.prototype 即可得到所有的 操作数组的方法。 数组详情参考链接—快速入口 单词表： “单词” 描述 concat() 用于合并两个或多个数组，不改变现有数组，返回新数组 constructor() Array.prototype copyWithin() 浅复制数组的一部分到同一数组中的另一个位置，并返回，不改变原数组的长度。 entries() 返回一个新的 Array Iterator 对象，该对象包含数组中每个索引的键/值对。 every() 测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 fill() 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 fiiter() 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 find() 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 findIndex() 返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1 flat() 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 flatMap() 使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 forEach() 对数组的每个元素执行一次提供的函数。 includes() 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 indexOf() 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 join() 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 keys() 返回一个包含数组中每个索引键的 Array Iterator 对象。 lastIndexOf() 返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 map() 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 pop() 从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 push() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 reduce() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 reduceRight() 接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 reverse() 将数组中元素的位置颠倒，并返回该数组。 shift() 从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 slice() 返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 some() 测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 sort() 用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的,由于它取决于具体实现，因此无法保证排序的时间和空间复杂性 splice() 删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开。 toString() 返回一个字符串，表示指定的数组及其元素。 unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 values() 返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值 继承 Function、 Object String.prototype 在浏览器控制台输入 String.prototype 即可得到所有的 操作数组的方法。 操作 字符串 详情参考链接 即将不支持不建议使用的已忽略 单词表： “单词” 描述 charAt() 从一个字符串中返回指定的字符。 chartCodeAt() 返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 chartPointAt() 返回 一个 Unicode 编码点值的非负整数。 concat() 将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 endsWith() 用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。 includes() 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。 indexOf() 返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。 lastIndexOf() 返回调用String 对象的指定值最后一次出现的索引，在一个字符串中的指定位置 fromIndex处从后向前搜索。如果没找到这个特定值则返回-1 。 localeCompare() 返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 match() 检索返回一个字符串匹配正则表达式的的结果。 matchAll() 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器 normalize() 按照指定的一种 Unicode 正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）。 padEnd() 会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。 padStart() 用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。 repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。 replace() 返回一个由替换值replacement替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。原字符串不会改变。 search() 执行正则表达式和 String 对象之间的一个搜索匹配。 slice() 提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。 split() 使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 startsWith() 使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 substring() 返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 toLocaleLowerCase() 根据任何指定区域语言环境设置的大小写映射，返回调用字符串被转换为小写的格式。 toLocaleUpperCase() 使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。 toLowerCase() 调用该方法的字符串值转为小写形式，并返回。 toString() 返回指定对象的字符串形式。 toUpperCase() 返回一个将调用字符串转换为大写形式的值。（如果这个值不是字符串则会被变成字符串） trim() 会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。 trimEnd() 从一个字符串的末端移除空白字符。trimRight() 是这个方法的别名。 trimStart() 从字符串的开头删除空格。trimLeft()是此方法的别名。 valueOf() 返回一个String对象的原始值（primitive value）。 继承 Function、 Object]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>前端端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float 相关]]></title>
    <url>%2F2019%2F03%2F28%2Ffloat%2F</url>
    <content type="text"><![CDATA[float 相关定义float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反） 如何定位当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。 理解display首先 float 属性会影响到页面的布局，所以涉及到一些 display 的一些块级元素（block），内联元素（inline）及内联块级（inline-block）的知识。 因为 float 元素 定义： “允许文本和内联元素环绕它” 可以使文本和兄弟内联元素环绕，也是设计该属性的初衷。 因为 float 元素定义： “该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性” 对于该句我是这样理解的： 首先 block元素 的默认宽度是 width:auto; 自动调整宽度。在不带float的情况下，block元素 的宽度会自动调整至最大化占据整行，而float元素会自动调整至最小化，在不设置宽高的情况下会被内容撑起。 float元素仅会对自身（宽高默认自适应但可设置），文字及内联兄弟元素（inline元素）环绕，下一个兄弟float元素产生影响。 对于块级（block元素会另起一行）、兄弟父元素（忽略其高度） 及 父兄元素（相对父元素排列，与float元素无关）。 因此： 它会将 float 元素当做 display：block 元素去计算宽高（像是自动添加了 block 框），包裹性 即可设置宽高。 block元素默认高度也是 height:auto 由内容撑起，在计算高度（height 值）时，会忽略浮动的元素的高度，而基于此父元素的下一个文档流的父兄弟元素就也会忽略该浮动元素，及为其父亲 带来 高度塌陷问题。 float 特性总结img div float 使用 float 可以带来 ： 将元素浮向左或右、宽高默认自适应、文字及内联元素环绕、包裹性（可设置宽高）、高度塌陷（高度被父忽略）。 清除浮动为什么要清除浮动根据 float 的 特性，当这些特性影响了我们的布局，即，超出了我们的设计的预期时，我们就想要清除浮动。主要是为了解决 清除文字环绕，和高度塌陷带来的布局问题。 如何清除 利用 clear 属性 利用 BFC 全文参考 float：https://developer.mozilla.org/zh-CN/docs/CSS/floatdisplay：https://developer.mozilla.org/zh-CN/docs/Web/CSS/displayposition：https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#Absolute_positioning块级元素：&lt;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements float对内联元素和块元素的影响 清除浮动的四种方式及其原理理解 完全理解float之“不完全脱离文档流” 理解为何需要清除浮动及清除浮动的方法 行内元素在为什么设置浮动后可以设置高宽 inline-block和float的共性和区别]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>CSS</category>
        <category>float</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Position]]></title>
    <url>%2F2019%2F03%2F28%2Fposition%2F</url>
    <content type="text"><![CDATA[position 定位问题position：static position:static,静态定位，这种定位是默认的，即正常的文档流，一般没有实际作用 特点 静态定位的元素不会受到 top right bottom left 的影响 position：relative position:relative,相对定位，不会脱离文档流，类似于static,默认按照顺序排列，可以通过 margin-top / top margin-right / right margin-bottom / bottom margin-left / left来改变元素的位置，（注意在简写的时候也是按照这个顺序，顺时针），可以看出，都只是相对于正常位置的偏移。 特点 相对于它原本的正常位置偏移，因此它原本的所占的空间不会改变。也就是说，在它之下的文档流元素依然按照它原本的位置排列。 经常被用作绝对定位的容器块。 position：absolute position:absolute,绝对定位，脱离文档流，可以用 top right bottom left​ 来控制元素的位置，需要注意的是，它是相对于最近祖先为非static定位来定位的，如果它的父级元素定位是默认的，它会继续向上找，直到找到为止，如果页面上没有，就相对于 html 。 特点 由于它是脱离文档流的，因此它的变动是不会对文档流的其他布局产生影响的。 在 absolute 定位下，float: left/right ,对它是不起作用的 子绝父相 即，父元素是相对定位（position：relative），子元素是绝对定位（position:absolute），被经常用来定位元素。因此相对定位经常被用作容器块。 position : fixed position : fixed,固定定位，它是相对于浏览器窗口来进行定位的，例如我们经常在网页中见到的 回到顶部 按钮就是利用这种定位，一般使用 top right bottom left,进行操作。 特点 它同样也脱离了文档流，它的位置与文档流无关。 fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才会支持 position：sticky—– 这个定位好好玩啊啊啊，之前没有用过（暴露了我的无知、浅薄、傻了吧唧）。o(╥﹏╥)o position:sticky ,粘（zhan）性定位,基于用户的滚动位置来定位的。它有一个由 top/right/bottom/left构成的特定阀值，也必须有他们才能使粘性定位生效。在跨越特定阀值之前为相对定位（position：relative）,之后为固定定位（position:fixed）,固定在目标位置。 特点： Internet Explorer,Edge 15 及 更早的 IE 版本不支持 sticky 定位。 Safari需要使用 position: - webkit-prefix;来做兼容 。]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>CSS</category>
        <category>position</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js——Readme]]></title>
    <url>%2F2019%2F03%2F27%2FNode%2F</url>
    <content type="text"><![CDATA[README后端语言 后端当然有：Java PHP Python Ruby .Net … Node.js。 啊，作为前端进入后台的切入口，当然是Node.js了。 Node.js是一个 JavaScript 运行时的环境，可以解析执行 js 代码，摆脱了浏览器来运行。 js与node.js的区别：​ - js : EcmaScript语法（if/ for/ var…）、 BOM、 DOM。​ - Node.js : 没有 BOM DOM ，有 EcmaScript 及其一些服务器级别的操作 API，比如：文件读写、网络服务的构建、网络通信、http服务器…等处理。 构建于 Chrome 的 V8 引擎之上（公认的最快的 JS 解析引擎）。 特性：event-driven 事件驱动。​ - non-blocking I/O model 非阻塞IO模型（异步）。​ - lightweight and efficient 轻量高效 等。 相关：基于node开发的npm是放着js相关的绝大多数的包。node.js官方网站 能做什么 Web 服务器后台 命令行工具 npm (node) git (c语言) hexo (node,嘻嘻就是本博客啦(～￣(OO)￣)ブ） 对于前端来说，接触node最多的是它的命令行工具 webpack gulp npm 简单命令行操作 cd 切换目录 dir 列出目录 ls 列出目录 mkdir rm cls //clear 清屏 资源推荐 《深入浅出Node.js》 朴灵，偏理论 《Node.js权威指南》 API讲解 《编写可维护的 JavaScript》 《JavaScript 语言精粹》 《JavaScript 高级编程》 JavaScript 标准参考教程(alph)（阮一峰o(╥﹏╥)o大佬） Node入门 官方API文档 CNODE社区 CNODE-新手入门 中文文档（较老） 在线查看各个文件格式 比较被人熟知的代码规范 重点关注 B/S编程模型 Browser - Server / back-end 模块化编程 RequireJS SeaJs12@import(&apos;文件路径&apos;)//即，node中可以像@import（）一样来引用加载 JS脚本文件 Node常用API 异步编程 回调函数 Promise async generator Express Web 开发框架 Ecmascript 6 … 安装 Node 环境 这里不再赘述，网上一大堆教程（傻瓜式下载安装） 需要注意的是在官网上 LTS 稳定版 Current 最新版 对于已经装过的 输入 node –version 可以更新 node -v ( node –version ) 查看安装是否成功 起步读写 写一个js脚本文件 注意：文件名不要使用 node.js 命名，最好也不要使用中文 如果想要解析某个文件在该文件目录终端输入： 1node xxx.js 没有BOM DOM，有 EcmaScript 及具有文件读取能力等服务器级别的 API。 其中 fs 就是 file-system 的简写，Node想要进行文件操作，必须引入 fs 的这个核心模块。 fs 中提供了与所有文件操作相关的API，例如： fs.readFile 用来读取文件 第一个参数：读取文件路径 第二个参数：回调函数 error错误对象data为null，成功data显示数据error为null 使用 require 方法加载 fs 核心模块12345678var fs = require('fs')fs.readFile('./data/xxx.txt',function(error,data)&#123; if(error)&#123; console.log('读取文件失败') &#125; else &#123; console.log(data.toString()) &#125;&#125;) fs.writeFile 用来写文件 第一个参数：文件路径 第二个参数：文件内容 第三个参数：回调函数 文件写入 error 为null ,未写入打印123456789var fs = require('fs')fs.writeFile('./data/xxx.txt','大家一起加油呀！',function(error)&#123;// console.log('文件写入成功')if (error)&#123; console.log('写入失败')&#125; else &#123; console.log('写入成功')&#125;&#125;) 简单的http服务 使用 node 构建一个 Web 服务器 在 node 中提供了一个核心模块 : http 它可以帮你创建编写服务器 加载 http 核心模块 1var http = require('http') 使用 http.createServer() 方法创建一个Web 服务器，返回一个server 实例 1var server = http.createServer() 提供服务：数据的服务，发/接收请求，反馈（发送响应） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//req: request 请求对象 用来获取客户端的一些请求信息，例如：请求路径//res: response 响应对象 用来给客户端发送响应信息server.on('request',function (req,res) &#123; console.log('受到客户端的请求了，请求路径是：' + req.url) //response 对象有一个方法：write 可以用来给客户端发送响应数据 //write 可以使用多次，但是最后一定要使用 end 来结束响应 否则会一直等待 response.write('hello') response.write('node.js') //告诉客户端，在此处结束了 response.end()&#125;)//注册 request 请求事件，当有请求过来，就会出发服务器的 request 请求事件，执行回调函数//简写合并server.on('request',function (req,res) &#123; //直接 end 的同时发送响应 res.end('hello world')&#125;)//根据不同的请求路径发送不同的响应结果server.on('request',function (req,res) &#123; var url = req.url if (url === '/') &#123; res.end('index page') &#125; else if (url === '/login')&#123; res.end('login page') &#125; else &#123; res.end('404 Not Found...') &#125;&#125;)// end 返回数组server.on('request',function (req,res) &#123; var products = [ &#123; name:'苹果', price:8888 &#125;, &#123; name:'香蕉', price:848 &#125;, &#123; name:'茄子', price:458 &#125; ] //响应内容只能是二进制数据 或者字符串 //数字 对象 数组 布尔值 都不行，因此使用 JSON.stringify 将其转换为 字符串 res.end(Json.stringify(products))&#125;)server.on('request',function (req,res) &#123; //在 服务端 默认发送的数据是 utf8 编码的内容 //浏览器 在不知道的情况下会按照当前操作系统的默认编码去解析 //比如中文的操作系统默认是 gbk //解决：用 res.setHeader Content-Type 内容类型即，告诉浏览器发送的内容用什么编码 res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('hello 你好 world 世界') // text/plain 普通文本 text/html html文件 &#125;) 绑定端口号，启动服务器 12345server.listen(3000,function () &#123; console.log('服务器启动成功，通过 http://127.0.0.1:3000/ 来进行访问')&#125;) //端口号的范围 0~65536//默认端口号最好不要使用，例如 http 服务的 80 如何关闭cmd : Ctrl + C http - fs1234567891011121314151617181920212223242526272829303132333435var http = require('http')var fs = require('fs')var server = http.createServer()server.on('request',function (req,res) &#123; var url = req.url if (url === '/') &#123; fs.readFile('./resourse/index.html',function (err,data) &#123; if (err) &#123; res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('文件读取失败，请稍候再试！') &#125; else &#123; //data 默认是二进制数据 res.setHeader('Content-Type','text/html;charset=utf-8') //在这里不用转 res.end(data) &#125; &#125;) &#125; else if (url === '/image') &#123; fs.readFile('./resourse/image.jpg',function (err,data) &#123; if (err) &#123; res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('文件读取失败，请稍候再试！') &#125; else&#123; //图片不需要指定编码格式 res.setHeader('Content-Type','image/jpeg') res.end(data) &#125; &#125;) &#125;&#125;)server.listen(3000,function () &#123; console.log('服务器启动成功,通过 http://127.0.0.1:3000/ 来进行访问')&#125;) 在线查看各个文件格式 Node 中的 jsEcmaScript 没有 BOM DOM 核心模块Node 为 JavaScript 提供了很多服务器级别的 API ，这些API都被包装到了一个具名的模块中了。例如：文件操作 fs 核心模块，http服务构建的 http 模块，path 路径操作模块，os 操作系统信息模块等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//例子://url 模块用来处理 urlvar url = require('url') //把url每一部分按分割解析出来 var obj = url.parse('/index?name=adfjdfla&amp;message=djskafh',true) console.log(obj) console.log(query)//os 用来获取机器信息var os = require('os') //获取当前机器 CPU 信息 console.log(os.cpus()) //获取 memory 内存 console.log(os.totalmem()) //path 用来操作路径var path = require('path') //获取扩展名 console.log(path.extname('c:/a/d/c/d/hello.txt'))//fs 用来操作文件var fs = require('fs') //得到目录列表中的文件名和目录名 (涉及到手动粗暴制作阿帕奇功能) //同时涉及到ES6 模板字符串`` 及 $&#123;item&#125; 替换server.on('request',function(req,res)&#123; var url = req.url fs.readFile('./template.html',function(err,data)&#123; if(err)&#123; return res.end('404 Not Found') &#125; fs.readdir('D://node/js',function(err,files)&#123; if (err) &#123; return res.end('404 not Found') &#125; var content = '' files.forEach(function(item)&#123; content += `&lt;li&gt;$&#123;item&#125;&lt;/li&gt;` &#125;) data = data.toString() data = data.replace('☺',content) res.end(data) &#125;) &#125;)&#125;) 用户自定义模块 require 是一个方法，作用：（1）用来加载模块（2）获取加载文件模块导出的接口 对象 加载顺序即：遇到 require 便中断执行加载模块 require 加载自定义模块的，其中相对路径 ./ 不能省略，否则会当成核心模块 报错 node 中没有全局作用域，只有模块作用域，因此无法在 加载模块 中调用 上级或下级模块中的 变量 或 方法 exports是一个 对象 解决模块之间的通信 123456//a.js require 里加载另一个文件路径 var bExports = require('./b')console.log(bExports.xyz) // 2. ...console.log(bExports.foo)var fs = require('fs') //核心模块本质上也是使用 fs 模块里的 exports 对象里导出的成员 12345678//在每个文件模块中都提供了一个对象：exports//exports 默认是一个空对象//你要做的就是把所有需要被外部访问的成员挂载到这个 exports 对象中var xyz = '1.我是导出的自定义的变量'exports.xyz = '2.我才是导出的自定义的变量'exports.foo = 'hello' 第三方模块在node中使用模板引擎（art-template） 1234567891011121314151617181920//在浏览器中需要引用 script三连 除了 &#123;&#123;&#125;&#125; 其他都被原模原样输出&lt;script scr=&quot;node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/template&quot; id=&quot;tpl&quot;&gt; &lt;p&gt;我是&#123;&#123;1&#125;&#125;&lt;/p&gt; &lt;p&gt;我是&#123;&#123;2&#125;&#125;&lt;/p&gt; &lt;p&gt;我是&#123;&#123;3&#125;&#125;&lt;/p&gt; &lt;p&gt;我喜欢循环&#123;&#123;each 4&#125;&#125; &#123;&#123;$value&#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/p&gt;&lt;/script&gt;&lt;script&gt; var ret = template(&apos;tpl&apos;,&#123; 1:&apos;a&apos;, 2:&apos;b&apos;, 3:&apos;c&apos; 4:[ &apos;循环value&apos;, &apos;循环value&apos;, &apos;循环value&apos; ] &#125;)&lt;/script&gt; 123456789101112npm install art-template // node 安装//--------------------------------铁血直男分割----var template = require('art-template)var tpl = template.render('模板字符串&#123;&#123;对象&#125;&#125;',&#123; 对象:'替换成我' &#125;)console.log('tpl')//--------------------------------铁血直男分割----var tpl = template.render(data.toString(),&#123; 对象:'替换成我' &#125;) 服务端渲染和客户端渲染的区别： 客户端渲染不利于 SEO 搜索引擎优化，至少两次请求，发起 ajax 在客户端渲染 服务端渲染是可以被爬虫抓取到的，客户端异步渲染难以被抓取到 好的网站是两者结合的，查看源代码可见到的内容就是服务端渲染的 服务端渲染 ：商品列表 客户端渲染：评论列表 静态资源 浏览器在收到 HTML 响应的内容之后，从上至下解析，其中若发现 link、script、img、iframe、video、audio等带有 src 或者 href (link) 属性标签（具有外链作用）的时候，浏览器会自动对这些资源发起请求 为了方便统一处理静态资源，我们把约定的所有的静态资源（css、img、js、lib(第三方包)）都存放在 public 目录里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var http = require('http')var fs = require('fs')var template = require('art-template')var url = require('url')//假信息var comments = [ &#123; name:'张三', message:'说点啥', dateTime:'2020/10/10' &#125;, &#123; name:'李四', message:'说点啥', dateTime:'2020/10/10' &#125;, &#123; name:'王五', message:'说点啥', dateTime:'2020/10/10' &#125;]http .createServer(function (req,res) &#123; var url = req.url var parseObj = url.parse(req.url,true) var pathname = parseObj.pathname if (pathname === '/') &#123; //请求主页 fs.readFile('./views/index.html',function (err,data) &#123; if (err) &#123; return res.end('404 Not Found') &#125; //用模板引擎渲染 var htmlStr = template.render(data.toString(),&#123; comments: comments &#125;) res.end(htmlStr) &#125;) &#125; else if (pathname === '/post')&#123; //a链接请求 fs.readFile('./view/post.html',function(err,data)&#123; if (err) &#123; res.end('404 Not Found') &#125; res.end(data) &#125;) &#125; else if (pathname.indexOf('/public/') === 0)&#123; //请求静态资源 //统一处理：如果请求路径是以/public/开头的，则我认为你要获取 public //中的某个资源，可以将其请求路径当做文件路径来直接获取 fs.readFile('.' + pathname,function(err,data)&#123; if (err) &#123; return res.end('404 Not Found') &#125; res.end(data) &#125;) &#125; else if (pathname === '/pinglun') &#123; //提交评论 var comment = parseObj.query//获取数据 comment.dateTime = '2017-11-12 17:11:22' comments.push(comment) //放入到数组中 //如何通过服务器让客户端重定向？ // 1.状态码设置为 302 临时重定向 statusCode // 2.在响应头中通过 Location 告诉客户端往哪里重定向 setHeader res.statusCode = 302 res.setHeader('Location','/') res.end() //如果客户端发现收到服务器的响应的状态码是 302 就会自动去响应头中找 Location 这样它就会自动跳转了 &#125; &#125;) .listen(3000,function()&#123; &#125;)//注意: 1. 服务端的文件路径就不要写相对路径了，都直接写成：/public/xxx// 2. cmd node enter 可以像浏览器控制台一样走读测试API// 3. 301 永久重定向 浏览器会记住是否进行了重定向 比如：每次都从 .com 跳转到 .com.cn的网站// 4. 302 临时重定向 浏览器不记忆 每次都会尝试访问不通的路径 1234567891011121314151617181920212223242526272829&lt;!--index展示列表--&gt;&lt;ul&gt; &#123;&#123;each comments&#125;&#125; &lt;li&gt;&#123;&#123;$value.name&#125;&#125;说：&#123;&#123;$value.message&#125;&#125; &lt;span&gt;&#123;&#123;$value.dateTime&#125;&#125;&lt;/span&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt;&lt;!--简单的H5表单验证--&gt;&lt;!--以前的表单是如何提交的？表单中需要提交的表单控件元素必须具有 name 属性。表单提交分为： 1.默认提交行为 2.表单异步提交action 表单提交的地址，就是请求的 url 地址method 请求方法 get post--&gt;&lt;form action="/pinglun" method="get"&gt; &lt;div&gt; &lt;label for="input_name"&gt;name&lt;/label&gt; &lt;input type = "text" required minlength="2" maxlength="10" id="input_name" name="name" placeholder="Email"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="textarea_message"&gt;message&lt;/label&gt; &lt;textarea cols="30" rows="10" required minlength="5" maxlength="20" id="textarea_message" name="message"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/form&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041// 补充:// ES5 .forEach IE8不支持 遍历 数组 的方法// 伪数组是对象 对象原型链中没有 forEach;['abc','d','efg'],function(item,index)&#123; console.log(item)&#125;// jQ实例对象，伪数组 转 数组;[].slice.call($('div'))// 补充模拟 .slice 原型Array.prototype.mySlice = function () &#123; var start = 0 var end = this.length if (arguments.length === 1)&#123; start = arguments[0] &#125; else if (arguments.length === 2)&#123; start = arguments[0] end = arguments[1] &#125; var tmp = [] for (var i = start; i &lt; end; i++)&#123; tmp.push(this[i]) &#125; return tmp&#125;var fakeArr = &#123; // 伪数组 0:'abc', 1:'efg', 2:'haha', length:3&#125;[].mySlice.call(fakeArr) // 由此得到 数组// 遍历 jQ 元素 .each 在jQ的原型链中 可以遍历jQ实例对象(元素/伪数组),也可以兼容问题$.each(['abs','b','egf'],function(index,item)&#123; console.log(item)&#125;)// art-template 模板引擎&#123;&#123;each 数组&#125;&#125;&lt;li&gt;&#123;&#123;$value&#125;&#125;&lt;/li&gt;&#123;&#123;/each&#125;&#125; 什么是模块化 具有文件作用域 通信规则有 加载、导出 CommonJs 模块规范在 Node 中的 JavaScript 的一个重要概念：模块系统 模块作用域 避免了命名污染 使用 require 方法来加载模块 优先从 缓存加载（提高加载模块效率） 判断模块标识 12345678// 语法:var 自定义变量名 = require('模块标识/文件路径')// 作用：1.执行被加载模块中的代码// 2.得到被加载模块中的 exports 导出接口对象// 模块标识：1.非路径 模块标识 （核心模块，第三方模块）// 2.路径形式模块 ./(当前目录) ../(父级目录) /xxx (磁盘根路径)//第三方加载：1.node_modules/art-template/package.json 中的 main 属性记录了 art-template 的入口模块，然后加载使用这个第三方包// 2.找不到会逐级向上查找 index 加载项，直到根目录，因此兄弟文件中无法以第三方包加载的方式加载 node_modules 中的文件 使用 exports 接口对象用来导出模块中的成员 由于模块作用域，默认文件中的所有成员只在当前文件模块中有效 导出需要公开的成员，导出多个成员必须在对象中 123456789// 语法：exports.a = 123exports.b = 'hello'exports.c = function () &#123; console.log('ccc')&#125;exports.d = &#123; foo:'ddd'&#125; 使用 module.exports 可以 只导出某一个成员 12345678910111213141516171819// 语法：module.exports = 'hello'module.exports = function () &#123; return x + y&#125;// 此时 require 文件中导出的直接为该值var fun = require('./xfs')console.log(fun)// 注意：一个文件中同时出现两个 后面的 会覆盖 前面的，即 重新赋值// 导出多个成员的方式module.exports = &#123; str:'hello', fun:function () &#123; return x + y &#125;&#125; module 和 exports 原理 在 Node 中，每个模块内部都有一个自己的 module 对象，该 module 对象中的一个成员叫：exports ，其也是一个对象。 每个文件都默认在代码的最后一句：return module.exports，另一个文件通过 require 得到。 12345678910111213141516var module = &#123; exports:&#123; foo:'bar' &#125;&#125;// 等同于 module.exports.foo = 'bar'// 等同于var exports = module.exportsexports.foo = 'bar'// 省略声明，简化为exports.foo = 'bar'// 注意：exports = 'bar' //无法执行 因为 exports 被重新赋值 而最后返回的是 module.exports// 重新建立引用关系的正确方法exports = module.exports package.json 包描述文件 12345npm install art-template --save # --save 写进包依赖文件npm init # 初始化 具有引导作用npm install # 根据 package.json 里 dependencies 定义好的安装依赖 npm 包管理工具 在其官网上发布 npm 命令行工具，伴随着 node 安装 1234567891011121314151617npm --version # 查看版本npm install --global nppm # 升级版本 --global 安装到全局npm init -y # 跳过向导 快速生成npm install # 简写 npm inpm install --save # 简写 npm i -Snpm uninstall 包名 # 只删除 有依赖项依然会保存 简写 npm unnpm uninstall --save 包名 # 同时删除依赖项 简写 npm un -Snpm help # 使用帮助npm uninstall --help # 查看具体命令简写 解决被墙问题 （淘宝镜像 cnpm） 123456789101112npm install --global cnpm # 安装淘宝镜像 之后都将 npm 改为 cnpm# 如果不想通过淘宝服务器来下载npm install jquery --registry=http://registry.npm.tobao.org# 手动配置选项 避免每次都要输入链接npm config set registry https://registry.npm.taobao.org# 查看 npm 配置信息npm config list# 补充：mkdir cnpm-demo # 创建文件 cnpm-demormdir cnpm-debo # 删除文件 Express原生的 http 不足以应对开发需求，需要使用框架加快开发效率。 起步npm install express --save 安装 hello word1234567891011121314151617181920212223242526272829// 1.引包var express = require('express')// 2.创建服务器应用程序 等价于 http.createServervar app = express()// 3.公开指定目录 用户可以直接通过 /public/xx的方式访问 public 目录中的资源了app.use('/public/',express.static('./public/'))// 4.当服务器收到 get 请求 / 的时候，执行回调处理函数app.get('/',function (req,res) &#123; res.send('hello express!')&#125;)app.get('/about',function (req,res) &#123; res.send('你好 express!') // 不用声明 请求头&#125;)// 5.相当于 server.listenapp.listen(3000,function()&#123; console.log('app is running at port 3000.')&#125;)// 补充：// 1. 在文件操作的相对路径中// ./data/a.txt 等价于 data/a.txt 相对于当前目录// /data/a.txt 绝对路径 当期文件模块所处磁盘根目录// 2. 模块加载路径中用的是 相对路径 但是不能省略 ./ require('./data/foo.js') 修改完代码自动重启使用第三方命令行工具：nodemon 12345#安装npm install --global nodemon #使用 nodemon app.js 代替 node app.jsnodemon app.js express 基本路由路由器：请求方法、请求路径、请求处理函数 get：当你用 GET 方法请求 / 时，指定对应的处理函数 123app.get('/',function()&#123; res.send('Hello World!')&#125;) post：当你用 POST 方法请求 / 时，指定对应的处理函数 123app.post('/',function()&#123; res.send('Hello World! With Post')&#125;) 路由也可以看成是一张表，里面有具体的映射关系。 1234app .get('/',函数名) .get('/login',函数名) .post('/about',函数名) express 之 static-server 的静态资源服务1234567891011// 当以 /public/ 开头的时候，去 ./public/目录访问资源app.use('/public/',express.static('./public/')) // 推荐方式 易辨识// 以 /a/ 开头 相当于 publicapp.use('/a/',express.static('./public/'))// 也可以省略，省略时 不加 public 相当于 为空嘛app.use(express.static('./public'))// __dirname 指的是当前文件夹app.use('static',express.static(path.join(__dirname,'public'))) express 之 使用 art-template安装： 12npm install --save art-templatenpm install --save express-art-template 配置： 123456789101112131415161718192021222324// 第一个参数：表示当用 .art 文件渲染时，使用 art-template 模板引擎// express-art-template 就是指 express 里的 art-template app.engine('art',require('express-art-template'))// Express 为 Response 提供了一个 render 方法，仅在配置模板引擎时使用// 第一个参数不能写路径 express 默认所有的视图文件会去 views 目录查找，因此 view可省app.set('views',render函数默认路径) //修改默认文件夹// res.render('html模板名',&#123;模板数据&#125;)app.get('/',function(req,res)&#123; res.render('404.art') //第二个参数可选&#125;)//或者将两个都改回 .htmlapp.engine('html',require('express-art-template'))app.get('/',function(req,res)&#123; res.render('404.html') //第二个参数可选&#125;)// 第二个参数是模板数据app.get（'/admin',function(req,res)&#123; res.render('admin/index.html',&#123; title:'管理系统' &#125;)&#125;) 使用时的 html 不变： 1&lt;h1&gt;admin &#123;&#123;title&#125;&#125;&lt;/h1&gt; 用 express 修改案例案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 引包var express = require('express')// 创建服务器应用程序 等价于 http.createServervar app = express()// 假数据var comments = [&#123;&#125;,&#123;&#125;,&#123;&#125;]// 公开指定目录 用户可以直接通过 /public/xx的方式访问 public 目录中的资源了app.use('/public/',express.static('./public/'))// 配置模板引擎app.engine('html',require('express-art-template'))// 当服务器收到 get 请求 / 的时候，执行回调处理函数app.get('/',function (req,res) &#123; res.render('index.html'),&#123; comments:comments &#125;&#125;)app.get('/post',function (req,res) &#123; res.render('post.html') // 不用声明 请求头&#125;)app.get('/pinglun',function (req,res) &#123; // Express 内置了一个 API 可以直接通过 req.query 来获取 var comment = req.query // 直接获取 name message comment.dateTime = '20017-22-5' // unshift() 方法可向数组的开头添加一个或更多元素,并返回新的长度 comments.unshift(comment) res.redirect('/') // 重定向&#125;)// 相当于 server.listenapp.listen(3000,function()&#123; console.log('app is running at port 3000.')&#125;)// 补充：// 1. 在文件操作的相对路径中// ./data/a.txt 等价于 data/a.txt 相对于当前目录// /data/a.txt 绝对路径 当期文件模块所处磁盘根目录// 2. 模块加载路径中用的是 相对路径 但是不能省略 ./// require('./data/foo.js') Express 获取表单 POST 请求体数据Post 无法使用 req.query 获取参数，需使用第三方插件 （Express 中间件）。 1npm install --save body-parser 配置： 123456789101112131415161718192021// 获取var express = require('express')var bodyParser = require('body-parser')var app = express()// 配置 body-parser 中间件// 只要加入这个配置，则在 req 请求对象上会多出来一个属性：bodyapp.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())// 使用app.post(function(req,res)&#123; var comment = req.body comment.dateTime = '2020/02/02' comments.unshift(comment) res.redirect('/')&#125;)// 补充：在输入框输入 url 获取页面的请求都是 get 请求// Express 会自动结束请求 end() Express 之 crud 增删改查起步1234567891011121314151617181920212223242526272829303132var express = require('express')var app = express()app.use('/node_modules',express.static('./node_modules/'))app.use('public',express.static('./public/'))app.engine('html',require('express-art-template'))app.get('/',function(req,res)&#123; // readFile 的第二个参数是可选的，传入 utf8 指按其编码 fs.readFile('./db.json','utf8',function(err,data)&#123; // 此时 data 转为了 字符串 if(err)&#123; return res.status(500).send('Server error.') &#125; // 从文件中读取到的一定为字符串，需手动转成对象 var students = JSON.parse(data).students res.render('index.html',&#123; fruits:[ '苹果'，'香蕉'，'橘子' ], students: students // 将 data 转为 对象 . 出 students &#125;) &#125;)&#125;)app.listen(3000,function()&#123; console.log('running...')&#125;) 路由设计 请求方法 请求路径 get 参数 post 参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生 POST /students name/age/gender/hobbies 处理添加学生 GET /students/edit id 渲染编辑页面 POST /students/back id/age/genter/hobbies 处理 GET /students/delate id 处理删除请求 路由模块提取 模块职责要单一，增强可维护性，提高开发效率 新建文件 router.js 使用 Express 提供了 router 方法 1234567891011121314151617181920212223242526272829303132/** app.js 入口模块 职责：启动服务，做一些服务相关配置 模板引擎 body-parser 解析表单 post 请求体 提供静态资源服务 监听端口启动服务 挂载路由*/var express = require('express')var router = require('./router')var app = express()app.use('/node_modules/',express.static('./node_module/'))app.use('/public/',express.static('./public/'))app.engine('html',require('express-art-template'))// 配置模板引擎和 body-parse 一定要在 app.use(router) 挂载路由之前// 这是中间件的执行流程// parse application/x-www-form-urllencodedapp.use(bodyParser.urlencoded(&#123; extended:false &#125;))//parse application/jsonapp.use(bodyParser.json())// 把路由容器挂载到 app 服务中app.use(router)app.listen(3000,function()&#123; console.log('running 3000...')&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** router.js 入口模块 职责：处理路由 根据不同的请求方法将请求路径设置具体的请求函数*/var fs = require('fs')var express = require('express')var students = require('./student') // 下面数据操作模块// 1. 创建一个路由容器var router = express.Router()// 2.把路由都挂载到 router 路由容器中//首页router.get('/students',function (res,req) &#123; Student.find(function (err,students) &#123; if (err) &#123; return res.status(500).send('Server error') &#125; res.render('index.html',&#123; fruits:[ '苹果', '香蕉', '橘子' ], students:students // 调用封装的 find 调回数据 &#125;) &#125;)&#125;)// 渲染添加数据页router.get('/students/new',function (res,req) &#123; res.render('new.html') &#125;)// 处理添加学生页面router.post('/students/new',function (res,req) &#123; // 1.获取表单数据 ： // 先读取为字符串，转对象，往对象中 push 数据，转字符串再次写入 // 2.处理：将数据保存到 db.json 文件中用以持久化 // 3.发送响应 Student.save(req.body,function (err) &#123; if (err) &#123; return res.studus(500).send('Server error.') &#125; res.redirect('/students') &#125;)&#125;)// 渲染编辑页面// &lt;a herf="/students/edit?id=&#123;&#123;$value.id&#125;&#125;"&gt;编辑&lt;/a&gt;router.get('/students/edit',function (req,res) &#123; res.render('edit.html',&#123; var byId = parseInt(req.query.id) Student.findById(byId,function (err,student) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.render('edit.html',&#123; student:student &#125;) &#125;) &#125;)&#125;)// 处理编辑数据// &lt;input type="hidden" name="id" id="&#123;&#123; student.id &#125;&#125;"&gt; 用来放一些不希望被用户看见，但是需要被提交到服务端的数据router.post('/students/edit',function (req,res) &#123; // 1.获取表单数据 req.body // 2.更新 Student.updateById() // 3.发送响应 Student.updateById(req.body,function (err) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.redirect('/') &#125;)&#125;)// 删除数据 router.get('students/delate',function (req,res) &#123; // 1.获取要清除的 id // 2.根据 id 执行 // 3.根据操作结果发送相应数据 Student.delateById(id,function (err) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.redirect('/students') &#125;)&#125;)//3. 把 router 导出module.exports = router 封装提取数据操作模块 数据操作模块 封装异步API （node 基础重点） 类比 jQ (重点) 1234567891011121314151617181920212223242526272829303132333435363738// 封装异步 API// setTimeout 是异步操作// 如果需要获取一个函数异步操作的结果，则必须通过回调函数来获取function fn (callback) &#123; //var callback = function (data) &#123; console.log(data) &#125; setTimeout(function () &#123; var data = 'hello' callback(data) &#125;,1000)&#125;fn(function (data) &#123; console.log(data)&#125;)// 回调函数：获取异步操作的结果// jQ $.get('dsdf',function(data)&#123; &#125;)$.ajax(&#123; url:'dsd', type:'get', data:&#123; foo:'bar' &#125;, // 使用者只负责传递,封装者需要去调用 success:function()&#123; &#125;&#125;)function ajax(options) &#123; options.success(data)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** student.js 数据操作模块 * 职责：操作文件中的数据，只处理数据，不关心业务*/var fs = require('fs')var dbPath = './db.json'/** * 获取所有数据列表 * callback 中的参数 * 第一个是 err ：成功是null,错误是错误对象 * 第二个是 data ：成功是数组，错误是 undefined * return []*/exports.find = function (callback) &#123; fs.readFile(dbPath,'uft8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; callback(null,JSON.parse(data).students) &#125;)&#125;// 调用：在 router.js 中 find(function (err,data) &#123;&#125;)/** * 根据 id 查找获取 * @param &#123;Number&#125; id 数据id * @param &#123;Function&#125; callback 回调函数*/exports.findById = function (id,callback) &#123; fs.readFile(dbPath,'uft8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students var ret = students.find(function (item) &#123; return item.id === parseInt(id) &#125;) return callback(null,ret) &#125;)&#125;// 调用 Student.findById(id,function (err,student) &#123;&#125;)/** * 添加保存数据*/exports.save = function (students,callback) &#123; fs.readFile(dbPath,'uft8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 处理 id 唯一的，不重复 students.id = students[students.length - 1].id + 1 students.push(student) var fileData = JSON.stringify(&#123; students:students &#125;) fs.writeFile(dbPath,fileData,function (err) &#123; //写入数据 if(err)&#123; return callback(err) &#125; callback(null) &#125;) &#125;)&#125;// 调用：save(&#123;name:'xx',age:18&#125;,function(err)&#123;if(err)&#123;&#125;else&#123;&#125;&#125;)/** * 更新数据 （编辑）*/exports.updateById = function(student,callback)&#123; fs.readFile(dbPath,'utf8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 将 id 改为数字类型 student.id = parseInt(student.id) // EcmaScript 6 中的一个数组方法：find // 即，符合条件终止遍历，同时返回遍历项 var stu = students.find(function (item) &#123; return item.id === student.id &#125;) // 遍历拷贝对象 for (var key in student) &#123; stu[key] = student[key] &#125; // 把对象数据转换为字符串 fs.write(dbPath,fileData,function(err)&#123; if (err) &#123; return callback(err) &#125; callback(null) &#125;) &#125;)&#125;// 调用 updateById(&#123;id:1,name:'xx',age:15&#125;,function(err)&#123;&#125;)/** * 删除数据*/exports.delateById = function(id,callback)&#123; fs.readFile(dbPath,'utf8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // findindex 方法专门用来根据条件查找元素的下标 var delateId = students.findIndex(function (item)&#123; return item.id === parseInt(id) &#125;) students.splice(delateId,1) &#125;)&#125;// 调用 delateById(id,function(err)&#123;&#125;) 案例总结 入口文件 （main.js） 处理模板、配置开放静态资源、配置模板引擎、简单路由渲染静态首页 路由设计 提取路由模块 准备处理文件数据模块 写好结构 实现具体功能 通过路由收到请求 接收请求中的数据 get （req.query） / post （req.body） 用数据操作 api 处理数据 （find）/ （findIndex） 根据操作结果发送响应 12345678- 补充 1 ： + (ctrl + alt) 快捷键 + 函数是一种数据类型，可以作为 参数 返回值。 + 一般情况下，把函数作为参数的目的就是为了获取函数内部的异步操作 + 涉及到 JavaScript 底层概念：单线程、事件循环 - 凡是需要得到一个函数内部异步操作的结果 必须通过 回调函数，比如： + setTimeout/readFile/writeFile/ajax/readdir 1234567891011121314151617181920212223242526272829303132333435363738394041// 例一：function add(x,y) &#123; console.log(1) setTimeout(function()&#123; console.log(2) var ret = x + y return ret &#125;,1000) console.log(3) // 到这里就执行结束了，不会等定时器，没有返回值，默认返回 undefined &#125; console.log(add(10,30))// 例二：function add(x,y,callback) &#123; //形参变量 及 返回值 console.log(1) setTimeOut(function () &#123; // 异步操作 var ret = x + y callback(ret) &#125;,1000)&#125;add(10,20,function (ret) &#123; // 在此处定义 实参变量 ，再把结果传回这里 // 回调函数 console.log(ret)&#125;)// 例三：基于原生 XMLHTTPRequest 封装 get 方法function get(url,callback) &#123; var oReq = new XMLHttpRequest() // 当加载成功后调用指定函数 oReq.onload = function () &#123; // 需要拿到这里的数据 callback(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send()&#125;get('/url.json',function (data) &#123; console.log(oReq.responseText)&#125;) 12345678910111213- 补充2： + javascript 天生不支持模块化 + node.js 支持（require,exports）commonJS + 浏览器中需要第三方库来像在 Node 一样进行模块化编程 * require.js AMD * sea.js CMD + 无论是 CommonJS AMD CMD UMD EcmaScript6 Modules 官方规范 * 都是为了解决 JavaScript 的模块化问题- app.use + 开放静态资源、加载中间件- package-lock.json + 保存了 node_modules 中的所有信息（版本、下载地址），提升下载速度 + lock 即可以避免三方件自动升级版本 123456789// EcmaScript 6 对数组新增了很多方法// find 找元素 和 findIndex 找下标// 控制台 Array.prototype 即可找到操作数组的方法// 其中遍历的还有：// every()，每一个都符合条件 返回布尔值 true// includes()// some()，满足其中一个返回 true// map// reduce MongoDB （node.js）介绍安装关系型数据库 和 非关系型数据库 关系型数据库 表 就是关系，就是指 表与表之间存在关系 所有的关系型数据库都想需要通过sql语言来操作 所有的关系型数据库在操作之前都需要设计表结构 数据表同时支持 约束，为了保证数据的完整性 唯一的 主键 默认值 非空 非关系型数据库 （也可以加入 关系） 有些非关系数据库就是 key-value 对儿 MongoDB 是最像关系型数据库的非关系型数据库 数据库 =&gt; 数据库 数据表 =&gt; 集合（数组） 表记录 =&gt; 文档对象 它不需要设计表结构（没有结构性） mongoDB 数据库的基本概念可以看做是一个大的集合对象： 其中可以有多个数据库 一个数据库可以有多个集合（表） 一个集合可以有多个文档 （表记录） 文档结构很灵活，没有任何限制，不需要像 MySOL 一样先创建数据库、表、设计表结构，这里只需要在你插入数据的时候，指定往哪个库和集合操作就可以了 123456789101112131415161718192021&#123; qq:&#123; // 数据库 users:[ // 数据表 &#123;name:'azhong',age:15&#125;, // 表记录 &#123;&#125;, &#123;&#125;, &#123;&#125; ... ], products:[ ], ... &#125;, taobao:&#123; &#125;, baidu:&#123; &#125;&#125; 安装 下载安装 配置环境变量 查看版本 mongod --version 启动关闭数据库启动： 123# mongodb 默认使用执行 mongod 命令所处盘符根目录下的 /data/db 作为自己的数据存储目录# 所以在第一次执行该命令之前先自己动手建一个 /data/dbmongod 如果想要修改默认的数据存储目录，可以： 1mongod --dbpath=数据存储目录路径 停止： 12在开启服务的控制台，直接 Ctrl + c或者直接关闭控制台 连接和退出数据库1234# 该命令默认连接本机的 mongodb 服务mongodb# 在连接状态输入 exit 退出连接exit 基本命令 show dbs：查看显示所有数据库 db：查看当前操作的数据库 use 数据库名称：切换到指定数据库（如果没有会新建）。例如：use itcast db.students.insertOne({&quot;name&quot;:&quot;Jack&quot;})：插入数据，students 指的是集合 show collections，显示集合 db.students.find()：查询所有数据集合 在 node 中如何操作 MongoDB 数据使用 node mongodb npm 包来操作:1npm install mongodb --save 官方指导流程 使用第三方 mongoose 来操作 MongoDB 数据库第三方包：mongoose 基于 MongoDB 官方的 mongodb包再次做了封装 1npm install mongoose --save mongoose 官网 官方指南 官方 API 文档 1234567891011121314151617181920// 1. 引包const mongoose = require('mongoose');// 2. 连接 MongoDB 数据库 连接本机 test 数据库// 如果没有，在创建第一条数据库时自动创建mongoose.connect('mongodb://localhost:27017/test',&#123;useNewUrlParser: true&#125;);// 3. 之后延伸// mongoose.Promise = global.Promise// 4. 创建一个模型，设计数据库// MongoDB 是动态的，非常灵活，直接在代码设计数据库// mongoose 使其设计编写过程变得简单const Cat = mongoose.model('Cat', &#123; name: String &#125;);// 5. 实例化一个 Catconst kitty = new Cat(&#123; name: 'Zildjian' &#125;);// 6. 持久化保存 kitty 实例kitty.save().then(() =&gt; console.log('meow')); mongoose 入门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var mongoose = require('mongoose')var Schema = mongoose.Schema// 连接数据库mongoose.connect('mongodb://location/itcast',&#123; useMongoClient:true &#125;)// 设计集合结构（表结构），主要是为了 保证数据的完整性，不要有脏数据var blogSchema = new Schema(&#123; title: String, // 字段名称就是表结构的属性名称 author: String, // 指定了值的类型 body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;, username: &#123; type: string, require: true // 该字段必须有，不能为空 &#125;&#125;);// 3. 将文档结构发布为模型 // mongoose.model 方法用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数用来表示数据库名称，mongoose 会自动生成 小写复数 的集合名称 User =&gt; users// 第二个参数：架构 Schema// 返回值：模型构造函数var Blog = mongoose.model('Blog', blogSchema);// 4. 使用操作集合中的数据（增删改查）var admin = new Blog(&#123; ...// 按照表结构写数据&#125;)// 5. 存入数据admin.save(function(err,ret)&#123; if (err) &#123; console.log('保存失败') &#125; else &#123; console.log('保存成功') console.log(ret) &#125;&#125;)// 查询=============铁血直男分割线Blog.find(function (err,ret) &#123; // 查询所有 if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;)// 按条件查询 Blog.find(&#123; username: 'azhong'&#125;,function (err,ret) &#123; // 查询所有 if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret)&#125;)// 按条件查询单个 没有条件查询第一个 查不到为 nullBlog.findOne(&#123; username: 'azhong', password: '12345'&#125;,function (err,ret) &#123; // 查询所有 if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret)&#125;)// 删除=============铁血直男分割线Blog.remove(&#123; username: 'azhong', password: '12345'&#125;,function (err,ret) &#123; if (err) &#123; console.log('删除失败') &#125; else &#123; console.log(ret)&#125;)// 更新=============铁血直男分割线Blog.findByIdAndUpdate('sdafasdfadaf2erwrq',&#123; username: 'azhong', password: '12345666'&#125;,function (err,ret) &#123; if (err) &#123; console.log('删除失败') &#125; else &#123; console.log(ret)&#125;) 使用 mongoose 修改案例1234567891011121314151617181920212223242526272829303132333435363738394041var mongoose = require('mongoose')mongoose.connect('mongodb://localhost/itcast',&#123; useMongoClient:true &#125;) //链接数据库，没有会新建var Schema = mongoose.Schema// mongoose.model('Comment',new Schema(&#123;&#125;))var commentSchema = new Schema(&#123; // 设计结构 name: &#123; type: String, required: true, // 是否为必填项 &#125;, gender:&#123; type: Number, enum: [0,1], // 枚举 必须是 0/1 default: 0 // 默认值 是 0 &#125;, message: &#123; type: String, required:true &#125;, date: &#123; type:String &#125;&#125;)module.exports = mongoose.model('Comment',commentSchema)// mongodb 启动数据库 node app.js 启动服务器// &#123;$value.id&#125; =&gt; &#123;$index + 1&#125;// 处理添加学生 保存数据，其它 API名称一样所以不用改new Comment(req.body).save(function (err) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.redirect('/students')&#125;)// mongodb 的id 默认为 _idComment.findById(req.query.id.replace(/"/g,''),function()&#123;&#125;)// replace 字符串模式 简单，但不支持全局和忽略大小写// 正则模式 支持全局和忽略大小写 MySQL (node.js)安装（npm）入门参考 1npm install mysql 入门12345678910111213141516171819202122// 加载包var mysql = require('mysql');// 创建连接var connection = mysql.createConnection(&#123; host : 'localhost', // 本机 user : 'me', // 用户名 password : 'secret', // 密码 database : 'my_db' // 数据库&#125;); // 连接数据库connection.connect(); // 执行数据操作 增删改查都写在这里connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; //throw err 阻止执行，抛出异常（打印到控制台） console.log('The solution is: ', results[0].solution);&#125;); // 关闭连接connection.end(); Navicat 数据库可视化工具 重难点提取promise问题：callback hell（回调地狱）即，在异步请求中嵌套异步请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445var fs = require('fs')fs.readFile('./data/a.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data)&#125;)fs.readFile('./data/b.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data)&#125;)fs.readFile('./data/c.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data)&#125;)// 问题：三个异步编程，异步编程不一定谁先谁后执行// 需求：希望由自己制定顺序执行// 解决：通过回调嵌套的方式保证顺序性fs.readFile('./data/a.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data) fs.readFile('./data/b.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data) fs.readFile('./data/c.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data) &#125;) &#125;)&#125;)// 新问题，嵌套过深，难以维护解决 EcmaScript 6 API promisepromise 承诺 保证 解决上述问题，是 ES6 的 API Promise 容器中存放了一个异步任务 Pending 正在发生 进入以下一种状态 Resolved 已解决 Rejected 未解决 123456789101112131415161718// 创建 Promise 容器// 1.Promise 容器一旦创建，就开始创建里面执行的代码console.log(1)new Promise(function () &#123; console.log(2) fs.readFile('./data/a.txt','utf8',function (err,data) &#123; if (err) &#123; // 失败了，承诺容器中的任务失败了 console.log(err) &#125; else &#123; // 承诺容器中的任务成功了 console.log(data) console.log(3) &#125; &#125;)&#125;)console.log(4)// 输出 1/2/4/3 语法：123456789101112131415161718// Promise 本身不是异步，但是内部往往都会封装一个异步任务var el = new Promise(function (resolve,reject) &#123; fs.readFile('./data/a.txt','utf8',function (err,data) &#123; if (err) &#123; // 这里调用 resolve 方法实际上就是 then 方法传递的第二个函数 reject(err) // 将容器的 Pending 状态改为 Rejected &#125; else &#123; // 这里调用 resolve 方法实际上就是 then 方法传递的第一个函数 resolve(data) // 将容器的 Pending 状态改为 Resolved &#125; &#125;)&#125;)el.then(function (data) &#123; // 指当 promise 实例成功了，然后触发 console.log(data)&#125;,function (err) &#123; console.log('读取文件失败'，err)&#125;) 解决 回调地狱问题1234567891011121314151617181920212223242526272829303132333435363738394041424344var el_1 = new Promise(function (resolve,reject) &#123; fs.readFile('./data/a.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)var el_2 = new Promise(function (resolve,reject) &#123; fs.readFile('./data/b.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)var el_3 = new Promise(function (resolve,reject) &#123; fs.readFile('./data/c.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)el_1 // 异步编程 链式调用 .then(function (data) &#123; console.log(data) return el_2 // return 的 promise 对象可在后面的 then 中接收到 &#125;,function (err) &#123; console.log('读取文件失败'，err) &#125;) .then(function (data) &#123; console.log(data) return el_3 &#125;) .then(function (data) &#123; console.log(data) &#125;) 封装 Promise API封装 readFile1234567891011121314151617181920212223242526var fs = require('fs')function pReadFile(filePath) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(filePath,'utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;pReadFile('./data/a.txt') .then(function (data) &#123; console.log(data) return pReadFile('./data/b.txt') &#125;) .then(function (data) &#123; console.log(data) return pReadFile('./data/c.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) jQ已封装支持1234567891011var data = &#123;&#125;$.get('http://a/s/d/1') .then(function (userData) &#123; data.user = user return $.get('http://a/s/d/2') &#125;) .then(function (jobsData) &#123; data.jobs = jobs var htmlStr = template('tpl',data) document.querySelector('#user_form').innerHTML = htmlStr &#125;) jQ中Ajax使用Promise1234567891011121314$(function () &#123; $('#btn').on('click',function()&#123; $.ajax(&#123; url: './data.json', type: 'get', dataType: 'json', /*success: function (data) &#123; console.log(data) &#125;*/ &#125;).then(function(data) &#123; console.log(data) &#125;) &#125;)&#125;) 自己封装jQ1234567891011121314function get(url) &#123; return new Promise(function (resolve,reject) &#123; var oReq = new XMLHttpRequest() // 当请求加载成功后调用指定函数 oReq.onload = function () &#123; resolve(oReq.responseText) &#125; oReq.onerror = function (err) &#123; reject(err) &#125; oReq.open("get",url,true) oReq.send() &#125;)&#125; 使用场景（分类信息展示）[废弃]12345678910111213141516&lt;form action="js中的一等公民"&gt; &lt;div&gt; &lt;label for=""&gt;职业&lt;/label&gt; &lt;select name="" id=""&gt; &lt;option value=""&gt;学生&lt;/option&gt; &lt;option value=""&gt;老师&lt;/option&gt; &lt;option value=""&gt;码农&lt;/option&gt; &lt;option value=""&gt;老板&lt;/option&gt; &lt;option value=""&gt;演员&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt;//用户表 获取用户信息//职业信息表 获取所有的职业信息&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940&#123; "users":[ &#123; "id":1, "username":"admin", "age":18, "job":2 &#125;, &#123; "id":2, "username":"root", "age":18, "job":1 &#125;, &#123; "id":3, "username":"admin", "age":18, "job":3 &#125; ], "jobs":[ &#123; "id":1, "name":"学生" &#125;, &#123; "id":2, "name":"老师" &#125;, &#123; "id":3, "name":"码农" &#125;, &#123; "id":4, "name":"老板" &#125; ]&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>后端技术</category>
        <category>Node.js</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>node.js 技术栈</tag>
        <tag>后端技术</tag>
        <tag>Express 框架</tag>
        <tag>mongoDB 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6——Readme]]></title>
    <url>%2F2019%2F03%2F27%2FES6%2F</url>
    <content type="text"><![CDATA[简介：ES6 在这里就不给详细科普了 ES6 全称ECMAScript 6.0 ,是JavaScript的新的一个版本标准，说是为了： 适应更复杂的应用； 实现代码库之间的共享； 不断迭代维护新版本； 兼容性，各大浏览器基本上都支持 ES6 的新特性。（时代在进步，这里对于这个必然趋也不进行过多叙述了） Chrome Firefox 兼容的最好 IE 7~11基本不支持（万恶的兼容之源） 本文是在老的基础上对比新的来学习，毕竟在项目里并不都是ES6。顺便温故而知新。 新的声明方式：old: ver 不支持封闭作用域，会声明到全局作用域 12345for (var i = 0;i&lt;3;i++)&#123; console.log(i); // 0 1 2&#125;console.log(i); //结果是 3 3 3//意思是在for循环里声明的变量，在全局也可以拿到 old 解决方法，把它放到一个匿名函数里去 (function(){ for (var i = 0;i&lt;3;i++){ console.log(i) } })(); console.log(i);// 0 1 2 以及定时器问题 for(var i = 0;i&lt;3;i++){ setTimeout(function(){ console.log(i); },1000); } //for循环是同步代码，setTimeout()是异步代码。根据事件环，同步代码执行完毕之后，才执行异步代码，此时变量i已经是全局的变量i且为3，因此结果为3 3 3 3 3 ... //by the way : 在项目开发中要记得清理定时器: var flag = setTimeout(fn,1000); clearInterval(flag); //后面准备专门写一篇关于内存泄露的，这里打个标记 (#^.^#) old 解决方法： for(var i = 0;i&lt;3;i++){ (function(i){ setTimeout(function(){ console.log(i); },1000); })(i); } // 结果 ：0 1 2 new: let let 和 {} 配合可以产生一个作用域 let 支持块级作用域，声明的变量只会声明在当前作用域内 for(let i = 0;i&lt;3;i++){ setTimeout(function(){ console.log(i); },1000); // 结果 ：0 1 2 } console.log(i); // undefined let 可以解决作用域污染问题和局部作用域问题 new 不可以在同一作用域下多次声明 let a = 3 //不同作用域，因此可以 function fn(){ let a = 1; let a = 2; // 报错 } old 可以 var a = 3 function fn(){ var a = 1; var a = 2; //不会报错 } 域解释问题 ——变量提升 new 没有变量提升，以及要避免暂存死区（避免） console.log(b) let b = 1; // undefined let a = 1; { console.log(a); // undefined let a = 2; } old 变量提升只提升变量名，并不赋值 console.log(a); //undefined var a = 1; console.log(a); // 1 new : const const 与 let 基本一致 const声明的变量不能被修改，指的是不能被修改引用空间 const a = 1; a = 2; //报错，不能给常量赋值 const a = {name:’xyz’} a.age = 9; console.log(a); //没有修改引用空间，因此可以。 解构赋值 解构赋值 声明和赋值都放到了一起 解构 表示等号左边和右边解构类似 数组的位置必须相同 1let [,age] = ['十八'，18] 对象解构时的名字必须相同 12let &#123; length &#125; = ['十八'，18];console.log(length); // 2 如果有关键字可以采用 : 的形式进行更改名字 12let &#123;name,age,default:d&#125; = &#123;name:'十八'，age:18,default:'灰喵'&#125;console.log(d); // 灰喵 多层取数/取默认值 如果想设置某个属性的默认值 必须采用 = 号的形式 12345let [, &#123;address: [,a]&#125;,hobby='挠人'] = [ &#123; name:'十八' &#125;, &#123; age: 15,address:[1,2,3] &#125;,]console.log(hobby); // 挠人 解构的应用 12345678910111213function ajax(&#123;url=new Error('url without'),type="get",data=xxx&#125;) &#123; console.log(url,type,data);&#125;ajax(&#123; url:'/test', type:'get', data:&#123;&#125;&#125;)function test() &#123; return [1,2,3];&#125;let [a,b,c] = test(); 模板字符串模本字符串 取代了 原有的字符串拼接 1234let name = '十八';let age = 15;let str = `hello~'$&#123;name&#125;'今年$&#123;age&#125;岁了`console.log(str); // hello~'十八'今年15岁了 支持换行 和 取值 ${} 1234let str = `&lt;ul&gt; &lt;li&gt;$&#123;name&#125;&lt;/li&gt; &lt;li&gt;$&#123;age&#125;&lt;/li&gt;&lt;/ul&gt;` 如何实现 一个类模板字符串的功能 12345str = str.replace(/\$\&#123;([^]*)&#125;\)/g,function () &#123; console.log(arguments) return eval(arguments[1]); //with&#125;);console.log(str); 带标签的模板字符串 自定义模板字符串的实现 1234567891011121314function meStr()&#123; console.log(arguments) // &#123;'0':['hello~','今年','岁了'],'1':'十八','2':15&#125; let strings = arguments[0]; // Array.prototype.slice.call() let values = [].slice.call(arguments,1) // 将后两项转为数组 ['十八'，15] let str = '' for(let i = 0;i&lt;values.length;i++)&#123; str += `$&#123;strings[i]&#125;*$&#123;values[i]&#125;*` &#125; str += strings[strings.length-1]; return str&#125;let str = meStr`hello~'$&#123;name&#125;'今年$&#123;age&#125;岁了`;console.log(str); 补充：常用字符串方法 123456789101112131415161718let url = 'http://F-lancer.io/node.html'// includes 是否包含console.log(url.includes('lancer'))// startsWith 以xxx开头console.log(url.startsWith('http://'))// endsWith 以xxx结尾console.log(url.endsWith('.html'))// 进制转换 padStart padEnd 补全setInterval(function () &#123; let date = new Date(); let hour = date.getHours(); let minutes = date.getMinutes(); let seconds = date.getSeconds(); let str = `$&#123;hour.toString().padStart(2,0)&#125;:`; // 不满两位 补 0 str += `$&#123;minutes.toString().padStart(2,0)&#125;:`; str += `$&#123;seconds.toString().padStart(2,0)&#125;`; console.log(str)&#125;,1000) 箭头函数优点 ：箭头函数写起来简单，解决了 this 的问题。 与高阶函数的对比： 箭头函数没有 function 的关键字 小括号和大括号之间有个箭头 123456function fn(a) &#123; return a;&#125;let fn = (a) =&gt; &#123; return a&#125; 如果参数是一个，可以省略小括号 123let fn = a =&gt; &#123; return a&#125; 如果没有 return 可以不写大括号 1let fn = a =&gt; a; 例： 12345678910111213141516function a(c) &#123; return function (d) &#123; return c+d; &#125;&#125;// 等价于let a = c =&gt; d =&gt; c+d;console.log(a(1)(2));// 注意 返回一个对象时 加个括号（）function a(c) &#123; return function (d) &#123; return &#123;sum:c+d&#125;; &#125;&#125;let a = c =&gt; d =&gt; (&#123;sum:c+d&#125;); 解决 this 问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// old way // (1) 谁调用指向谁let obj = &#123; b:1, a:function()&#123; console.log(this) &#125;&#125;console.log(obj.a()); // this为,&#123; b:1, a:[Function:a] &#125; ,第二个 console为 undefine// (2) window 调用 指向windowlet fn = obj.a;fn(); // (3) 同理 定时器 也指向 windowlet obj=&#123; b:1, a:function () &#123; setTimeout(function()&#123; console.log(this); &#125;,1000) &#125;&#125;obj.a(); // 指向window// (3.1) 想要使其指向 obj (old way) var that = this;let obj = &#123; b:1, a:function () &#123; let that = this; setTimeout(function()&#123; console.log(that); &#125;,1000) &#125;&#125;obj.a(); // 指向 obj// (3.2) 使用 bind() 方法 改变指向 或 call() apply() (备选);let obj = &#123; b:1, a:function () &#123; setTimeout(function()&#123; console.log(this); &#125;.bind(this),1000) &#125;&#125;obj.a(); // 指向 obj 箭头函数没有 this 指向，因此会向上找 this，就解决了 this指向被改变的问题 12345678910111213141516171819let obj=&#123; b:1, a:function () &#123; setTimeout(()=&gt;&#123; console.log(this); &#125;,1000); &#125;&#125;obj.a() // &#123;b:1,a:f&#125;let obj=&#123; b: 1, a: () =&gt; &#123; setTimeout(()=&gt;&#123; console.log(this); &#125;,1000); &#125;&#125;obj.a() // window 例： 1234567891011121314151617let a = 1;let obj = &#123; a:2, b:()=&gt;&#123; console.log(a); &#125;&#125;obj.b(); // a = 1; 对象不是作用域，所以会找到外面let a = 1;let obj = &#123; a:2, b:()=&gt;&#123; console.log(this); &#125;&#125;obj.b(); // this = window;this.a = undefined 对象不是作用域，所以会找到外面,let不会声明到全局 箭头函数中 没有 arguments 可以使用 剩余运算符 ... 只能放到最后一个（剩余全部） 1234567891011let fn = (x,...args) =&gt; &#123; console.log(args)&#125;fn('x',1,2,3,4) // [1,2,3,4]//等同于let fn = (...arguments) =&gt; &#123; let arg = arguments.slice(1); console.log(args);&#125;fn('x',1,2,3,4) 可以设置默认值 1234let fn = (x=1,y=2) =&gt; &#123; console.log(x+y);&#125;fn() 展开运算符例 1： 123456789// apply 可以把参数用数组的方式传，即可以一个个传function spread(x,...args)&#123; // sum.apply(null,agrs); 等价于 sum(...args); // 展开预算符&#125;function sum(a,b,c,d)&#123; console.log(a,b,c,d);&#125; spread('x',1,2,3,4) 例 2： 123// concat 拼接转换let arr = [1,2,3].concat([4,5,6]); // 等价于let arr = [...[1,2,3],...[4,5,6]]; // 展开两个数组拼接到一起 例 3： 12// 展开求最小值Math.min(...[1,2,3,4]) 例 4： 1234// 展开对象let name = &#123;name:'十八'&#125;;let age = &#123;age:'15'&#125;;let cat = &#123;...name,...age&#125;; 例 5：深浅拷贝 123456789101112131415161718192021// 利用 slice 拷贝 为浅拷贝 一维数组就是深拷贝let b = [1,2,3];let a = [b];let c = a.slice(0);console.log(c); // [[1,2,3]]b[0] = 100;conosle.log(c); // [[100,2,3]] 随之改变为浅拷贝// ...运算符也是浅拷贝 一维数组就是深拷贝let name = &#123; name: &#123;name:'十八'&#125;&#125;;let age = &#123; age: 9 &#125;;let cat = &#123; ...name, ...age &#125;;name.name.name = '喵喵';console.log(cat); // &#123; name: &#123; name: '喵喵' &#125;, age: 9 &#125;// 深拷贝的实现 // 补充：JSON.Stringify() 用于将 对象/值 转为JSON格式 // JSON.parse() 解析JSON字符串// 以下不支持 函数 ，且都会强制性都变为对象，无法继承let obj = &#123;a:1,fn:function(params) &#123;&#125;,t:/a/,d:new Date,b:null&#125;;console.log(JSON.parse(JSON.stringify(obj))); 实现深拷贝（保留继承关系，实现各种类型的拷贝）123456789101112131415function deepClone(obj) &#123; if(typeof obj !== 'object') return obj; if(obj == null) return null; if(obj instanceof Date) return new Date(obj); if(obj instanceof RegExp) return new RegExp(obj); Object.prototype.toString.call(obj) === '[object Array]' let o = new obj.constructor(); // 保留类的继承关系 for(let key in obj)&#123; //是对象就递归 o[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key] &#125; return o;&#125;let o = &#123; a: &#123; a: 1 &#125; &#125;;let newObj = deepClone(o);console.log(newObj); 数组新增及常用方法map() some() every() filter() forEach() es5 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1) forEachArray.prototype.forEach = function (fn) &#123; for(let i = 0;i&lt;this.length;i++) &#123; fn(this.[i],i); &#125;&#125;;[1,2,3].forEach((item,index)=&gt;&#123; console.log(item,index);&#125;)// 2) map返回值 返回值是一个新数组Array.prototype.map = function (fn) &#123; let arr = []; for (let i=0; i &lt; this.length; i++) &#123; arr.push(fn(this[i],i)); &#125; return arr;&#125;let arr = [1,2,3].map(item =&gt; &#123; return item*2;&#125;);console.log(arr);// 3) filter 过滤 如果返回true表示留下 返回false表示删除let arr = [1,2,3];let filterArr = arr.filter(item=&gt;&#123; return item&gt;2;&#125;);console.log(filterArr);// 4) find 查找 返回查找的那一项，找到后就不会继续找了，没有返回 undefinedlet f = [1,2,3].find(item=&gt;&#123; return item === 2;&#125;);console.log(f);// 5) some 找到后返回true，找到false可以用every （找到第一个不为条件的截止）let r = [2,1,3].some(item =&gt; &#123; console.log(item); return item === 1;&#125;);console.log(r);// 6) includes 是否包含console.log([1,2,3].includes(3)); find() findIndex() es6 reduce() 收敛 叠加 123456789101112131415161718192021222324252627282930313233343536373839// 1) reduce 返回的结果是叠加后的结果 迭代根据设置叠加// prev 第一项 next第二项 currIndex循环次数 ary传入的数组[1,2,3,4].reduce((prev, next, currIndex, ary) =&gt; &#123; return prev+next; // 返回的结果会给予下一次迭代的 prev&#125;,0) // 加 0 多循环一次// 2) 求平均数[1,2,4,3].reduce((prev,next,currIndex,ary) =&gt;&#123; if (ary.length-1 === currIndex)&#123; return (prev+next)/ary.length &#125; return prev+next;&#125;);// 3) 对象[&#123;price:10&#125;,&#123;price:20&#125;,&#123;price:30&#125;].reduce((prev,next,currIndex,arr) =&gt; &#123; return prev +next.price // 若为 prev.prive + next.price 结果为 NaN&#125;,0) // 0 设置初始值，使得第一次遍历为 0+10,不设置就从第一项开始// 4) 原理Array.prototype.myReduce = function (fn,prev) &#123; for (let i = 0;i&lt;this.length;i++)&#123; if(typeof prev === 'undefined')&#123; prev = fn(this[i],this[i + 1],i + 1,this); i++; // 保证不错乱 &#125;else&#123; prev = fn(prev,this[i],i,this); &#125; &#125; return prev;&#125;[1,2,3].myReduce((prev,next,currIndex,ary) =&gt; &#123; return prev + next&#125;)// 5) 利用 reduce 展平二维数组let flat = [[1,2,3],[4,5,6]].reduce((prev,next,index,ary)=&gt;&#123; return [...prev,...next];&#125;) for of() Array.form () 1234567// 将类数组转化为数组function a()&#123; //此处不能传参，传残就表示只能一个或指定个数 console.log(eval(Array.from(arguments).join('+')))&#125;a(1,2,3);// 常见的类数组有 htmlCollection（html的元素集合）、arguments、&#123;0:1,1:2,2:3,length:3&#125; of() 12345let ary = new Array(3);console.log(ary); // 声明的数组为三个空项 [ empty , empty , empty ]let ary = Array.of(3);console.log(ary); // 声明的数组为 [3] 对象Object.assign() 1234let name = &#123;name:'十八'&#125;;let age = &#123;age:9&#125;;let obj = Object.assign(name,age); // 浅拷贝console.log(obj); // 等同于 console.log(&#123;...name,...age&#125;) ; __proto__ 链 Object.setPrototypeOf() 可以在对象内直接操作 __proto__ 123456789101112131415161718192021let obj1 = &#123; name: "十八" &#125;;let obj2 = &#123; age: 9 &#125;;obj1.__proto__ = obj2;console.log(obj1.age);// 等价于Object.setPrototypeOf(obj1,obj2);console.log(Object.getPrototypeOf(obj1));// 子中获取父的名字let obj = &#123; age: 9, name: '十八'&#125;;let obj = &#123; name:'喵喵', getPName () &#123; // 可以通过 super 关键字获取父属性 return super.name &#125;, __proto__:obj2&#125;console.log(obj.name) // 喵喵console.log(obj.getPName()) // 十八 类 class在 es5 中没有类的概念，通过 构造函数 模拟类 类的继承三种属性: 公有属性（__proto__）、私有属性、静态方法（静态属性） 如何实现一个类：(es5) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Parent () &#123; // 构造函数中的 this 通过 new 调用，那么 this 指代的是实例 this.name = 'parent'; //私有属性&#125;Parent.prototype.eat = function()&#123; console.log('eat'); // 公有属性 // 这里有个 constructor 属性指向 Parent&#125;let parent = new Parent(); // 实例上有 __proto__ 指向 Parentconsole.log(Parent.prototype.constructor === Parent); // trueparent.__proto__.eat(); // eat 会先去私有属性中找，找不到去公有属性里找function Child () &#123; this.age = 9; // 构造函数中的 this 通过 new 调用，那么 this 指代的是实例 Parent.call(this); // 等价于 this.name = 'parent' 实现继承私有属性&#125;Child.prototype.smoking = function()&#123; console.log('smoking')&#125;let child = new Child();console.log(Child.age) // undefined// 继承私有属性 Parent.call(this);console.log(child.name)// 继承公有属性// 使用 Child.prototype = Parent.prototype; 使其互相影响变成兄弟关系，非继承关系Child.prototyoe.__proto__ = Parent.prototype; // es5中的方法Object.setPrototypeOf(Child.prototype,Parent.prototype); // es6Child.prototype = Object.create(Parent.prototype) // 可以实现只继承公有属性// 原理：function create(parentPrototype,props)&#123; function Fn()&#123;&#125; Fn.prototype = parentPrototype; let fn = new Fn(); for(let key in props)&#123; Object.defineProperty(fn,key,&#123; ...props[key], enumerable:true &#125;); &#125; return fn;&#125;Child.prototype = Object.create(Parent.prototype,&#123;constructor:&#123;value:Child&#125;&#125;);let child = new Child();console.log(child.constructor) // 会指向 parent 的 Constructorlet a = &#123;&#125;;a.name = 1;// 等价于Object.defineProperty(a,'name',&#123; enumerable:true, // 使其可枚举 configurable:true, // 可删除 writable:true, // 可编辑 get()&#123;&#125;, // 这两个就不能写 write 和 value set()&#123;&#125;, value:1 // 只定义这个是看不到的，及不可枚举型&#125;); class（类）12345678910111213141516171819202122232425262728293031// 类 可以继承 公有 私有 和 静态方法class Parent&#123; constructor()&#123; this.name = 'parent'; return &#123;&#125;; // 如果在父类返回一个引用空间，则子类中的 this 指向了这里 &#125; static b()&#123; return 2; &#125; eat()&#123; console.log('eat'); &#125;&#125;class Child extends Parent&#123; // 要求继承父亲的私有和公有 constructor()&#123; super(); // Parent.call(this); this.age = 9; // 私有属性 &#125; static a()&#123; // 静态方法 return 1; &#125; smoking()&#123; // 原型上的方法 console.log('smoking') &#125;&#125;let child = new Child();console.log(child.b())// 总结：1.类只能 new// 2.类可以继承公有私有和静态方法// 3.父类的构造函数中返回了一个引用类型，会作为子类的this。及可以指定继承对象 原理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 类的调用检测function _classCallCheck (instance,constructor) &#123; if (!(instance instanceof constructor))&#123; throw new Error('抛出错误，未用你 new 调用') &#125;&#125;// 创建类function definePropertys(target,arr) &#123; for(let i = 0;i&lt;arr.length;i++)&#123; Object.defineProperty(target,arr[i].key,&#123; ...arr[i], configurable:true, enumerable:true, writeable:true &#125;) &#125;&#125;/* construtor 构造函数 protoPropertys 原型方法描述 staticPropertys 静态方法的描述*/function _createClass(constructor,protoPropertys,staticPropertys) &#123; if (protoPropertys.length&gt;0)&#123; definePropertys(constructor.prototype,protoPropertys) &#125; if (staticPropertys.length&gt;0)&#123; definePropertys(constructor,staticPropertys) &#125;&#125;let Parent = function () &#123; // 写逻辑 function P() &#123; _classCallCheck(this,P); //类的调用检测 如果this是P的实例，则是 new 出来的 this.name = 'parent'; return &#123;&#125;; &#125; _createClass(P, // 属性描述器 [ &#123; key: 'eat', value: function()&#123; console.log('吃') &#125; &#125; ],[ &#123; key: 'b', value: function()&#123; return 2; &#125; &#125; ]); // 创建类 return P;&#125;();let p = new Parent();p.eat(); 继承： 12345678910111213141516171819202122232425// 子类继承父类function _inherits(subClass,superClass) &#123; // 继承公有属性 subClass.prototype = Object.create(superClass.prototype,&#123;constructor:&#123; value:subClass&#125;&#125;); // 继承静态方法 Object.setPrototypeOf(subClass,superClass);&#125;let Child = (function(Parent)&#123; // 先实现继承父类的公有属性和静态方法 _inherits(C,Parent); function C()&#123; _classCallCheck(this.C); let obj = Parent.call(this); let that = this; if(typeof obj === 'object')&#123; that = obj; &#125; that.age = 9; // 解决了父类返回一个引用类型的问题 return that; &#125; return C;&#125;)(Parent)let child = new Child();console.log(Child.b()); Promise基本语法在 es6 中新出现的。generator async await 都是基于 promise 的。 比如：kao axios redux-saga fetch …。 promise 是一种异步流程的控制手段 promise 链式调用解决回调地狱。 promise 可以支持多个并发的请求，获取并发请求中的数据。避免返回快慢错乱问题。 promise 可以解决异步问题，但本身并不能称为 异步。 promise 可以实现不再传递回调函数了。 promise 函数new一个实例可以then多次，及调用多次。 promise （承诺）的关键字 及 三个状态一个执行器 resolve 成功 reject 失败 pending 等待 （只有它可以转为其它状态） excutor 执行器（隐） then 然后 （带两个参数，成功和失败两个函数） throw new Error() （promise 中发生错误 就会执行失败态） 123456789101112131415let p = new Promise((resolve,reject)=&gt;&#123; // 默认 promise 中的 excutor 执行器是同步执行的 console.log(1); throw new Error(); // 如果代码报错，走失败 setTimeout(() =&gt; &#123; // 原来实现这一点需用回调函数 resolve('买'); &#125;,1000);&#125;);console.log(2); // 1,2// then方法是异步调用的，事件环p.then((value)=&gt;&#123; // value成功的原因 console.log('value',value)&#125;,(err)=&gt;&#123; // err 失败的原因 console.log('err',err)&#125;) 回调地狱（参考 node.js 回调地狱篇） 现象：12345678let fs = require('fs'); // 导入文件模块fs.readFile('1.txt','utf8',function(err,data)&#123; if (err) return console.log(err); fs.readFile(data,'utf8',function(err,data)&#123; if (err) return console.log(err); console.log(data); &#125;)&#125;) 改进：12345678910111213141516171819202122232425262728293031// 链式调用let fs = require('fs');function read(url) &#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(url,'utf8',function (err,data) &#123; if (err) reject (err); resolve(data); &#125;) &#125;)&#125;// 如果返回的是一个 promise 的结果，会将结果作为下一个 then 的参数传入read('cat.txt').then((data)=&gt;&#123; return read(data); //如果成功，传给下一个 then 的 data&#125;).then(data=&gt;&#123; console.log('data');&#125;,err=&gt;&#123; console.log('err');//如果不出存在或失败走到这里&#125;); // promise 实现链式调用返回的并不是this,而是一个新的promise,及失败了可以继续向下运行read('1.txt').then(data=&gt;&#123; return 100;&#125;).then(data=&gt;&#123; throw new Error(); // 标明执行错误，下一步走错误逻辑&#125;).then(data=&gt;&#123; console.log(data);&#125;,(err)=&gt;&#123; console.log(err); // error&#125;).then(data=&gt;&#123; console.log(data,'1213') // undefined '1213' &#125;) 捕获异常：（.catch）12345678910// catch 如果有任何一个出错，会走到 catch 里去read('1.txt').then(data=&gt;&#123; &#125;).then(data=&gt;&#123; throw new Error();&#125;).catch(err=&gt;&#123; console.log(err); // 获取失败，走到下一个成功里去&#125;).then(data=&gt;&#123; console.log('catch');&#125;) 多次调用：12345678910111213let p = new Promise((resolve,reject)=&gt;&#123; resolve('成功');&#125;);// 一个promise的实例可以then多次p.then(data=&gt;&#123; console.log(data); // 成功 &#125;);p.then(data=&gt;&#123; console.log(data); // 成功 &#125;);p.then(data=&gt;&#123; console.log(data); // 成功 &#125;) 并发请求：（.all）12345678910111213141516let fs = require('fs'); function read(url) &#123; return new Promise((resolve,reject) =&gt; &#123; fs.readFile(url,'utf8',function(err,data)&#123; if (err) reject(err); resolve(data); &#125;) &#125;)&#125;// promise.all方法调用后会返回一个新的promise// 并发请求Promise.all([read('1.txt'),read('2.txt')]).then(([r1,r2])=&gt;&#123; console.log(r1,r2);&#125;,err=&gt;&#123; console.log(err); // 有一个失败结果就为失败 &#125;); 赛跑：（.race）123456// 处理多请求，只取最快的Promise.race([read('1.txt'),read('2.txt')].then((data)=&gt;&#123; console.log(data); // 取1或2&#125;,err=&gt;&#123; conosle.log(err);&#125;)); 其他：(.resolve，.reject)12345678// 返回一个成功的promisePromise.resolve('123').then(data=&gt;&#123; console.log(data);&#125;)// 返回一个失败的promisePromise.reject('123').then(null,data=&gt;&#123; console.log(data);&#125;) 源码实现：123456789101112131415161718192021222324252627282930313233class Promise&#123; constructor(executor)&#123; this.status = 'padding'; this.value = undefined; this.value = undefined; let resolve = value =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; this.value = value; &#125; &#125;; let reject = reason =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'rejected'; this.reason = reason; &#125; &#125;; try&#123; executor(resolve,reject); &#125;catch(e)&#123; reject(e); &#125; &#125; then(onFuFilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFuFilled(this.value); &#125; if(this.status === 'rejected')&#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise; 解决异步的方案 高阶函数 函数是一等公民，函数可以当作参数，函数可以当作函数，函数可以返回函数（偏函数，函数柯里化）callback Promise generator + co库 async + await 高阶函数 函数返回函数 123456// 类型判断function isType (type,content) &#123; let t = Object.prototype.toString.call(content).replace(/\[object]\s|]/g,''); return t === type;&#125;console.log(isType('String','adc')); 123456789// 需要批量生产的一些方法 isString('abc') isNumber(123);function isType (type) &#123; // 闭包 不会释放 的变量 return function (content) &#123; // 用完后即清除的变量 let t = Object.prototype.toString.call(content).replace(/\[object]\s|]/g,''); return t === type; &#125;&#125;let isString = isType('String');isString('abc'); 12345678910111213// 扩展function isType (type) &#123; return function (content) &#123; let t = Object.prototype.toString.call(content).replace(/\[object]\s|]/g,''); return t === type; &#125;&#125;let arr = ['String','Number','Array','Object','null'];let util = &#123;&#125;; // 对象，一般有这个工具类arr.forEach(item =&gt; &#123; util['is' + item] = isType(item)&#125;);console.log(util.isString('123')); 高阶函数 函数当作参数传递 典型的 callback。例如： loadash after 1234567891011121314// 当达到某个条件的时候，执行 callbackfunction after (times,callback) &#123; return function () &#123; if (--times === 0) &#123; callback(); &#125; &#125;&#125;let eat = after(3,function()&#123; console.log('吃完了');&#125;);eat();eat();eat(); // 到第三次才执行 应用 12345678910111213141516171819let fs = require('fs');function after (times,callback) &#123; let arr = []; return function (d) &#123; arr.push(d); if(arr.length === times) callback(arr); &#125;&#125;;let out = after(2,function(data)&#123; console.log(data);&#125;);fs.readFile('./2.promise.js/a.txt','utf8',function (err,data) &#123; console.log(data); out(data);&#125;);fs.readFile('./2.promise.js/b.txt','utf8',function (err,data) &#123; console.log(data); out(data);&#125;);]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>ES6</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>前端端技术</tag>
        <tag>ES6.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[optimization]]></title>
    <url>%2F2019%2F03%2F27%2Foptimization%2F</url>
    <content type="text"><![CDATA[简介：性能优化…… Hexo之性能优化hexo是本博的框架，起初是建立在 github 上的静态页面。但是仅仅只是根据 hexo 建立好博客是远远不够的。因为在一般网络环境下加载速度会很慢，如果自己的知识积累还不如百度来的快，那建立博客的初衷就会大大减少。加载速度慢有很多原因，比如，框架本身的源码中有许多空格，github是外网，图片加载尤其缓慢，字体采用的是 google 字体等等。从这几个方面入手，解决性能优化问题，是本页的初衷。 DNS域名解析DNS域名解析是本博最基础且是最致命的问题。国内访问 本博 so fast 。木钱买域名，凄惨。 移动端删除 live2d-widget在 _config.yml 文件夹下将 live2d 中的 mobile 置为 false。 修改 hexo 样式在该 F:\blog\themes\next\source\css\_custom\custom.styl 文件下修改即可覆盖原本样式。想要复原时，删除该文件内容即可。 注意：修改 header（头部导航栏）的透明度会引发 search 选项调出的弹框被遮挡层遮挡，建议修改 header 内部标签属性实现，可 F12 参考本博。]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>hexo</category>
        <category>性能优化</category>
        <category>DNS 解析案例</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学进站]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%A7%91%E5%AD%A6%E8%BF%9B%E7%AB%99%2F</url>
    <content type="text"><![CDATA[嘻嘻，这里是一些进站指南，毕竟花里胡哨得人写地花里胡哨的页面： （1）由于背景是随机图片，所以如果看不清，请点击右上角刷新按钮,更换背景图片。 （2）由于左下角是我的“女儿”，所以我是不会为了移动端客户而抛弃我的女儿的，当然可爱的女儿也挡住了我的“压岁钱”的二维码入口，o(╥﹏╥)o。 （3）有什么意见右下角可以联系我呀~，期待 (#^.^#) （4）页首 Links 项里有许多技术、工具、资源、题库站点 （5）暂时就先这样了，后面有什么隐蔽福利更新再更ヾ(◍°∇°◍)ﾉﾞ &amp; 提示：电脑端右下角,里面有个界面超好看的电影推荐链接，推荐！！！后面会增加更多的资源以及技术博文欢迎PC端订阅呀！（为了女儿，抛弃移动端[○･｀Д´･ ○]）]]></content>
      <categories>
        <category>进站指南 </category>
      </categories>
      <tags>
        <tag>指南 </tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog 论坛]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%96%B0%E5%BB%BAbolg%E8%AE%BA%E5%9D%9B%2F</url>
    <content type="text"><![CDATA[简介该blog论坛基于 node.js Express 框架，mongoDB数据库，mongoose数据库框架，jQuery库等。可以进行一些简单的注册，登陆，评论，发表等功能。 结构：1234567891011121314151617181920212223242526272829303132333435blog |-- public // 公共的静态资源 |-- img |-- JS |-- CSS |-- HTML |-- views // 存储视图目录 |-- _layouts |-- home.html |-- _partials |-- footer.html |-- header.html |-- settings-nav.html |-- settings |-- admin.html |-- profile.html |-- topic |-- profile.html |-- index.html |-- login.html |-- register.html |-- controllers |-- models // 数据库数据模型 |-- comment.js |-- topic.js |-- user.js |-- routes // 路由配置 |-- session.js |-- topic.js |-- app.js // 启动入口文件 |-- README.md // 项目说明文档 |-- .gitignore git // 忽略配置项文件，忽略一些不必要的配置文件 |-- package.json // 包描述文件 |-- package-lock.json // 第三方包版本锁定文件 |-- node_modules // 第三方包 构建：12345678910npm init -y ## 初始化 package.jsongit init ## 初始化发布到 git 的必要文件npm i express mongoose ## 配置核心文件npm i art-template express-art-template ## 配置模板引擎npm install --global nodemon ## 配置第三方命令行工具npm i bootstrapnpm i jquerynpm install --save body-parser ## 配置三方包 获取表单信息npm install blueimp-md5 ## 配置密码加密三方包npm install express-session ## 配置使用 cookie session 三方包 细节：path模块123456path.basename('') // 获取一个路径的文件名（默认包含扩展名）path.dirname('') // 获取一个路径的目录部分path.extname('') // 获取一个路径的扩展名部分path.isAbsolute('') // 判断一个路径是否是绝对路径path.parse('path') // 返回一个路径对象&#123;root dir base ext name&#125;path.join('','') // 当进行路径拼接的时候，推荐使用它，会格式化避免出错 参考文档：http://nodejs.org/dist/latest-v9.x/docs/api/path.html Node 中的其他成员在每个模块中，除了require，exports等模块相关的 API 之外，还有两个特殊成员： __dirname ：可以用来动态获取当前文件模块所属目录的绝对路径。 __filename ：可以用来动态获取当前文件的绝对路径。 path.join(&#39;&#39;,&#39;&#39;) ：当进行路径拼接的时候，推荐使用它，会格式化避免出错 相对路径问题1234567var fs = require('fs')fs.readFile('./a.txt','utf8',function (err,data) &#123; if (err) &#123; throw err &#125; console.log(data)&#125;) 一般情况下：./a.txt 是相对于当前文件路径。 在 node 中是相对于执行 node 命令所处的终端路径。 因此，在文件操作中使用相对路径是不可靠的，相对路径的设计的应该是相对于执行 node 命令所处的路径。 解决：将其换为绝对路径。缺陷，写死不利于项目迁移。 使用 __dirname 和 __filename path.join(&#39;&#39;,&#39;&#39;) 转换为动态的绝对路径。 123456fs.readFile(path.join(__dirname,'./a.txt'),'utf8',function (err,data) &#123; if (err) &#123; throw err &#125; console.log(data)&#125;) 补充：模块中的相对路径（相对当前文件）不受影响，这里仅指文件操作中的相对路径标识。 art-template子模版header.html / footer.html 1234&lt;!-- header.html --&gt;&lt;header&gt;&lt;/header&gt;&lt;!-- footer.html --&gt;&lt;footer&gt;&lt;footer&gt; layout.html 12345678910&lt;!-- 头部组件 --&gt;&#123;&#123; include './header.html' &#125;&#125;&lt;!-- 内容组件 --&gt;&#123;&#123; block 'content' &#125;&#125; &lt;section&gt;我是默认内容&lt;/section&gt;&#123;&#123; /block &#125;&#125;&lt;!-- 尾部组件 --&gt;&#123;&#123; include './footer.html' &#125;&#125; 模板继承index.html 12345678&lt;!-- 继承自 layout.html --&gt;&#123;&#123; extend './layout.html' &#125;&#125; &#123;&#123; block 'content' &#125;&#125; &lt;section&gt; index页面填充内容&lt;/section&gt;&#123;&#123; /block &#125;&#125; 路由设计 路径 方法 get参数 post参数 是否需要登陆权限 备注 / GET 渲染首页 /register GET 渲染注册页面 /register POST email/nickname/password 处理注册请求 /login GET 渲染登陆页面 /login POST email/password 处理登陆请求 /logout GET 处理退出请求 补充： try ... catch try ... catch ：try中包含了由一个或者多个语句组成的try块，catch子句包含try块中抛出异常时要执行的语句。即，你想让try成功，如果其中有任何异常抛出，会在catch中执行，否则继续忽略catch语句。 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch async async：基于ES6 Promise 的异步请求的方式。大多数异步函数也可以使用Promises编写。但是，在错误处理方面，async函数更容易捕获异常错误。 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 在注册页面表单验证时会用到以上两个语法。 cookie cookie 保存一些不太敏感的数据，且数据量较小。不能用来保存登录状态，比如vip。但是可以保存比如用户名，购物车。 session 你（客户端）、寄存行李处（服务端）、电子票（cookie）、箱子中的内容（敏感信息） 在 Express 中，默认不支持 Session 和 Cookie 但是可以使用第三方中间件：express-session来实现 express-session 的使用 加载：npm install express-session。 配置： 1234567var session = reequire('express-session')app.use(session(&#123; //配置加密字符串，会在原有的加密基础上和这个字符串一起加密 secret: 'itcast', resave: false, saveUninitialized: true // 无论是否使用 session 都会分配钥匙&#125;)) 使用：添加 Session 数据：req.session.foo = &#39;bar&#39;，获取 Session 数据：req.session.foo。 提示：默认 session 数据时内存存储的，服务器一旦存储就会丢失，在生产环境中，会将 session 进行持久化存储。 参考https://www.npmjs.com/package/express-session]]></content>
      <categories>
        <category>node.js 案例</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积小流]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%AD%A6%E4%B9%A0%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[简介不积小流，无以成江海。 javaScriptEvent Loop 参考：http://www.ruanyifeng.com/blog/2014/10/event-loop.html 闭包/引用类型对象 举例： 123456789101112function Foo() &#123; var i = 0; return function() &#123; console.log(i++); &#125;&#125;var f1 = Foo(), f2 = Foo();f1(); // 0f1(); // 1f2(); // 0 涉及知识点： Function 是引用类型，保存在堆中，变量保存在栈中。 闭包：一个函数（产生新的作用域）定义的局部变量、子函数的作用域在函数内部，一旦离开该函数，局部变量就无法访问。通过闭包，即一个函数中定义了一个新的函数，通过此函数使得局部变量得以访问。 过程： （1）执行 Foo() ,返回新的函数 fn，i++ 及先输出 i=0，继而 i+1。 （2）再次执行 f1() 时，i 值已被 i+1 覆盖为 1。即闭包有延续变量的作用。 （3）执行 f2 时，f2 指向堆中新的函数对象，i=0。 深拷贝及浅拷贝概念深拷贝、浅拷贝这个概念讨论是对于 Object 和 Array 复杂类型的。简单来说， 浅拷贝：就是指把一个对象的地址给了另一个对象，他们的指向相同，两个对象之间有共同的属性或者方法。改变其中一个的值，另一个值也会改变。 深拷贝：在另一个对象中开辟相应的空间，一个一个的存储到另一个对象中。 解决方案原生方法浅拷贝：简单的 赋值行为 12345678var obj1=&#123; age:10, sex:"男", car:["浅拷贝","拷贝","地址","属性"]&#125;;var obj2 = obj1;obj1.age = 20;console.log(obj2.age); // 随之改变为 20 深拷贝：jQuery.extend() 函数用于将一个或多个对象的内容合并到目标对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 语法：$.extend( [deep], target, object1 [, objectN ] )。// [deep] 表示是否进行深拷贝jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone,target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === "boolean" ) &#123; deep = target; // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if (deep&amp;&amp;copy&amp;&amp;(jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray( copy ))))&#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 跨域请求 相同的域是指，域名、协议、端口号完全相同。 跨域请求的方法： （1）CORS （2）document.domain （3）图像Ping （4）Jsonp （5）Comet （6）WebSocket call()和apply()的区别 相同点：作用相同，即，在特定的作用域调用函数，等于设置this对象的值，以扩充函数赖以运行的作用域。 1234567891011// 与apply()效果相同，此处仅以 call() 为例window.color = "red";var o=&#123;color:"blue"&#125;;function getColor()&#123; console.log(this.color)&#125;;getColor.call(this); // redgetColor.call(window); // redgetColor.call(o); // blue 不同点： 接收参数的方式不同： （1）call()：第一个参数是运行函数的作用域 ，后面的参数依次传入函数。 （2）apply()：第一个参数是运行函数的作用域 ，另一个参数是参数数组,可以是Array实例或arguments对象。 12345678function add(c, d)&#123;return this.a + this.b + c + d;&#125;var o = &#123;a:1, b:3&#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 阻止默认事件 阻止表单默认行为 1234&lt;form id="add_form"&gt; ... &lt;input type="submit" value="保存"&gt;&lt;/form&gt; 1234567$('#add_form').on('submit',handleAddSubmit)function handleAddSubmit(e)&#123; e.preventDefault() // 阻止表单默认行为 $.post('http://...',$(this).serialize(),function (data) &#123; ... &#125;)&#125; 原因：（1）需要处理逻辑再提交（2）防止跳转链接 ，仅将数据提交给某个url，不需跳转 CSS经典布局双飞翼布局步骤： 两栏和自适应元素都设置统一方向的浮动（如 float: left; )； middle-wrap 元素设置宽度为100%； middle元素设置左右margin值，值为左右两栏的宽度。 左边栏margin-left为负100%； 右边栏margin-left为负自身宽度。 代码： 1234567891011121314151617181920212223.middle-wrap&#123; float: left; width: 100%; overflow: hidden; clear: both;&#125;.middle &#123; height: 200px; background-color:yellowgreen;&#125;.left, .right&#123; float: left; width: 200px; height: 200px;&#125;.left &#123; background-color: #ccc; margin-left:-100%;&#125;.right &#123; background-color: #333; margin-left:-200px;&#125; 12345&lt;div class="middle-wrap"&gt; &lt;div class="middle"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; 理解：（关键点对于margin的理解） margin-left:-100% 是指：子元素（left）的左边框距离父元素（body）右边框的距离。 参考链接：https://segmentfault.com/a/1190000014546205?utm_source=tag-newest border:none; / border:0; 的区别border:none;：表示无边框。 border:0;：表示边框宽度为 0。 性能差异： border:宽度 样式 颜色;顺序不能错，渲染颜色前先获得边框。 border:none;浏览器不进行渲染，不占用内存。 border:0;浏览器对 border-with、border-color进行渲染，占用内存。 浏览器兼容： IE-7不支持border:none; Sprites精灵图优缺点优点： 减少图片字节； 减少http请求； 不同场景下可维护性高（比如只改变图片颜色）； 缺点：（为了性能，繁杂工序的缺点都不构成缺点） 合并麻烦 适应性差 定位繁琐 不同场景下可维护性差，（高边其中图片内容） HTML&lt;a&gt; 标签中的 target 属性 属性值 描述 _blank 在新窗口中打开被连接文档。 _self 默认。在相同的框架中打开被连接文档。 _parent 将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，和_self参数效果一样。 _top 在整个窗口中打开被链接文档。 framename 在指定的框架中打开被链接文档。 _top 和 _partent 不常用，区别为： 比如网A中镶嵌 iframe 了网页B，网页B镶嵌 iframe 了网页C：如果网页C中连接设置target=parent，则将网页B去掉，直接跳入A中嵌入网页C中链接的页面;而如果网页C中target=top ，则直接跳出所有iframe框架，直接转向C中链接页面。 注意：任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将_下划线作为文档中定义的任何框架 name 或 id 的第一个字符。 ES6模块化 export default name 只能导一个，不能写成 export default {name} 的形式 ， 接收时 import name from &#39;./path&#39;，不能写为import {name} from &#39;./path&#39;。 export {name,...} 可以导出多个，但是导出导入都必须加 { }， import {name,...} from &#39;./path&#39;。 安全xssxss攻击，大致原理就是 代码注入，利用漏洞注入代码进行攻击 参考链接：https://tech.meituan.com/2018/09/27/fe-security.html 浏览器渲染机制重绘：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。 回流：当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。 参考：https://blog.fundebug.com/2019/01/03/understand-browser-rendering/ Vue组件封装待更…….]]></content>
      <categories>
        <category>前端积累</category>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>前端积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE之webpack项目搭建（移动端UI）]]></title>
    <url>%2F2019%2F03%2F21%2FUI-%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[简介：手动由 webpack 简单搭建的 Vue 移动端项目，使用到的技术主要有 ：vue2.x、webpack4.0、es6模块化、Mint-ui 及 MUI … 项目结构：UIMint-ui类似于移动端的 element-ui 。 官方文档：http://mint-ui.github.io 可以使用按需导入，来减小项目的体积。 注意：CSS需要手动导入 MUI 官方文档：http://dev.dcloud.net.cn/mui/ui 类似于 BootStrap ，配套的CSS HTML，适用于任何项目。相比之下，Mint-UI是真正的 Vue 的组件库。 需要手动下载安装，从 github 上下载现成的包，解压出来后手动拷贝到项目中 lib 文件夹下，使用。 GITgit init 初始化 git status 显示提交的文件的状态 git add . 将提交的文件放入了 文件暂存区 里 git commit -m &quot;init my project&quot; 提交到了本地 尚与远端未有联系 这里使用的是gitee，创建公钥，已有在C盘用户下找 .ssh 文件夹下，.pub文件即为创建过得公钥 创建远程仓库 git config --global --list 查看git用户配置信息 Git 全局设置： 12git config --global user.name "user.name"git config --global user.email "user.email" 提交代码： 传统方式 git add . git commit -m &quot;提交信息&quot; git push vscode默认集成的 GIT 工具。 + 暂存 输入修改记录 点击√提交本地 点击更多里推送选项 GIT 之 vscode: 绿色表示 添加的代码 蓝色表示修改的 红色表示删除的 补充vscode 快捷方式 ： ctrl + D 点击一次选中下一个相同代码 ctrl + shif + L 选中页面所有相同代码 同时选择上一行 (Ctrl + Alt + Up) 或者下一行 (Ctrl + Alt + Down) 的相同位置 错误汇总：mint-ui懒加载组件lazy load的使用 gitwin10环境，中间有修改过远程仓库网址密码会报错： username or password ( access token )。 解决：参考链接 html豆瓣API访问图片403，对于img标签，可使用referrerpolicy属性 1&lt;img src="https://img3.doubanio.com/view/photo/m_ratio_poster/public/p2503578746.jpg" referrerpolicy ="never"&gt; 兼容性不是很好好像。但是chrom这个跑demo没问题 webpack移除严格模式一些框架使用到 caller、callee、arguments会报错，是 webpack 严格模式打包导致的，禁用webpack用严格模式打包 移除严格模式：https://github.com/genify/babel-plugin-transform-remove-strict-mode babel升级问题babel-loader和babel-core版本不对应会产生问题，babel-loader 8.x对应babel-core 7.xbabel-loader 7.x对应babel-core 6.x 12# 安装babel-core 7.xnpm install -D @babel/core babel-preset-stage-0 貌似已弃用，卸载删除 其它的babel插件改为 @babel/...前缀 并以此前缀安装配置 升级命名1234# 安装npm i -g babel-upgrade# 运行命令npx babel-upgrade --write --install 参考链接 ChromeChrome自己的东西 1234* &#123; /* 解除滑动时的警告 Chrome自己的东西*/ touch-action: pan-y;&#125;]]></content>
      <categories>
        <category>技术 - 前端技术 - VUE-UI</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>VUE-UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记]]></title>
    <url>%2F2019%2F03%2F21%2Fwebpack%2F</url>
    <content type="text"><![CDATA[简介： 该文基于 nodejs 网页中手写的常用的静态资源： JS（.js .jsx .coffee .ts） CSS（.css .less .sass .scss） Images（.jpg .png .gif .bmp .svg） Fonts （.svg .ttf .eot .woff .woff2） 模板文件 （.ejs .jade .vue） …等等 这些东西会使得网页速度变慢，其中一些会发起二次请求，以及复杂的依赖关系。 解决这些问题需要 合并压缩、精灵图、Base64(适合小图) 、requireJS、webpack（解决依赖问题）。 webpack 和 gulp 的区别： gulp：基于 task 任务。 webpack：基于整个项目，主要用于资源的合并打包、压缩等。 webpack官网：https://www.webpackjs.com/ 安装：正常安装，注意官网说的事项即可 nodejs 版本要和 webpack 某种程度上的匹配。（这里有坑） webpack4+，还需要安装 webpack-cli。 安装：https://www.webpackjs.com/guides/installation/ 基本使用：示例项目基本结构：1234567891011* dist 文件夹 放着我们所有要交付的代码* src 文件夹 放着我们的源代码 - CSS 文件夹 - images 文件夹 - js 文件夹* index.html 首页* main.js 项目 js 入口文件* package.json 导入包时创建的* webpack.config.js 手动创建 webpack 配置文件* bundle.js 打包好的文件* .babelrc babel 配置文件 基本功能 / JS 打包：处理依赖 及 兼容语法：12# npm 导入包npm i jquire 1234// main.js// 使用包，例如JQuery，使用的是 ES6 导入模块的语法import $ from 'jquery' 123# 有些浏览器无法解析 ES6 需要 webpack 处理webpack .\src\main.js .\dist\bundle.js# 将处理后的放入到指定文件下的 bundle.js 文件 1&lt;script src="../dist/bundle.js"&gt;&lt;/script&gt; 配置文件简化打包命令：12345678910111213141516171819// webpack.config.js// 使用 node 语法中的模块语法 导入 path 模块const path = require('path')// node中向外暴露配置对象module.exports = &#123; // 入口，表示要使用 webpack 打包哪个文件 entry: path.join(__dirname,'./src/main.js'), // 字符串形式 // entry: ['./src/index.js','./src/a.js'], // 数组形式打包多个js // entry:&#123;&#125; // 对象形式打包多页应用 参考进阶篇 // 出口，输出文件相关的配置 output: &#123; // 指定路径 path: path.join(__dirname,'./dist') // 指定输出的文件名称 filename: 'bundle.js' &#125;&#125; 123# 直接使用 webpack 即可webpack# 未指定 入口 出口 会直接去 'webpack.config.js' 中找 webpack-dev-server ：自动打包编译。 12# -D 安装到本地开发依赖npm i webpack-dev-server -D 由于无法直接执行非全局安装的 webpack-dev-server，所以需在 package.json 中配置一下。 1234567// package.json 文件..."scripts": &#123; ... "dev": "webpack-dev-server" // 使用 npm run dev 即可代替&#125;... 1npm run dev 注意： 即使在全局安装过 webpack 也要在本地再安装一次（坑）。 引入标签修改为：&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt; 。 打包生成的 bundle.js 并没有存放到 实际的 物理磁盘 上，而是直接托管到了电脑的内存中，因此在项目根目录中找不到。可以当做是一种虚拟的形式托管。这个机制是因为处理速度会更快。 webpack-dev-server 常用参数：第一种方式： 12345678910111213// package.json 文件..."scripts": &#123; ... "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot" /* 设置参数： 1. 自动打开浏览器 2. 设置端口号 3. 直接打开首页 4. 热启动，只更新局部打入补丁，可异步刷新，即不用手动刷新浏览器 */&#125;... 第二种方式：（比较麻烦，不推荐） 1234567// package.json 文件..."scripts": &#123; ... "dev": "webpack-dev-server“&#125;... 1234567891011121314// webpack.config.jsconst webpack = require('webpack') // 2.启用热更新需要导入，配置 plugins...devServer: &#123; // 配置 dev-server 命令参数 open: true, // 自动打开浏览器 port: 3000, // 指定端口 contentBase: 'src', // 指定托管根目录 hot: true, // 1.启用热更新 compress:true, // 启动服务器压缩 &#125;,plugins: [ // 配置插件节点 new webpack.HotModuleReplacementPlugin() // 3.new 一个热更新模块对象，启用热更新]... 基本功能 / HTML ：html-webpack-plugin 插件： 在内存中生成 HTML 页面的插件。 自动追加缺失未引入的打包好的（bundle.js）js文件。 123456789101112131415161718192021// webpack.config.jsconst webpack = require('webpack')// 导入插件使用的包，放入到 plugins 节点中去const htmlWebpackPlugin = require('html-webpack-plugin')...plugins: [ // 配置插件节点 ... new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 指定模板页面 filename: 'index.html', // 指定生成页面的名称 title: 'webpack架构', // title标签内容 hash: true, // 清缓存 minify: &#123; // 压缩 html removeAttributeQuotes:true, // 删除html标签属性的双引号 collapseWhitespace:true, // 从删除空行 &#125; &#125;) ...]... 12&lt;!--index.html EJS模板配置title--&gt;&lt;title&gt; &lt;%=htmlWebpackPlugin.options.title%&gt; &lt;/title&gt; CSS处理/loader：&lt;link&gt; 导入 CSS 会引起二次请求。 CSS 处理 非 JS 类型的文件，需手动安装合适的第三方 loader 加载器。这里分别为 style-loader css-loader。 1npm i style style-loader css-loader -D 在 webpack配置文件中新增 module对象，以及存放着所有的三方文件的匹配和处理规则的rules属性。 12// main.jsimport './css/index.css' 12345678910// webpack.config.js...module: &#123; // 所有三方加载器 rule: [ // 所有三方加载器匹配规则 // test 来源于正则方法 reg.test() &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, // 匹配 .css 结尾的文件，用 所写三方规则打包 处理 ]&#125;... 注：查找到对应的规则从后向前调用，即先css-loader处理再交给style-loader再webpack打包 less同理。 12npm i less-loader -D # less-loader 内部依赖于 lessnpm i less -D 123// main.jsimport './css/index.css'import './css/someone.less' 1234567891011// webpack.config.js...module: &#123; rule: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, // 先 less-loader 处理 &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, ]&#125;... scss同理。 12cnpm i sass-loader -D # sass 是 scss 的前身cnpm i sass -D # cnpm镜像比较好装 1234...&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;,...// -loader 在webpack1.x之后都必须带上 url（图片、字体库）/loader默认情况下，webpack 无法处理 CSS 文件中的 url 地址的图片、字体库，需要三方 loader。 url / 图片12345html,body&#123; .box&#123; background：url('./images/miao.jpg'); &#125;&#125; 1npm i url-loader file-loader # url 内部依赖 file-loader 1234// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader' &#125;,... 以上可以， 将图片转成 bace64 格式，适用于小图片。如果需要按图片大小判断是否需要，则如下传参： 12345// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader?limit=7632' &#125;,...// 如果图片大于或等于 7632byte（字节）则不会转为 base64 格式 未编码的图片会被强行修改图片名称，防止重名。但有些地方会用到同一张图片，则如下传参： 12345// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader?limit=7632&amp;name=[name].[ext]' &#125;,...// [name]表示不改名称，[ext]表示不改后缀名 当遇到放在不同文件夹下相同名称的图片会出现渲染错误，通过截取hash传参，如下： 12345// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader?limit=7632&amp;name=[hash:8][name].[ext]' &#125;,...// 截取 hash 前 8 位（总长 32 位）拼接名称 url / 字体库以 bootstrap 字体库图标为例： 1npm i bootstrap -D 1234// main.js...import 'bootstrap/dist/css/bootstrap.css'// 引入 node_modules 中的文件 可以不写 ./node_modules，默认会去这里找 12345// webpack.config.js...&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;,...// 处理字体文件loader模块 进阶使用：babel配置： babel：https://babeljs.io webpack中只能处理一部分ES6新语法，一些更高级的ES6或ES7需要借助第三方loader降维。 12345678// main.js ES6简单 Class 类 示例// 静态属性class Person &#123; static info = &#123;name: 'amiao', age:20&#125;&#125;let per = new Person() 注1：static定义静态属性，即通过类名直接访问的属性。相对的，实例属性，通过类的实例访问。 安装如下： 第一套：（转换器） 1npm i babel-core babel-loader babel-plugin-transform-runtime -D 第二套：（字典） 1npm i babel-preset-env babel-preset-stage-0 -D 1234567891011// webpack.config.js...module: &#123; rule: [ ... // 需要把 node_modules 目录，通过exclude选项将其排除掉 &#123; test: /\.js$/, use: 'babel-loader',exclude:/node_modules/ &#125; ... ]&#125;... 在项目根目录中新建 .babelrc 文件，是Babel 配置文件，属于 JSON 格式（不能写注释，字符串必须带双引号）。其中 presets（语法） 和 plugins（插件） 必需配置。 12345// .babelrc&#123; "presets": ["env", "stage-0"], "plugins": ["transform-runtime"] &#125; 多页应用打包配置打包出两个js文件。 12345678910//webpack.config.js ...entry: &#123; index: './src/index.js', a: './src/a.js'&#125;,output: &#123; filename: '[name].[hash:8].js' , path: path.resolve('./build') &#125; 对应两个html 12345678910111213141516plugin:[ new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 指定模板页面 filename: 'index.html', // 指定生成页面的名称 title: 'webpack架构', // title标签内容 hash: true, chunks: ['index'] &#125;) new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 指定模板页面 filename: 'a.html', // 指定生成页面的名称 title: 'webpack架构', // title标签内容 hash: true, chunks: ['a'] &#125;)] 指定热更新1234// index.js if (module.hot) &#123; module.hot.accept();&#125; rulesrules 的 use 用对象方便传参。 12345678910module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123;loader: 'style-loader', options:'...'&#125;, &#123;loader: 'css-loadder'&#125; ] &#125; ]&#125; 抽离样式借助三方插件。但是该配置影响了热更新，仅在上线时使用比较好。 1234567# 抽离样式 抽离到一个CSS文件 通过css文件的方式引用 # webpack3.0 npm i extract-text-webpack-plugin -D # webpack4.0npm i extract-text-webpack-plugin@next -D # 取代版npm i mini-css-extract-plugin -D 1234567891011121314151617181920212223242526272829303132333435363738394041// webpack.config.jslet ExtractTextWebpackPlugin = require('extract-trxt-webpack-plugin')// new两次分别抽离，同时要将rules里的use改成此处的名称LessExtract、CssExtractlet LessExtract = new ExtractTextWebpackPlugin(&#123; filename: 'css/less.css', disable: true&#125;);let CssExtract = new ExtractTextWebpackPlugin(&#123; filename: 'css/css.css' disable: true // 暂时先禁用&#125;);...plugins:[ new ExtractTextWebpackPlugin(&#123; filename:'css/index.css' // 抽离后的文件 &#125;)]...module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: 'style-loader' // 不生效时进入这个打包 use: [ // &#123;loader: 'style-loader'&#125;, 上线是 link 形式插入，故去掉它 &#123;loader: 'css-loadder'&#125; ] &#125;) &#125;, &#123; test: /\.scss$/, use: ExtractTextWebpackPlugin.extract(&#123; use: [ // &#123;loader:'style-loader'&#125;, &#123;loader:'css-loader'&#125;, &#123;loader:'sass-loader'&#125; ] &#125;) &#125;, ]&#125;... mini-css-extract-plugin用法参考：https://webpack.docschina.org/plugins/mini-css-extract-plugin/ webpack 构建 vue 项目参照本博 VUE篇。 注意：关于webpack 和 npm： package.json json文件中不能写注释。 ’不是内外部命令‘，可能是环境变量或未安装的问题。 Webpack 4.0补充安装按照官网安装，注意要多安装个 webpack-cli。 原理npx在 webpack 中所有文件都是模块：js模块、模块化（AMD CMD es6Module commonjs）。 123# 1.新出的 npx 可以执行 node_module 对应的 bin 下的 webpack.cmd 文件npx webpack #（node8.5以上会有）# 2.紧接着会找 webpack.cmd 下定义的 webpack.js 执行 这样直接运行的话是进行默认打包，但通常情况下我们会使用 webpack.config.js 对其进行配置定义。 webpack.config.js该文件是基于 node 的，需要尊循 commonjs 规范 123456789101112131415// config.js 常用配置let path = require('path')module.exports = &#123; entry: '', // 入口 output: &#123; // 出口 filename: 'build.[hash:8].js', // 配置hash为了清缓存 path: path.resolve() // 这个路径必须是绝对路径所以使用path模块 resolve() 方法解析 &#125;, devServer: &#123;&#125;, // 开发服务器 module: &#123;&#125;, // 插件的配置 plugins: [], // 插件配置 mode: 'development', // 可以更改模式 resolve: &#123;&#125;, // 配置解析&#125; 更多webpack.config.js解析可以参考：https://webpack.docschina.org/configuration build.js打包文件此处假设是打包好的文件 上半部分是 自定义函数 是webpack的启动函数，下半部分是执行的参数 12345678910111213141516(function (modules) &#123; // webpackBootstrap webpack的启动函数 // The module cache 缓存模块对象，放着模块de缓存 ... // The require function ... // Check if module is in cache 先检查模块是否存在缓存中 ... // Create a new module (and put it into the cache) ... // Execute the module function 调用方法 执行模块功能 ... // Flag the module as loaded 将模块标记为已加载 ... ...&#125;) package.json这个文件记录一些版本信息等。 12345678"scripts": &#123; "build": "webpack", "dev": "webpack-dev-server“, "...":"...."&#125; // 其中 这个字段可以配置一些我们自定义的脚本 // build 一般为上线打包 // dev 一般为开发打包 插件补充介绍插件。 12# 带hash时清缓存的插件npm install clean-webpack-plugin -D 12# 清除未使用到的样式 注意升级问题npm i purifycss-webpack purify-css glob -D npm purifycss-webpack：https://www.npmjs.com/package/purifycss-webpack 12# 自动加前缀 -webkit- 等npm install postcss-loader autoprefixer -D npm postcss-loader：https://www.npmjs.com/package/postcss-loader 12# copy 插件npm i copy-webpack-plugin -D npm copy-webpack-plugin：https://www.npmjs.com/package/copy-webpack-plugin 123# 引入一个模块既可以全局使用，又想import引入# 可以使用 ProvidePlugin 或 暴露模块的插件npm i export-loader -D ProvidePlugin：https://www.webpackjs.com/plugins/provide-plugin/ export-loader：https://www.npmjs.com/package/export-loader 12# 分析webpack打包内容 性能分析npm install --save-dev webpack-bundle-analyzer webpack-bundle-analyzer：https://www.npmjs.com/package/webpack-bundle-analyzer]]></content>
      <categories>
        <category>技术 - 前端构建工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由 todoMVC 深入 VUE.2x]]></title>
    <url>%2F2019%2F03%2F21%2FVueDetail%2F</url>
    <content type="text"><![CDATA[简介：此处的 Vue 指的是 Vue2… 简易实现： 这里是简易实现其双向绑定等功能的 todoList 。 123.done &#123; color:#ccc;&#125; 1234567891011&lt;div id="app"&gt; &lt;h1&gt;ToDoList&lt;/h1&gt; &lt;p&gt;&#123;&#123; todos.filter(item =&gt; !item.done).length &#125;&#125; of &#123;&#123; todos.length &#125;&#125; remaining [archive]&lt;/p&gt; &lt;p v-for="(item,index) in todos"&gt; &lt;input type="checkbox" v-model="item.done"&gt; &lt;span v-bind:class="&#123;done: item.done&#125;"&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt;tton &lt;button @click="handleRemoveTodoClick(index)"&gt;&lt;/button&gt; &lt;/p&gt; &lt;input type="text" @keydown.enter="handleAddTodoClick" v-model="todoText"&gt; &lt;button @click="handleAddTodoClick"&gt;Add&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344const todos = [ &#123; id: 1, title: '上班', done: true &#125;, &#123; id: 2, title: '撸代码', done: true &#125;, &#123; id: 3, title: '加班', done: true &#125;]const app = new Vue(&#123; el: '#app', data: &#123; todos, todoText: '' &#125;, methods: &#123; handleAddTodoClick () &#123; const todos = this.todos const todoText = this.todoText.trim(); // 非空校验 if (!todoText.length) &#123; return &#125; this.todos.push(&#123; id: todos[todos.length - 1].id + 1, title: todoText, done: false &#125;) // 清空文本框 this.todoText = '' &#125;, handleRemoveTodoClick (index) &#123; this.todos.splice(index,1) &#125; &#125;&#125;) 基础注意：值得注意的基础内容。 el:123new Vue(&#123;el:'#app'&#125;)也可以写为 new Vue(&#123; data... &#125;).$mount('#app')。//将 app 绑定到 window 上以便于使用 localStroage 等window.app = new Vue(&#123;...&#125;).mount('#app') 数据绑定 data：12345678910111213141516171819201. `v-once` 一次性绑定 &#123;&#123; message &#125;&#125;。2. `rawHTML:'&lt;h1&gt;...&lt;/h1&gt;'` - 可以用 `v-html="rawHTML"` - 渲染输出 &#123;&#123; rawHTML &#125;&#125; 转义不渲染。 3. `&#123;&#123; message &#125;&#125;` 接受： - 输出文本字符串及拼接 `&#123;&#123; 'Hello' +word &#125;&#125;`。 - 三元表达式 `&#123;&#123; true ? 123 : 456 &#125;&#125;` 。 - `&#123;&#123; message.split('').reverse().join('') &#125;&#125;` - 不能写进标签绑定属性（使用 v-bind）。 - 不能用于双向绑定 （使用 v-model）。 - 会有闪动问题 （使用 v-text/v-cloak）4. v-bind 之于绑定 标签属性： - v-bind 绑定字符串及拼接 `v-bind:href="'/todos?id=' + item.id"` 。 - v-bind 三元表达式 `v-bind:id="'list'"`。5. HTML 字符串中不能使用 Vue 语法（非组件内）。6. data 中的成员只能修改，不能外部添加。7. v-model 用于表单控件的各种双向绑定。 指令 v-：1234567891011121314151617181. `v-if = "true"` 条件渲染。 - 如果想要渲染多个元素，可以用 template 元素包裹，最终结果 template 将不被渲染。 - v-if 惰性渲染，直接决定是否渲染元素，v-show，决定是否显示元素。2. `v-for="(item,index) in todos"` 循环渲染。 - 可以循环 数组 对象 数字 数组对象。 - 使用 key 绑定到更加牢固。 3. `v-bind:placehodler="tip"` 绑定属性 有参数 缩写 :placehodler。4. `v-model.number="number"`，用户输入的全部都是字符串，需要数字转换可以用该修饰符。5. `v-on:click.prevent="handlelInputFocus"` 绑定事件 有参数 可有修饰符 缩写 @click。 - 指令修饰符可串联 - .stop 阻止事件冒泡。.self只管理自己，嵌套时不阻止外层冒泡。 6. v-pre Vue将跳过被该标记标记的块。7. `v-text = "&#123;&#123; message &#125;&#125;"` 解决单个元素闪动问题。8. v-cloak `[v-cloak]&#123;display:none&#125;`，解决代码块闪动问题，可以继续用 `&#123;&#123; message &#125;&#125;`。 绑定样式：12345671. `:class="&#123;active:false&#125;"` - `:class="[activeClass,errorClass]"` 3. `:style="&#123;backgroundColor: bgc&#125;"` 样式名驼峰命名法 - `:style="[baseStyle,overridingStyle]"` - `:style` 可以自动添加浏览器引擎前缀 - `:style="&#123;display:['-webkit-box','-ms-flexbox','flex']&#125;"`多重值，添加多个浏览器前缀 选项注意：methods/computed/watch 对比： computed 适合一些反复使用简单计算，会作为属性被存储。 methods 适合比较复杂的业务逻辑，方法集合。 watch 适合对一些特殊的数据监听再进行具体的业务逻辑。 方法 methods：123451. methods 中的方法不要使用箭头函数，否则其中的 this 指向 window。 - methods 当传入自己的参数的时候，event 需要手动传入，`@click = "fn(index,$event)"`。 - v-on 注册的方法可以直接通过 this 来访问 data 中的数据成员。 - 模板中使用方法必须调用，即带括号 `&#123;&#123; fn() &#125;&#125;`。 - 一个方法清除另一个方法中的定时器 id，该 id 放到 data 中去。 计算属性 computed:具有行为的属性。 123456789101112131415161718192021// 当想要显示一个数组的副本，而不改原始数组时，可以创建返回过滤或排序的计算属性// ...computed:&#123; //默认只有 getter 'message': function () &#123; return this.number + 1; &#125; //使用 setter oneComputed:&#123; // 取值 get () &#123; // 计算属性被使用时，会调用 get 计算出的值 &#125;, // 赋值 set () &#123; // 当你想要为 oneComputed 重新赋值的时候就会调用 set 方法 // set 中的方法使用 this.oneComputed 就是指向自己的 get() 值 &#125; &#125;&#125;//... 使用到的 data 中的变量改变时，会随即跟着改变重新计算。 当做属性调用不是用调用方法的方式。 使用计算属性出现渲染不对错误：在过滤后再次编辑 完成/未完成按钮 ，出现渲染错误，按官方文档 在 v-for 之后给予 v-bind 解决。 1v-for="item in items" v-bind:key="item.id" 适用于所有列表渲染不正确。 侦听器 watch:可以监听 data 上的所有数据。 12345678910111213141516// ... va1,oldVal2 变化的值的新老值watch: &#123; a: function (va1,oldVal2) &#123; // 用方法侦听 a &#125;, b: "oneMethod", // 调用方法侦听 b c: &#123; handler: function (va1,oldVal2) &#123;...&#125;, // handler 是固定的不能乱写 deep: true // 深度监听 c ——&gt; 监听引用类型的数据时可用 &#125;, d: &#123; onclickIt: function (va1,oldVal2) &#123;...&#125;, immediate: true // 侦听 d 开始后，立即调用 &#125;&#125;// ... 也可以监听非 dom 元素，比如 路由变化，参考 路由 过滤器 |fn ：本质就是格式转化的方法，在需要调用的地方以其要求格式调用。 用作一些常见文本格式化。用在两个地方，双花括号插值和 v-bind 。 123 &lt;!--调用：&#123;&#123; name | 过滤器名称 |...&#125;&#125; 把结果依次向后过滤--&gt;&lt;p&gt; &#123;&#123; message | msgFormat(arg,arg2) | ... &#125;&#125; &lt;/p&gt;&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt; 12345678910// 全局Vue.filter('msgFormat',function (msg,arg,arg2) &#123; return msg.replace(msg,arg+arg2)&#125;)// 组件filters: &#123; formatId: function (msg,arg,arg2) &#123; return msg.replace(msg,arg+arg2) &#125;&#125; 注意：定义全局过滤器一定要在 Vue 实例之前，当全局过滤器和局部过滤器重名时，会采用局部过滤器。 自定义修饰符：键盘码 1&lt;input @keyup.f2="add"&gt; 12// 全局Vue.config.keyCode.f2 = 113; 生命周期函数： 函数名称/进程 进行阶段/执行时机 beforeCreate () {} 实例被创建出来之前 执行，此时实例中的 data 和 methods 还没有创建 created () {} 此时 data和methods 已被初始化，调用其中的值，最早在这里 — 判断环 — Vue 开始执行指令，内存中生成模板字符串，再渲染为内存中的DOM树 beforeMount () {} 在内存中已生成模板字符串，还未渲染（挂载）到页面 — 执行环 — 挂载到页面 mounted () {} 挂载到页面后执行该函数（通过插件执行页面DOM节点的最早时期） — 创建完成 — 组件完全创建 ok 进入 运行阶段** beforeUpdate () {} 数据更新，界面未更新时触发 — 更新界面 — 根据 data 更新界面 updated () {} 界面 以更新 beforeDestroy () {} 组件销毁之前，Vue上的data,methods等还处于可用状态 — 销毁实例 — 销毁实例 destroyed () {} 组件已完全销毁时执行 — 此外 — activated () {} 待补充 deactivated () {} 待补充 errorCaptured () {} 待补充 自定义指令：语法：对普通 DOM 元素进行底层操作，会用到自定义指令。 1234567891011121314151617181920212223242526272829303132333435// 全局Vue.directive('focus',&#123; bind (el, binding) &#123; //el为绑定元素 binding.value 为传入的值 ... &#125;&#125;)// 私有...directives: &#123; 'fontweight': &#123; bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;&#125;... // 私有简写directives: &#123; 'fontweight':function (el, binding) &#123; // 若只关心 bind 和 update 可以简写，直接写函数 &#125;&#125;/** 第一个参数是命名：1. 分为全局（注册）自定义指令、局部（注册）自定义指令。2. 使用时，名字加 v-。3. 驼峰命名 使用时加 v-，且改小写，用 - 连接。4. 组件内定义的自定义指令，只能在被该组件管理的模板中使用。第二个参数需要配置生命钩子函数：1. 生命钩子里有 dom 和 值，即可以进行 DOM 操作。使用时传入的值：1. 需要传入多个值，可以使用 js对象字面量。2. 指令函数可以接受所有合法的 js 表达式。 **/ 钩子函数：123456789101112131415161718192021222324252627282930// 相对于 指令定义对象可以提供如下几个钩子函数bind (el) &#123; // 只调用一次 指令第一次绑定到元素上（加载到内存上）时调用，初始化指令时使用。拿不到父结点 // 和样式相关 放到这里 el.timer = setInterval(function()&#123; console.log(1) &#125;,1000)&#125;;inserted () &#123; // 被绑定元素插入父结点时（渲染到页面上时）调用。可以拿到父节点。 // 和 JS 行为相关，放到这里&#125;;update () &#123; // Vue 管理的模板中的 DOM 更新前调用，若需要改变之前的数据&#125;;componentUpdated () &#123; // Vue 管理的模板中的 DOM 更新后调用，若需要改变之后的数据 &#125;;unbind () &#123; // 只调用一次 // 解绑时使用，及元素移除时。移除其他生命周期中的函数，定时器等。（防止内存泄漏？） window.clearInterval(el.timer)&#125;;/** 可以传四个参数：1. el 作用于该指令的 DOM 对象。2. binding 一个对象,可以获取指令的值等信息，就可以拿指令值和DOM进行比较判断。3. vnode4. oldVnode **/ 手动实现 v-show:12345678910111213141516171819202122232425262728293031//html... v-my-show = "seen" ...// new Vuenew Vue(&#123; data:&#123; seen:true &#125;&#125;).$mount('#app')// 手动实现 v-show 效果Vue.directive('my-show',&#123; bind (el,binding) &#123; // 只能调用一次，也可以绑到其他生命周期上 console.log('my-show bind',el,binding); if (binding.value) &#123; el.style.display = 'block' &#125; else &#123; el.style.display = 'none' &#125; &#125;, update (el,binding) &#123; // 更新时调用 if (binding.value) &#123; el.style.display = 'block' &#125; else &#123; el.style.display = 'none' &#125; &#125;&#125;)// 若只关心 bind 和 update 可以简写，直接写函数Vue.directive('my-show',function (el, binding) &#123; el.style.display = binding.value&#125;) 手动实现 v-bind:1234567891011121314151617181920212223242526272829303132333435// 实现 v-bind:title="message" 效果Vue.directive('my-bind',&#123; bind (el,binding) &#123; el.setAttribute(binding.arg,binding.value) &#125;, update (el, binding) &#123; el.setAttribute(binding.arg,binding.value) &#125;&#125;)// 或简写Vue.directive('my-bind',function (el, binding) &#123; el.setAttribute(binding.arg,binding.value)&#125;)// 进一步实现 v-bind:class = "&#123;&#125;"Vue.directive('my-bind',&#123; bind (el, binding) &#123; if (binding.arg === 'class') &#123; for (let key in binding.value) &#123; if (binding.value[key]) &#123; el.classList.add(key) &#125; else &#123; el.classList.remove(key) &#125; &#125; &#125; else &#123; el.setAttribute(binding.arg,binding.value) &#125; &#125;&#125;)const app = new Vue(&#123; data:&#123; message:"myTitle" &#125;&#125;) vue-resource 之请求: vue-resource: https://github.com/pagekit/vue-resource 也可以用 axios 测试请求资源，我用的是 豆瓣API 123456789101112131415161718192021222324252627...methods: &#123; fnName () &#123; // res 成功回调必须要传，err 可选 this.$http.get(/url/...,[options]).then(res=&gt;&#123; console.log(res) &#125;,err=&gt;&#123; console.log(err) &#125;) // [body] 提交给服务器的内容， // [option]提交的内容格式，数据类型， // 一般为 application/x-www-form-unlencoded this.$http.post(/url/...,[body],[options]).then(res=&gt;&#123; // 比如添加数据，添加完成后手动调用一下获取列表方法刷新数据 if (res.body.status ===0) &#123; getList() &#125; else &#123; console.log('失败了') &#125; &#125;,err=&gt;&#123; &#125;) &#125;&#125;... 全局配置数据接口的根域名：vue-resource: Set default values using the global 123456// 为了避免根域名过多重复，不易维护Vue.http.options.root = '/root';// 使用时必须是以相对路径开头// 配置 POST 提交的内容格式Vue.http.options.enulateJSON = true; 跨域：JSONP：12345678910&lt;!-- 前端页面 --&gt;&lt;body&gt; &lt;div&gt; ... &lt;/div&gt; &lt;script&gt; function showInfo(data) &#123; console.log(data) &#125; &lt;/script&gt; &lt;script src="http://127.0.0.1:3000/getscript?callback=showInfo"&gt;&lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819// 后端代码 node.jsconst http = require('http')const urlModule = require('url')const server = http.createServer()server.on('request',function (req, res) &#123; const &#123; pathname:url, query &#125; = req.urlModule.parse(req.url, true) if (url === '/getscript') &#123; var scriptStr = `$&#123;query.callback&#125;($&#123;JSON.stringify(data)&#125;)` res.end(scriptStr) &#125; else &#123; res.end('404') &#125;&#125;)server.listen(3000,function()&#123; console.log('server listen at http://127.0.0.1:3000')&#125;) 动画：过度的类名： 过度类名 时机 v-enter 定义进入过渡的开始状态。 v-enter-active 定义进入过渡生效时的状态。 v-enter-to 定义进入过渡的结束状态。 v-leave 定义离开过渡的开始状态。 v-leave-active 定义离开过渡生效时的状态 v-leave-to 定义离开过渡的结束状态。 transition （单个）元素：Vue 官方提供的元素。 123456789101112131415.v-enter,.v-leave-to&#123; /* 由于起始状态 样式相同，故写在同一样式中 */ opacity: 0; transform: translateX(150px); /*transform:位移*/&#125;.v-enter-active,.v-leave-active&#123; /* 入场离场的动画的时间段：对象，速度，曲线 */ transition: all 0.4s ease;&#125;.mark-enter,.mark-leave-to&#123; /* 由于起始状态 样式相同，故写在同一样式中 */ opacity: 0; transform: translateY(150px); /*transform:位移*/&#125;.mark-enter-active,.mark-leave-active&#123; /* 入场离场的动画的时间段：对象，速度，曲线 */ transition: all 0.4s ease;&#125; 12345678&lt;input type="button" value="toggle控制动画的控制模块" @click="flag=!flag"&gt;&lt;transition&gt; &lt;div v-if="flag"&gt;我是原始动画模块&lt;/div&gt;&lt;/transition&gt;&lt;transition name="mark"&gt; &lt;div v-if="flag1"&gt;我使用的是mark标识的动画样式&lt;/div&gt;&lt;/transition&gt; 123456...data: &#123; flag:true, flag1:true,&#125;... animate.css 三方类实现：animate.css 三方类库 12345678910111213141516171819202122232425&lt;transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut"&gt; &lt;div v-if="flag2"&gt; 1. animate直接在标签上de属性上add类 2. animated 是基础类 &lt;/div&gt;&lt;/transition&gt;&lt;transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="800"&gt; &lt;div v-if="flag3" class="animated"&gt; 1. animated也可以直接放在元素上 2. :duration="毫秒值" 入场离场总共花费的时间 &lt;/div&gt;&lt;/transition&gt;&lt;transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="800"&gt; &lt;div v-if="flag3" class="animated"&gt; 1. animated也可以直接放在元素上 2. :duration="&#123;enter:200, leave:400&#125;" 传入对象 入场离场各自时长 &lt;/div&gt;&lt;/transition&gt; 钩子函数，半程动画：这里的钩子指的是动画的生命周期，半程动画需要借助 动画钩子函数。 123456789101112&lt;!-- 如果写半程动画，只需要定义 上或下 函数即可 --&gt;&lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter" @enter-cancelled="enterCancelled" @before-leave="beforeLeave" @leave="leave" @after-leave="afterLeave" @leave-cancelled="leaveCancelled"&gt; &lt;div class="ball" v-show="flag"&gt;&lt;/div&gt;&lt;/transition&gt; 12345678910111213141516171819// ... el 控制的元素methods: &#123; beforeEnter (el) &#123; // 起始样式 el.style.transform = "translate(0,0)" &#125;, enter (el,done) &#123; el.offsetWidth // 强制动画刷新，显示过渡效果 // 起始后的样式，这里可以设置结束状态 el.style.transform = "translate(150px, 150px)" el.style.transition = 'all 1s ease' done() // 这里的 done 就是指 afterEnter函数 的应用 &#125;, after-enter (el) &#123; // 动画完成之后 this.flag = !this.flag &#125;&#125;// ... leave () 和 enter () 中写 done() 列表transition-group（多个元素）动画： 当列表是用 v-for 循环渲染的，使用 transition-group 代替 transition元素。 不仅有 transition 的进入和出时的过渡类，另外添加了新的 .v-move 类。可以在元素改变定位的过程中使用。 注意：在 v-for 添加 key 属性:key=&quot;item.id&quot;。 需要平缓过渡除了添加 .v-move 类，还要设置 .v-leave-active 类 position:absolute。 transition-group 上的 appear属性 增添入场效果。 transition-group 上的 tag属性 ，将 transition-group 渲染为什么属性，如果没有默认为 span标签。 组件过渡(动画)：组件：模块化：从代码逻辑划分，保证功能模块职能单一。 组件化：从UI界面划分，方便 UI 重用。 基础：1234561. 组件，在 VUE 中即一个特殊（可复用）的 Vue 实例。 - 组件的 data 是一个 data函数 返回的对象的形式。使得重复使用，也互不影响。 - 组件是独立作用域。 - 组件里 根元素 唯一。 - 全局注册（Vue.component()）。可以在任意组件中（子兄）使用。 - 局部注册（components:&#123;&#125;）。组件实例选项 components 选项。只能在本组件使用。 全局注册:12345678910111213141516171819202122// 第一种方式：内部定义Vue.component('my-component', &#123; // 此处若命名 驼峰，使用时用 - 连接 template: `&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;`, data () &#123; // 组件中使用 data选项 特有形式，保证可重复使用 return &#123; message: '...' &#125; &#125;, methods: &#123;&#125;, ..., components: &#123; hello: &#123; // 键名就是组件名称，值是一个对象，对象中配置组件选项 template: `&lt;div&gt;&#123;&#123;message2&#125;&#125;&lt;/div&gt;` &#125; &#125;&#125;)// 第二种方式：Vue.extendvar vm = Vue.extend(&#123; template: '&lt;h3&gt;这是创建Vue组件的第二种方式&lt;/h3&gt;'&#125;)Vue.component('my-component', vm); 123456789&lt;!-- 第三种方：外部定义 --&gt;&lt;template id="tmpl"&gt; &lt;div&gt;这是创建组件的第三种方式&lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-template', &#123; template: '#tmpl' &#125;)&lt;/script&gt; 局部组件：使用 Vue 实例中的 components 选项。 12345678...components: &#123; my-component: &#123; // 内部定义 template: '&lt;div&gt;我仅在定义内的实例中使用&lt;/div&gt;' &#125;, template: '#mycomponentid' // 外部定义&#125;... 12345&lt;template id="mycomponentid"&gt; &lt;div&gt; 我是局部组件外部定义 &lt;/div&gt;&lt;/template&gt; 组件切换：&lt;component :is=&quot;mycomponentflag&quot;&gt;&lt;/component&gt; 组件通信：12345671. 父子关系 * 属性（prop）向下传递（父传子）。Pass Props * 事件（event）向上传递 （子传父）。Emit Events2. 非父子关系 * Event Bus3. 专业组件通信 * Vuex 状态管理 prop:1&lt;todo-list message="message" v-bind:foo="todos"&gt; 父 &lt;/todo-list&gt; 12345678// 子用 props 选项声明，当做子组件的数据使用...,props:['message','foo'], // 自己组件声明的变量...,// 1. 第一个是字符串形式。// 2. 第二个只有 v-bind 传输是动态数据形式。且为单项数据流，不能修改，只能使用。// 3. 如果是引用类型（对象和数组）则可以修改（不能重新赋值），但是不推荐使用。// 4. 但是子可以用事件（event）把数据给父亲，由父亲改。 event / $emit():子组件内部调用父组件的方法，可以顺便传值 1234567891011121314151617// 1. 在 父组件 中定义一个方法。 ..., methods: &#123; addTodo (titleText) &#123; titleText = titleText.trim() if (!title.Text.length) &#123; return &#125; const todos = this.todos todos.push(&#123; id: todos[todos.length - 1].id + 1, title: titleText, completed: false &#125;) &#125; &#125;, ..., 12345678910111213// 2. 在 子组件 内部调用父组件的方法 ..., methods: &#123; handleKeyDown (e) &#123; const target = e.target const value = target.value.trim() if (!value.length) &#123; return &#125; this.$emit('newTodo',value) &#125;, &#125;..., 1&lt;todo-header v-on:newTodo="addTodo"&gt; 父组件标签 &lt;/todo-header&gt; $ref 引用：ref [ reference : 引用 ] $ref / 获取 DOM 元素：1234&lt;input type="button" value="获取DOM元素内容" @click="getElement"&gt;&lt;div id="myId" ref="myId"&gt; Vue 中推荐用 this.$refs 获取我&lt;/div&gt; 1234567...methods: &#123; getElement () &#123; console.log(this.$refs.myId.innerText) &#125;&#125;... $ref / 组件引用：12&lt;input type="button" value="获取DOM元素内容" @click="getElement"&gt;&lt;my-template ref="mytemlate"&gt; 子组件的data：&#123;&#123; sondata &#125;&#125; &lt;/my-template&gt; 12345678910111213// 子组件...data () &#123; return &#123; sondata: '我代表子组件数据' &#125;&#125;methodes: &#123; show () &#123; console.log('我代表子组件的方法') &#125;&#125;... 12345678910// 根实例...methods: &#123; getElement () &#123; console.log(this.$refs.mytemplate.sondata) this.$refs.mytemplate.show() &#125;&#125;... 路由 vue-router:后端路由是： url 对应 后端资源。 前端路由是： 单页面程序用 hash 实现页面跳转，不会涉及到页面的刷新。 安装使用： 官方入口 : https://router.vuejs.org/installation.html#direct-download-cdn 基本使用：在导入 vue-router 包之后，会在 window 全局对象中创建一个 路由的构造函数 VueRouter。 12345678910111213141516171819202122// 组件var mytpl = Vue.extend(&#123; template:'&lt;div&gt; 我是组件1，组件2省略 &lt;/div&gt;'&#125;)Vue.component('template-name1', mytpl)// 构造路由器 配置对象（路由规则配置）var routerObj = new VueRouter(&#123; routes: [ // component 值只能是组件模板对象，不能是组件名称 &#123;path: '/templateUrl1', component: mytpl&#125;, &#123;path: '/templateUrl2', component: mytpl2&#125;, &#123;path: '/', redirect: '/login'&#125; // refirect 仅修改hash值的 "重定向" ], linkActiveClass: 'myactive' // 修改给予的link-active-class类名&#125;)// Vue 根实例 router 选项挂载，用来监听 url 地址变化...router: routerObj... 123456789&lt;!-- 页面组件导航 &lt;a href="#/templateUrl1"&gt;&lt;/a&gt;--&gt;&lt;!-- 默认为 a标签 可以用 tag属性 修改--&gt;&lt;router-link to="/templateUrl1"&gt;&lt;/router-link&gt;&lt;router-link to="/templateUrl2" tag="span"&gt;&lt;/router-link&gt;&lt;!-- 页面组件入口 --&gt;&lt;transition mode="out-in"&gt; &lt;!-- 动画元素 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 123456/* router提供 CSS 类名 */.router-link-active,.myactive &#123;&#125;/* 动画效果 */.v-enter,.v-leave-to &#123;&#125;.v-enter-active,.v-leave-active &#123;&#125; 路由传参 / $router：12345678910111213141516171819var mytpl = &#123; template: '&lt;div&gt;&#123;&#123; $route.query.id &#125;&#125;&amp;&amp;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;' created () &#123; console.log(this.$route) // console 路径信息 &#125;&#125;var routerObj = new VueRouter(&#123; routes: [ &#123;path: '/templateUrl1?id=10&amp;name=zs', component: mytpl&#125;, &#123;path: '/templateUrl2/:id', component: mytpl2&#125;, &#123;path: '/', redirect: '/login'&#125; ], linkActiveClass: 'myactive'&#125;)/* query 方式传递参数： 1. 如果在路由中使用 ?查询字符串 不需要修改 path 属性，在 query 里 2. :id 是经 matchd 正则解析过得id值，在 params 里*/ $route.path 监听路由：1234567891011... watch: &#123; 'this.$route.path':function (newVal, oldVal) &#123; if (newVal === '/login') &#123; alert('欢迎登录') &#125; else if (newVal === '/register') &#123; alert('欢迎注册') &#125; &#125; &#125;... 路由嵌套/children项：1&lt;router-link to="/mytpl/child1"&gt;&lt;/router-link&gt; 12345678910111213var routerObj = new VueRouter(&#123; routes: [ &#123; path: '/templateUrl1?id=10&amp;name=zs', component: mytpl, // path前面不要带 / 否则会以根路径开始请求，不方便用户理解用户地址 children: &#123; &#123;path:'child1',component: child1&#125; &#125; &#125; ], linkActiveClass: 'myactive'&#125;) 路由布局/router-view name属性：12345678910111213var routerObj = new VueRouter(&#123; routes: [ &#123; path: '/', component: &#123; 'default': header, 'left': leftBox, 'main': mainBox &#125; &#125; ], linkActiveClass: 'myactive'&#125;) 12345&lt;router-view name="header"&gt;&lt;/router-view&gt;&lt;div class="container"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;router-view name="main"&gt;&lt;/router-view&gt;&lt;/div&gt; 基本项目结构：1234567index.html 首页 | main.js 组件化应用启动入口 | app.js APP.js 根组件 | ... 各个组件 webpack之Vue：render：使用 render 方法渲染组件。 1234567891011var mytemplate = &#123; template: '&lt;div&gt;我是一个组件&lt;div&gt;'&#125;var vm = new Vue(&#123; ... render: function (createElement) &#123; var html = createElements(mytemplate) return html &#125; ...&#125;) return 的结果会替换 el 指定的容器。但是之中只能放一个组件。 webpack配置：在webpack构建的项目中进行vue开发。 1npm i vue -S # 将vue安装到项目运行阶段 1234567// main.jsimport Vue from 'vue' // 此处的vue功能不完整，只提供了 runtime-onlyimport Vue form '../node_modules/vue/dist/vue.js' // 比较全var vm = new Vue(&#123; el:'#app'&#125;) 注意：在VUE中package.json文件中查找 main 属性来查找node import导入的包。 如果使用第一种导入方式需要在webpack.config.js 中配置 resolve属性。 12345678// webpack.config.js...resolve:&#123; alias: &#123; // 设置（修改） Vue 被导入包的路径 "vue$": "vue/dist/vue.js" &#125;&#125;... runtime-only 不提供传统创建组件模式，此时将引入 .vue 格式文件。 .VUE：1234567891011121314151617181920212223242526272829&lt;!-- mytemplate --&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;一个组件只能有一个根元素（div）&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 这里写组件的业务逻辑 用ES6规范 export default 导出 export default &#123; data () &#123; // 这里组件中的 data 必须是 function return &#123; msg: &quot;234&quot; &#125; &#125;, methods: &#123; &#125; &#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt; /*1. scoped 指定作用域（给div块自动添加属性） 2. lang=&quot;****&quot; 启用 预编译*/ body&#123; div &#123; color: red; &#125; &#125;&lt;/style&gt; 向外暴露成员的方式 ES6 和 node.js： node中是 module.exports={}`exports.a=’’向外暴露成员，var 名称 = require(‘模块标识符’)` 加载模块，详细参考 node 中3.5.1 CommonJS 模块规范。 ES6 中 import 模块名称 form &#39;模块标识符&#39;、import &#39;标识路径&#39; 导入模块，使用 export default（只允许向外暴露一次，类似于 module.exports） 和 export（import {模块名1，模块名2 as 别名...} form &#39;标识路径&#39; 按需导出）向外暴露成员（两者可以同时使用）。 注意不要混用。 webpack 无法打包 .vue 文件，需要用到相关的第三方 1npm i vue-loader vue-template-compiler -D # 前者内部依赖后者 12345678910// webpack.config.js...module: &#123; rule: [ ... // 处理 .vue 文件 loader &#123; test: /\.vue$/, use: 'vue-loader'&#125; ... ]&#125;... 然后使用 render 实现组件渲染 12345678910// main.jsimport mytemplate from './mytemplate.vue'var vm = new Vue(&#123; el: '#app', data: &#123; msg:'123' &#125;, render: c =&gt; c(mytemplate)&#125;) 总结： 安装配置 vue 及 webpack打包vue的三方包。 导入 vue 模块 创建.vue组件文件并导入 创建实例使用 render 创建实例控制区域… webpack 结合 vue-router：根据 官网 模块化导入安装： npm i vue-router -S 安装。 import VueRouter from &#39;vue-router&#39; 导入。 Vue.use(VueRouter) 手动安装。 import app form &#39;./main/app.vue&#39; 导入组件。 var router = new VueRouter({...}) 创建路由对象。 将 其他组件 router-view 写到 根组件 里去 抽离组件模块，将2 4（除根组件外）5的内容抽出 export default router 并在 main.js 接收 Vuex为了保存组件之间共享的数据而诞生的，是一个公共数据管理工具，方便整个项目调用。 导入使用 官网: https://vuex.vuejs.org/zh/installation.html 123456789101112131415161718192021222324252627282930313233343536// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)//0. 导入import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 1.声明const store = new Vuex.Store(&#123; state: &#123; // 相当于 data count: 0 &#125;, mutations: &#123; // 负责修改数据 相当于 methods increment (state,...) &#123; // 自增方法 最多可传两个参数，但可以是对象，数组。。。 state.count++ &#125; &#125;, getters: &#123; // 负责对外提供数据 optCount: function (state)&#123; // 相当于组建中的过滤器,都不修改原数据 return '当前最新count：'+ state.count &#125; &#125;&#125;)// 2.挂载到实例var vm = new Vue(&#123; el:'#app', store&#125;)// 3.1 组件中使用v-model="$store.state.count" // 3.2 组建中使用方法 //this.$store.commit('方法名') 类似于 this.$emit('父组件中的方法名')this.$store.commit('increment',...) // 3.3 组建中调用getters 调用又类似 计算属性this.$store.getters.optCount 采坑注意 不推荐直接在组件中操作 state 中的数据，容易导致数据紊乱。通过调用 mutations 提供的方法操作。 vuex 中方法第一个参数永远都是 state 小技巧：12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. Console * `console.dir()` 在控制台可以将传入的元素展开。 * 控制台输入 document.body.classList.(...) 可查看操作 className 的方法。 2. JSON * `JSON.Stringify(&#123;key:"value"&#125;);` 对象转为字符串，某些参数只能是字符串。 * `JSON.parse(JSON.Stringify(&#123;key:"value"&#125;));` 在将字符串转为 JSON。 * `JSON.parse('[]');` // [] JSON格式数组 转为 数组 3. H5 新增 * window.localStorage - `window.localStorage.setItem("key","String")` - `window.localStorage.getItem("key")` * autofocus H5新特性在 Vue 中不稳定（因为虚拟 Dom 问题），需要自定义 - focus 在多个列表时，仅在第一个生效。 4. hash * `window.onhashchange = function()&#123;&#125;` 注册hash的改变事件 * `window.location.hash` 获取hash 5. Vue * 自定义 v-my-focus 指令必须写在 inserted 钩子函数中。 * 双击事件 ondblclick,在 vue 中为 `@dblclick`。 * vue 提供的标签一共四个 component, template, transition, transitionGroup * 标签中 `&lt;input name="string"&gt;` 字符串，js中带引号。 * `&lt;input :value="'value'"&gt;`注意区分变量和值，表值，js中不带引号。 6. 涉及的 ES6： * 可以使用 ES6 简写 省去 function 写为 `handleCountClick () &#123; ... &#125;`。 * ES6 语法 当键和值一样的时候，可以简写，只写一个。 * ES6 新添加的操作数组的方法 forEach some filter findIndex - some() 中返回 true 会立即终止循环 - 当循环遍历删除元素的时候不要用 forEach() 用 for 循环,循环结尾 i--。 * ES6操作字符串 + 新添加includes() - 判断数组名字里里是否包含 keywords： - `if (item.name.indexOf(keywords) != -1)` - `if (item.name.includes(keywords))` + 头尾填充字符串 - String.prototype.padStart(maxLength,fillString="") - String.prototype.padEnd(maxLength,fillString="") * 箭头函数 this 指向外部 - 定时器内部使用箭头函数可指向外部。 * 模板字符串变量用 $&#123;&#125; 包裹 * 参数可设置默认值 `function (pattern="") &#123;&#125;` 7. JS * replace() 第一个参数是需要替换的内容，可以是字符串，也可以是正则。 回顾概念：M V VM：M V VM 是前端的视图层的分层开发思想，主要把每个页面分成了 M，V，VM。VM 是两者的桥梁。 123451. M 是保存每个页面的中的单独的数据。 （Vue中的选项 data）2. V 是每个页面中的 HTML 结构。 （DOM 元素）3. VM 是一个调度者，分割了 M 和 V，V 和 M 的通信即是通过 VM。（new 出来的 app实例对象 就是 VM 调度者）注：VM 提供了数据的双向绑定 M V C :MVC 其实是后端的 模块化分层/分发开发 的概念。 123451. M Model 层，负责操作数据库，执行对应的 SQL 语句，进行数据的 CRUD。2. C Controller 层，router.js 路由模块分发，业务逻辑处理，若涉及数据，调用 Model 层。3. V 通过入口文件的调度整合，整个形成的结果就是 View 视图层。注：模块化，是一种思想，使得各个模块职能单一，易于维护。参考本博客 NODE.JS。 工具:涉及用到的工具。 Chrome 浏览器插件工具 Vue Devtools。 todoMVC 模板仓库 。（1）--depth=1 表示只下载最后一次的 commit,不要其历史记录，可以提高下载速度git clone https://github.com/tastejs/todomvc-app-template.git todomvc-vue --depth=1。（2）npm install 浏览器同步测试工具 browser-sync。（1）npm install --save-dev browser-sync （npm install --production）。（2）配置 package.json 中的 script。 1234"scripts":&#123; "dev": "browser-sync start --server --files \"*.html,css/*.css,js/*.js"", "start": "npm run dev"&#125; （3）启动开发服务 npm run start。 团队协作类工具 Worktile / teambition vscode 插件 Debugger for Chrome 本地调试 Bootstrap 4 Snippets bootstrap代码块提示 便捷指令 Ctrl + T 搜索文件标签 Alt + 鼠标点击 选中列 VUE 提示工具 Vetur Vue 2 Snippets element-ui 进行手机 App 开发，需借助 Weex。 nrm工具 nrm维护了一些常用的 npm包镜像 npm i nrm -g，nrm ls，nrm use taobao webpack 见 webpack 文档]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美好事物]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%BE%8E%E5%A5%BD%E4%BA%8B%E7%89%A9%2F</url>
    <content type="text"><![CDATA[我望向幽谷，惶恐又欣喜。我试着想象，那里暗藏着的，是一枝花，一团火，还是一颗坠落的星辰。我把经过修饰的想象扔向那里，回声中，溅起了些许涟漪。你问我那里究竟是些什么？可我终究是无法形容的，那些回忆中带着的情绪，那些不甘心的幸运。——王佚——————————————————————谢谢自己走过深渊，穿过黑暗也谢谢你在光亮处翘首以盼]]></content>
      <categories>
        <category>poem - 美好事物</category>
      </categories>
      <tags>
        <tag>美好事物</tag>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谱]]></title>
    <url>%2F2019%2F03%2F21%2F%E4%B9%90%E7%90%86%2F</url>
    <content type="text"><![CDATA[认识简谱 简谱 1 2 3 4 5 6 7 唱名 do re mi fa sol la si 音名 C D E F G A B 简谱并不是因为比五线谱简单，只是因为书写方便 （1）简谱如何记录音的高低 （2）简谱如何记录音的长短 “—“表示增时线 （3）简谱如何记录音的休止 ​ 在简谱中，记录音的休止的基本符号是 “0” 。有怎样的音符就对应相应的休止符 （4）如何打拍子 ​ 完整的一拍子由“前半拍” “后半拍” 组成。打拍子的时候由一上一下来完成——“V”。 （5）附点音符 和 附点休止符 ​ 有什么样的音符就有什么样的休止符，以音符为例： ​ 在音符的右下方附加一个黑点，叫做单附点音符。加两个黑点，叫复附点音符。复附点音符的作用：增加前面音符时值的一半。 （6）连音符号 同音连接弧线后面的音符不演奏 异音连接：弧线内的音要演奏的连贯 （7）切分音 和 切分节奏 （8）强弱拍 小节 小节线 终止线 ​ ●表示强拍 ○表示弱拍 ​ 两条小节线之间的部分，就叫小节。 ​ 一粗一细两条小节线记在乐曲的末尾，表示乐曲的结束。 （9）拍号 ​ 表示拍子的记号，叫做“拍号”。 ​ 拍号用分数形式来标记：分子表示节拍的每一循环，也就是一小节有几拍；分母表示以什么音符为一拍。如： ​ 常用拍号有 四四 四二 四三 八二 八三 八六 等等]]></content>
      <categories>
        <category>Guitar</category>
        <category>乐理</category>
        <category>简谱</category>
      </categories>
      <tags>
        <tag>music</tag>
        <tag>美好事物</tag>
        <tag>Guitar</tag>
      </tags>
  </entry>
</search>
