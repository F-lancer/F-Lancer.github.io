<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F09%2F07%2F%E8%BF%99%E6%98%AFnull%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vue 原理深度剖析（三）]]></title>
    <url>%2F2020%2F09%2F07%2FVue_3_vueSnabbdom%2F</url>
    <content type="text"><![CDATA[vue 原理深度剖析（三） 虚拟树在很多时候并不是最优操作方案，但是具有普适性，效率，可维护性之间达到了平衡。 如果你的应用交互复杂，需要进行大量的UI变化，使用虚拟树没毛病，否则不如直接操作DOM。 Virtual DOM 与 diff历史 利用 innerhtml 构建 虚拟DOM 全局渲染过于繁复。抛出问题，每次只更新修改部分，引入 VNode。 VNode 模拟真实 Dom，操作 JS对象，只对虚拟 Dom 的差异进行修改。 修改后，利用diff算法，算出需要修改的最小单位，将视图的最小单位进行更新。 diff 算法寻找前后（新旧）两棵虚拟 dom树 的不同处（便于有效的更新 DOM）时使用。 https://github.com/aooy/blog/issues/2 即，只进行同层级比较： 123456789101112131415161718&lt;!-- 之前 --&gt;&lt;div&gt; &lt;!-- 层级1 --&gt; &lt;p&gt; &lt;!-- 层级2 --&gt; &lt;b&gt; aoy &lt;/b&gt; &lt;!-- 层级3 --&gt; &lt;span&gt;diff&lt;/Span&gt; &lt;/P&gt; &lt;/div&gt;&lt;!-- 之后 --&gt;&lt;div&gt; &lt;!-- 层级1 --&gt; &lt;p&gt; &lt;!-- 层级2 --&gt; &lt;b&gt; aoy &lt;/b&gt; &lt;!-- 层级3 --&gt; &lt;/p&gt; &lt;span&gt;diff&lt;/Span&gt;&lt;/div&gt;&lt;!-- 层级2添加一个，层级3删除一个。 而不会跨级比较将 层级三移至层级二。--&gt; diff过程就是调用 patch函数的过程： 12345678function patch(oldVnode,vnode) &#123; if (sameVnode(oldVnode,vnode))&#123; // 判断是否值得判断，不值得直接由新的替换掉旧的。 // 判断节点是否一致，子节点是否一致等等。子节点不一样调用 updateChildren 函数。 patchVnode(oldVnode,vnode); &#125; else &#123; // 不值得判断，直接由新的替换掉旧的。 &#125;&#125; 传统diff通过循环递归对节点进行依次对比。 react diff 策略（了解） https://zhuanlan.zhihu.com/p/20346379 tree diff DOM树的 diff 策略 对于 DOM树仅进行同层比较，如果不存在，停止比较类似 sameVnode(oldVnode,vnode)。 当发生跨层级操作，直接删除后在另一个层级节点添加，即只进行删除添加操作。不会发生想像中的移动操作。 react 官方不建议进行 DOM节点跨层级 操作，影响性能。 component diff 组件的 diff 策略 同类组件，维持策略进行同层比较。 两个不同的组件，直接替换。 shouldComponentUpdate() 完全没有变化，利用此方法进行判断，将不进行 diff 运算。 vue 默认会追踪组件树的依赖关系，不会重新渲染。而react会全部进行渲染，但是也可以通过 shouldComponentUpdate() 这个生命周期进行控制。 element diff 插入移动删除 添加唯一 key 值，进行可以移动的操作，优化了性能。 尽量减少将最后一个节点移动到列表首部的操作，因为他移动的原则是将老树前边顺序不一致的移到后面。 VNode（Virtual DOM）个人理解：以 对象 的形式描述dom文档（对象）。 123456789101112131415161718192021&#123; tag: 'div' data: &#123; class: 'test' &#125;, children: [ &#123; tag: 'span', data: &#123; class: 'demo' &#125; text: 'hello,VNode' &#125; ]&#125;/* 等同于 hello,VNode*/ Virtual DOM 作用维护了视图和状态的关系，复杂视图的情况下提升了性能。除了渲染 DOM 以外，还可以实现 SSR（Nuxt.js/Nest.js）、原生应用（Weex/React Native）、小程序（mpvue/uni-app）等。 Virtual DOM 库 Snabbdom Vue2.x 内部使用的 Virtual DOM 就是改造的 Snabbdom。 代码精简体积小。 通过模块可扩展。 源码使用 TypeScript。 最快的 Virtual DOM 之一。 virtual-dom Snabbdom 精简，通过 Snabbdom 了解 Virtual DOM。打包工具为了方便使用 parcel。 Snabbdom 的基本使用 [https://github.com/snabbdom/snabbdom][https://github.com/coconilu/Blog/issues/152] 中文过时沿用 CommonJS 引入模块 老版本官方文档使用 CommonJS，推荐使用 ESM，（最新版本以使用 ESM）创建项目： 1234567npm initnpm i parcel-bundler --save-devnpm i snabbdomnpm i snabbdom@0.7.4 # 使用的老版本，新版本不稳定 配置 package.json 的 scripts： 1234"scripts": &#123; "dev": "parcel index.html --open", "build": "parcel build index.html"&#125; 项目结构： 12345src|————basicuage.jsindex.html # parcel 入口文件|package.json 导入：（使用的 ESM） 1import &#123; h, thunk, init &#125; from 'snabbdom' 简介Snabbdom 提供了三个核心函数，init()、h()、thunk()： init() 是一个高阶函数，返回 patch() 函数。 h() 返回一个虚拟节点 VNode，与 VUE 中 h 函数类似。 12345new Vue(&#123; router, store, render: h =&gt; h(APP)&#125;).$mount('#app') thunk() 是一种优化策略，可以在处理不可变数据时使用。 简单案例Test index.html： 12345&lt;div id="app"&gt;&lt;/div&gt;&lt;!-- &lt;script src="./src/01snabbdom.js"&gt;&lt;/script&gt; --&gt;&lt;script src="./src/02snabbdom.js"&gt;&lt;/script&gt; 案例一： 123456789101112131415161718192021222324import &#123; h, thunk, init &#125; from 'snabbdom'// init中传入的是模块，返回 patch 函数，// patch 函数 的作用就是对比两个 虚拟DOM （VNode），将两个VNode差异更新到 真实DOMlet patch = init([])// 第一个参数，标签+选择器// 第二个参数，如果是字符串，就是标签中的内容。let vNode = h('div#container.cls', 'string就是标签中的内容')// #app 根元素与vue中的 根元素#app 一样，用来占位，之后会被替换let app = document.querySelector('#app')// 第一个参数：可以是 Dom 元素，内部会把 Dom 元素转化为VNode// 第二个参数：VNode// 返回值：VNode// patch会转换并对比两个虚拟dom的区别，并将差异渲染到页面上。let oldVNode = patch(app, vNode) // 改变 老vNode 测试vNode = h('div', '局部改变') // 新建一个虚拟 dom patch(oldVNode, vNode) // 对比 改变 案例二： 123456789101112131415161718192021222324252627import &#123;h, init&#125; from 'snabbdom'let patch = init([])// 创建子元素，第二个参数是数组let vNode = h('div#container', [ h('h1', '我是第一个子元素'), h('p', '我是第二个子元素')])let app = document.querySelector('#app')let oldNode = patch(app, vNode)// 测试两秒后拿到新的dom元素渲染setTimeout(()=&gt;&#123; vNode = h('div#container', [ h('h1', '我是第一个子元素'), h('h2', '我是第二个子元素') ]) oldNode = patch(oldNode, vNode) // 清空页面上内容 // patch(oldNode, null) 官网上这样会报错 无法读取 null 的 key 属性 patch(oldNode, h('!')) // 创建注释节点替换老 vNode&#125;,2000) Snabbom 中的模块 Snabbom 的核心库并不能处理元素的属性、样式、事件等， 需要使用模块。 （官方提供了6个）常用模块： attributes 设置 DOM 元素的属性，使用 setAttribute()。 处理布尔类型的属性。 props 和 attributes 模块相似，设置 DOM 元素的属性 element[attr] = Value。 不处理布尔类型的属性。 class 切换类样式。 注意：给元素设置类样式是通过 sel 选择器。 dataset 设置HTML5中 data-* 的自定义属性。 eventlisteners 注册和移除事件。 style 设置行内样式，支持动画。内部注册了transition delayed/remove/destroy。 使用模块步骤：导入模块、init() 注册、使用 h() 函数创建 VNode 的时候，把第二个参数设置为对象，其它参数往后移。 1234567891011121314151617181920212223242526272829import &#123;h, init&#125; from 'snabbdom'import style from 'snabbdom/modules/style'import eventlisteners from 'snabbdom/modules/eventlisteners' // 导入let patch = init([ // 注册 style, eventlisteners])let styleNode = h('div',&#123; // 写数据，对象形式 style:&#123; backgroundColor: 'aqua' &#125;, on: &#123; click: eventHandler &#125;&#125;, [ h('h1', '我是第一个子元素'), h('p', '我是第二个子元素'),])function eventHandler () &#123; console.log('click event')&#125;let oldNode = document.querySelector('#app')patch(oldNode, styleNode) Snabbdom 的源码解析 核心解析方向 使用 h() 函数创建 JavaScript 对象（VNode）描述真实 DOM。init() 设置模块，创建 patch()。patch() 比较新旧两个 VNode。把变化的内容更新到 DOM 树上。 快捷键：F12 、Alt + 左方向键（回退上次位置）、选中+F12。 h()重载概念：在JS中没有重载的概念。 java 里重载，即可以定义函数名相同，参数不同的函数，当调用的时候可以自动根据传入的参数判断具体调用哪个函数。 而javascript是动态的语言，重名的函数会将前者覆盖。但传入的参数不受限制，往往在函数内部做判断，根据不同的参数返回不同类型的返回值。 typeScript 需要提供一个类型检查机制。它定义了一个重载的列表，但是函数执行的机制函数按照JS来执行的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 重载列表 将最精确（常用）的写在前面。function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;// 函数本体function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == "object") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == "number") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;h()` 源码：位置 `src/h.tsimport &#123;vnode, VNode, VNodeData&#125; from './vnode';export type VNodes = Array&lt;VNode&gt;;export type VNodeChildElement = VNode | string | number | undefined | null;export type ArrayOrElement&lt;T&gt; = T | T[];export type VNodeChildren = ArrayOrElement&lt;VNodeChildElement&gt;import * as is from './is';// 添加命名空间 ？function addNS(data: any, children: VNodes | undefined, sel: string | undefined): void &#123; data.ns = 'http://www.w3.org/2000/svg'; if (sel !== 'foreignObject' &amp;&amp; children !== undefined) &#123; for (let i = 0; i &lt; children.length; ++i) &#123; let childData = children[i].data; if (childData !== undefined) &#123; addNS(childData, (children[i] as VNode).children as VNodes, children[i].sel); &#125; &#125; &#125;&#125;// h() 函数的重载export function h(sel: string): VNode;export function h(sel: string, data: VNodeData): VNode;export function h(sel: string, children: VNodeChildren): VNode;export function h(sel: string, data: VNodeData, children: VNodeChildren): VNode;export function h(sel: any, b?: any, c?: any): VNode &#123; var data: VNodeData = &#123;&#125;, children: any, text: any, i: number; // 处理参数，实现重载的机制 if (c !== undefined) &#123; // c 根据使用 是指 VNodeChildren 子元素 // 如果c有值，这里处理的是传入三个参数的情况 data = b; //传三个参数 b指 VNodeData，元素属性 if (is.array(c)) &#123; children = c; &#125; // 如果 c 是数组 说明是子元素存入 children else if (is.primitive(c)) &#123; text = c; &#125; // 如果 c 是字符串或者数字 说明是文本 存入text else if (c &amp;&amp; c.sel) &#123; children = [c]; &#125; // 如果 c 有 sel 属性的时候（VNode），转换成数组放入 children &#125; else if (b !== undefined) &#123; // c 为 undefined，b 不为 undefined，说明传入了两个参数 // 判断两个参数的情况 与上类似 if (is.array(b)) &#123; children = b; &#125; else if (is.primitive(b)) &#123; text = b; &#125; else if (b &amp;&amp; b.sel) &#123; children = [b]; &#125; else &#123; data = b; &#125; &#125; // 子元素存入了 children，处理 children if (children !== undefined) &#123; for (i = 0; i &lt; children.length; ++i) &#123; // 如果 children 是字符串（string）或者数字（number） 说明是文本，创建文本节点，用 vnode() 创建。 if (is.primitive(children[i])) children[i] = vnode(undefined, undefined, undefined, children[i], undefined); &#125; &#125; // 如果传入的是 svg，要给 svg 添加命名空间，调用上面定义的 addNS() if ( sel[0] === 's' &amp;&amp; sel[1] === 'v' &amp;&amp; sel[2] === 'g' &amp;&amp; (sel.length === 3 || sel[3] === '.' || sel[3] === '#') ) &#123; addNS(data, children, sel); &#125; // 调用 vnode，创建 vnode 并返回 return vnode(sel, data, children, text, undefined);&#125;;// 导出模块export default h; vnode() 创建虚拟DOMinterface：接口：TS核心原则之一：对值所具有的结构进行类型检查。接口的作用：1. 为类型命名、2. 为代码和三方代码约定，及约定好数据类型。 vnode() 源码：位置 src/vnode.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 导入依赖import &#123;Hooks&#125; from './hooks';import &#123;AttachData&#125; from './helpers/attachto'import &#123;VNodeStyle&#125; from './modules/style'import &#123;On&#125; from './modules/eventlisteners'import &#123;Attrs&#125; from './modules/attributes'import &#123;Classes&#125; from './modules/class'import &#123;Props&#125; from './modules/props'import &#123;Dataset&#125; from './modules/dataset'import &#123;Hero&#125; from './modules/hero'export type Key = string | number;export interface VNode &#123; // vnode 接口 约束实现该接口的对象都拥有相同的属性 // 选择器 sel: string | undefined; // 节点数据：属性/样式/事件等 data: VNodeData | undefined; // 子节点，和 text节点 只能互斥 children: Array&lt;VNode | string&gt; | undefined; // 记录 vNode 对应的真实 DOM elm: Node | undefined; // 节点中的内容，和 Children 只能互斥 text: string | undefined; // 优化使用 key: Key | undefined;&#125;export interface VNodeData &#123; props?: Props; attrs?: Attrs; class?: Classes; style?: VNodeStyle; dataset?: Dataset; on?: On; hero?: Hero; attachData?: AttachData; hook?: Hooks; key?: Key; ns?: string; // for SVGs fn?: () =&gt; VNode; // for thunks args?: Array&lt;any&gt;; // for thunks [key: string]: any; // for any other 3rd party module&#125;// 创建 vnode 对象export function vnode( sel: string | undefined, data: any | undefined, children: Array&lt;VNode | string&gt; | undefined, text: string | undefined, elm: Element | Text | undefined): VNode &#123; // VNode 就是上面定义的接口，表示该函数的返回值所需要实现的规定（接口） let key = data === undefined ? undefined : data.key; // 当data有值时，key = data.key return &#123;sel, data, children, text, elm, key&#125;;&#125;export default vnode; // 导出 vnode snabbdom()diff 概念：同上 patch(oldVnode, newVnode)。 打补丁，把新节点中变化的内容渲染到真实DOM，最后返回新节点作为下次处理的旧节点。 对比新旧 VNode 是否相同节点（节点的 key和sel 相同）。 如果不是相同节点，删除之前的内容，重新渲染。 如果是相同的节点，再判断新的 VNode 是否有 text，如果有并且和oldVNode的text不同，直接更新文本内容。 如果新的 VNode 有 Children，判断子节点是否有变化，判断子节点的过程就是 diff 算法。 diff 算法只进行同层比较。 源码：位置：src/snabbdom.ts。核心为 init() 函数，及其中的 patch() 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* global module, document, Node *//* 导入依赖模块 *///.../* 辅助函数 *///.../* 常量 hooks 存储钩子函数的名字 */const hooks: (keyof Module)[] = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];/* 导出了 h 和 thunk */export &#123;h&#125; from './h';export &#123;thunk&#125; from './thunk';/* 定义了 init 函数，并导出 *//** * * * @export * @param &#123;Array&lt;Partial&lt;Module&gt;&gt;&#125; modules 模块数组，用来除了样式、属性、事件等等。 * @param &#123;DOMAPI&#125; [domApi] 执行dom操作，未赋值，在内部会赋 htmlDomApi，一些转换 虚拟 dom 的 API。 * @returns 返回了 patch() 函数，把vnode渲染成真实dom，并返回vnode。 * 使用高阶函数的优点： 形成闭包外部使用 patch() 可以直接使用 init 传入的这两个模块。 */export function init(modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI) &#123; let i: number, j: number, cbs = (&#123;&#125; as ModuleHooks); // 初始化转换虚拟节点的 api const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi; // 官方给的几个模块（./modules）都满足 module.ts 中规定的接口，即必须具有上面的钩子函数一个或几个。 // 把传入的所有模块的钩子函数，统一存储到 cbs 对象中 // 最终构建的 cbs 对象的形式 cbs =&#123; create: [fn1, fn2], update: [], ... &#125; for (i = 0; i &lt; hooks.length; ++i) &#123; // 遍历钩子 cbs[hooks[i]] = []; // 钩子作为cbs的key，初始化为数组 for (j = 0; j &lt; modules.length; ++j) &#123; // 遍历模块 const hook = modules[j][hooks[i]]; if (hook !== undefined) &#123; (cbs[hooks[i]] as Array&lt;any&gt;).push(hook); // 将模块一次放入 刚刚初始化的数组 &#125; &#125; &#125; /* 内部辅助函数 */ // ... return function patch()&#123;&#125;&#125; 没有使用 export default 导出，导入要用 import {} from &#39;./../&#39; patch()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * 在 init() 内部返回了 patch() 函数，把vnode渲染成真实dom，并返回vnode。 * * @param &#123;(VNode | Element)&#125; oldVnode * @param &#123;VNode&#125; vnode * @returns &#123;VNode&#125; */return function patch(oldVnode: VNode | Element, vnode: VNode): VNode &#123; let i: number, elm: Node, parent: Node; // 保存新插入节点的队列，为了触发钩子函数 const insertedVnodeQueue: VNodeQueue = []; // 执行模块的 pre 钩子函数 pre 就是预处理的钩子 for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i](); // 判断是不是虚拟节点（判断是否有 sel 属性） if (!isVnode(oldVnode)) &#123; oldVnode = emptyNodeAt(oldVnode); // 如果是真实dom，创建vnode，即将dom元素转换为空虚拟dom &#125; // 根据key（节点唯一值）、sel（节点选择器）判断两个节点是否是相同节点 if (sameVnode(oldVnode, vnode)) &#123; // 是相同节点，找差异更新到节点上 patchVnode(oldVnode, vnode, insertedVnodeQueue); &#125; else &#123; // 如果不一样，新节点 vnode 创建对应的 DOM elm = oldVnode.elm as Node; // 获取老节点元素 parent = api.parentNode(elm); // 获取老节点父结点 createElm(vnode, insertedVnodeQueue); // 给新节点创建vnode并触发 init/create 钩子函数。 // 父结点不为空 if (parent !== null) &#123; // 新节点vnode对应的dom插入到文档中 api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm)); // 移除老节点 removeVnodes(parent, [oldVnode], 0, 0); &#125; &#125; // 执行用户设置的 insert 钩子函数 for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123; //遍历新插入的节点 (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]); &#125; // 执行模块的 post 钩子函数 for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i](); // 返回 vnode return vnode;&#125;; ! ts语法是指该处是 100% 有值的。 createElm()：把vNode转换为dom元素，此处并未渲染到页面上。insertBefore() 才插入到文档上去。 createElm()createElm() 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node &#123; // vnode.data h()函数传入的一个参数对象形式，里面是标签样式属性类等 let i: any, data = vnode.data; if (data !== undefined) &#123; // 执行用户设置的 init() 钩子函数 if (isDef(i = data.hook) &amp;&amp; isDef(i = i.init)) &#123; // isDef() 判断函数是否已定义 i(vnode); // data.hook.init(vnode) data = vnode.data; // 重新赋值是由于，用户可能在init里重新修改data值 &#125; &#125; // 把 vnode 转换成真实 DOM 对象（并未渲染到页面上） let children = vnode.children, sel = vnode.sel; if (sel === '!') &#123; // 如果选择器是感叹号，会创建注释节点。 if (isUndef(vnode.text)) &#123; vnode.text = ''; &#125; // 调用 document.createComment(text) 创造空注释节点 vnode.elm = api.createComment(vnode.text as string); &#125; else if (sel !== undefined) &#123; // sel 不为空，创建对应的 DOM 元素 // Parse selector 如果选择器不为空 解析选择器 // 找到'#''.'的位置，解析出标签名 const hashIdx = sel.indexOf('#'); const dotIdx = sel.indexOf('.', hashIdx); const hash = hashIdx &gt; 0 ? hashIdx : sel.length; const dot = dotIdx &gt; 0 ? dotIdx : sel.length; const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel; // isDef(data.ns) data是否有命名空间（？）createElementNS创建带有命名空间的元素，一般为SVG， // 否则创建一般元素 const elm = vnode.elm = isDef(data) &amp;&amp; isDef(i = (data as VNodeData).ns) ? api.createElementNS(i, tag): api.createElement(tag); // 如果有id class，设置 id class 属性 if (hash &lt; dot) elm.setAttribute('id', sel.slice(hash + 1, dot)); if (dotIdx &gt; 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' ')); // 执行模块的 create 钩子函数 for (i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode); // 如果 vnode 中有子节点，创建vnode对应的DOM元素并追加到DOM树上 if (is.array(children)) &#123; for (i = 0; i &lt; children.length; ++i) &#123; const ch = children[i]; if (ch != null) &#123; api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue)); // 递归调用 createElm() &#125; &#125; &#125; else if (is.primitive(vnode.text)) &#123; // 如果是文本节点，创建并追加到DOM树上 api.appendChild(elm, api.createTextNode(vnode.text)); &#125; i = (vnode.data as VNodeData).hook; // Reuse variable 重用变量 i if (isDef(i)) &#123; // 如果用户传入了钩子函数 if (i.create) i.create(emptyNode, vnode); // 有create调用create 创造空节点 // 有insert调用insert 将当前节点追加到队列里，patch()函数有使用到该队列 if (i.insert) insertedVnodeQueue.push(vnode); &#125; &#125; else &#123; // sel 为空，说明是文本节点，创建文本节点 vnode.elm = api.createTextNode(vnode.text as string); &#125; // 创建的新 DOM 存在 vnode.elm 属性里并返回 return vnode.elm;&#125; 理解使用用户定义的钩子函数，test： 1234567891011// h函数的第二个参数可以定义钩子函数let vnode = h('div#container.cls', &#123; hook: &#123; init(vnode)&#123; console.log(vnode.elm) &#125;, create(vnode)&#123; console.log(vnode.elm) &#125; &#125;&#125;, '使用用户定义的钩子函数') patchVnode()对比新旧两个节点，更新它们的差异： 调用钩子函数 prepatch 钩子函数。 触发 update 钩子函数。 对比： 新节点有 text 属性，且不等于旧节点的 text 属性。 如果节点有 children，移除老节点 children 对应的DOM元素 设置新节点对应DOM元素的 textContent 新老节点都有children，且不相等 调用 updateChildren() 对比子节点，并更新差异 只有新节点有children属性 如果老节点有text属性 清空对应DOM元素的textContent 添加所有的子节点 只有老节点有children属性 移除所有老节点。 只有来节点有 text 属性 移除所有的老节点 触发 postpatch 钩子函数。 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /** *对比两节点的差异，并跟新真实dom * * @param &#123;VNode&#125; oldVnode * @param &#123;VNode&#125; vnode * @param &#123;VNodeQueue&#125; insertedVnodeQueue * @returns */function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123; let i: any, hook: any; // 首先执行用户设置的 prepatch 钩子函数 if (isDef(i = vnode.data) &amp;&amp; isDef(hook = i.hook) &amp;&amp; isDef(i = hook.prepatch)) &#123; i(oldVnode, vnode); &#125; const elm = vnode.elm = (oldVnode.elm as Node); let oldCh = oldVnode.children; let ch = vnode.children; // 如果新老 vnode 相同返回 if (oldVnode === vnode) return; if (vnode.data !== undefined) &#123; // 执行模块的 update 钩子函数 for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode); i = vnode.data.hook; // 执行用户设置的 update 钩子函数 if (isDef(i) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode); &#125; // 如果 vnode.text 未定义 if (isUndef(vnode.text)) &#123; // 新老节点都有孩子 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 使用 diff 算法对比子节点更新子节点 if (oldCh !== ch) updateChildren(elm, oldCh as Array&lt;VNode&gt;, ch as Array&lt;VNode&gt;, insertedVnodeQueue); &#125; else if (isDef(ch)) &#123; // 如果新节点有 children，老节点没有 children // 如果老节点有 text，清空 dom 元素的内容 if (isDef(oldVnode.text)) api.setTextContent(elm, ''); // 批量添加子节点 addVnodes(elm, null, ch as Array&lt;VNode&gt;, 0, (ch as Array&lt;VNode&gt;).length - 1, insertedVnodeQueue); &#125; else if (isDef(oldCh)) &#123; // 批量移除老节点 removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; else if (isDef(oldVnode.text)) &#123; // 老节点有 text ，清空 DOM 元素 api.setTextContent(elm, ''); &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; // 如果没有设置 vnode.text if (isDef(oldCh)) &#123; // 老节点有 children 移除 removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; // 设置 DOM 元素的 textContent 为 vnode.text api.setTextContent(elm, vnode.text as string); &#125; // 最后执行用户设置的 postpatch 钩子函数 if (isDef(hook) &amp;&amp; isDef(i = hook.postpatch)) &#123; i(oldVnode, vnode); &#125;&#125; updateChildren()updateChildren()：对比新老节点的子节点，并更新子节点（是 diff 算法的核心） 执行过程： 要对比两棵树的差异，一个节点对应整棵树比较的事件复杂度为 O(n^3)。 由于在Dom操作的时候很少会把父节点移动更新到子节点。 采用同层比较，即一层对应一层比较，时间复杂度是 O(n)。 在进行同层比较的时候会首先对新老节点数组的开始和结尾节点设置索引标记，遍历的过程中移动索引。 在对开始结束的节点进行比较的时候，总共有四种情况： oldStartVnode / newStartVnode（旧开始节点/新开始节点） oldEndVnode / newEndVnode（旧结束节点/新结束节点） oldStartVnode / newEndVnode（旧开始节点/新结束节点） oldEndVnode / newStartVnode（旧结束节点/新开始节点） 如果四种情况都不满足，采用唯一 key 值比较。 结束时的情况也分为两种： 老节点数组结束，新节点数组未结束，说明新增了节点，将新增节点补充到老节点。 老节点数组未结束，新节点数组结束，说明删除了节点，将节点删除 源码：源码位置（src/snabbdom.ts） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 对比新老节点的子节点，并更新子节点 * * @param &#123;Node&#125; parentElm 父元素 * @param &#123;Array&lt;VNode&gt;&#125; oldCh 老节点 * @param &#123;Array&lt;VNode&gt;&#125; newCh 新节点 * @param &#123;VNodeQueue&#125; insertedVnodeQueue 节点队列 */function updateChildren(parentElm: Node, oldCh: Array&lt;VNode&gt;, newCh: Array&lt;VNode&gt;, insertedVnodeQueue: VNodeQueue) &#123; let oldStartIdx = 0, newStartIdx = 0; // 新老开始索引 let oldEndIdx = oldCh.length - 1; // 老结束 let oldStartVnode = oldCh[0]; // 根据索引老开始节点 let oldEndVnode = oldCh[oldEndIdx]; // 老结束节点 let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx: any; let idxInOld: number; let elmToMove: VNode; let before: any; // 同层比较 结束条件，新老索引有一个结束则结束 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 节为空移动索引 if (oldStartVnode == null) &#123; oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left &#125; else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx]; &#125; else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx]; // 四种对比情况 patchVnode()调用对比差异更新dom &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue); api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; // 开始结束节点四种情况都不满足，采用 key 值对比 if (oldKeyToIdx === undefined) &#123; // oldKeyToIdx 未定义就赋值 // 将老节点的 key 作为属性，所谓作为属性的值 oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; // 在老节点中找相同的key值 idxInOld = oldKeyToIdx[newStartVnode.key as string]; if (isUndef(idxInOld)) &#123; // New element 没找到为新元素 api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); // 移动指针指向新的下一个节点 newStartVnode = newCh[++newStartIdx]; &#125; else &#123; // 找到了，存储到 elmToMove elmToMove = oldCh[idxInOld]; if (elmToMove.sel !== newStartVnode.sel) &#123; // 根据sel判断两个节点是否被修改过，不同表示修改过，创建新DOM,插入到老的开始节点之前 api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); &#125; else &#123; // 相同节点，对比两节点的差异 patchVnode(elmToMove, newStartVnode, insertedVnodeQueue); oldCh[idxInOld] = undefined as any; api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node); &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; &#125; // 循环结束的两种情况的代码 有一个数组未遍历完，处理剩余元素 if (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx+1] == null ? null : newCh[newEndIdx+1].elm; // 把剩余新节点插到老节点后面 addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); &#125; else &#123; // 删除多余老节点 removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125; &#125;&#125; 模块源码 核心源码执行过程：patch() ——&gt; patchVnode() ——&gt; updateChildren()。snabbdom 为了代码精简，将处理的元素的属性/事件/样式等工作，放到了模块中。模块可以按需引入。 模块的核心是基于Hooks： 源码：位置 src/hooks.ts vue/react 区别先略 组件树的渲染策略。 vue 可以直接在单文件中写 css/html。react 是使用JSX。（vue也可以使用render函数和JSX） react props 单一数据源???。 vue：vue-router/vueX 团队维护。react：react-router/react-redux 社区成员维护。 React Native，手机上创建原生应用听说很nice，vue的 weex 听说高开低走不行，vue3.0也要出来了，so… 参考 vue-vs-react：[https://deliciousbrains.com/vue-vs-react-battle-javascript/] vue-vs-react：[http://caibaojian.com/vue-vs-react.html] 虚拟dom与diff实现：[https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM%E4%B8%8Ediff(Vue%E5%AE%9E%E7%8E%B0).MarkDown] VNode：[https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown] 回流重绘虚拟DOM：[https://blog.usejournal.com/what-the-heck-is-repaint-and-reflow-in-the-browser-b2d0fb980c08?gi=8bc0f4c14faa] [https://github.com/aooy/blog/issues/2] [https://zhuanlan.zhihu.com/p/20346379] [https://github.com/Matt-Esch/virtual-dom] vscode：[https://segmentfault.com/a/1190000012047237]]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>vueVNode</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>vnode/diff</tag>
        <tag>Snabbdom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 原理深度剖析（二）]]></title>
    <url>%2F2020%2F09%2F01%2FVue_2_vueReact%2F</url>
    <content type="text"><![CDATA[vue 响应式原理… 响应式原理数据驱动 数据驱动、双向绑定、数据响应式 数据响应式：数据模型仅仅是普通的 JS 对象，当修改数据时，视图会进行更新，避免操作 DOM，提高开发效率。 双向绑定：数据改变，视图改变；视图改变，数据随之改变。可以使用 v-model 在表单元素上创建双向数据绑定。 数据驱动：使得开发者，仅需关注数据本身，不需要关心数据是如何渲染到视图。 响应式核心原理Vue2.x深入响应式原理 官网defineProperty ES5新增的，兼容 IE8 以上。 [https://cn.vuejs.org/images/data.png] defineProperty(): 12345678910111213141516171819202122232425262728293031323334353637&lt;h1 class="h1"&gt; hello&lt;/h1&gt;&lt;script&gt; let data = &#123; msg: 'hello' &#125; // 模拟 Vue 实例 let vm = &#123;&#125; // 数据劫持 当访问或者设置 vm 中的成员的时候，做一些干预操作 Object.defineProperty(vm, 'msg', &#123; enumerable: true, // 可枚举（可遍历） configurable: true, // 可配置（可以使用 delete 删除，可以通过 defineProperty 重新定义） get: () =&gt; &#123; console.log('get:',data.msg) return data.msg &#125;, set: (newVal) =&gt; &#123; console.log('set:',data.msg) if (newVal === data.msg)&#123; return &#125; data.msg = newVal document.getElementsByClassName('h1')[0].textContent = data.msg &#125; &#125;) // vm.msg = 'Hello World' console.log(vm.msg)&lt;/script&gt; 多值时需要遍历： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;h1 class="h1"&gt; hello&lt;/h1&gt;&lt;script&gt;let data = &#123; msg: 'hello', tip: 'hello world'&#125;// 模拟 Vue 实例let vm = &#123;&#125;proxyData(data)function proxyData(data) &#123; // 遍历 data 中的所有属性 Object.keys(data).forEach(key =&gt; &#123; // 把 data 中的属性，转换为 vm 中的 getter/setter // 数据劫持 当访问或者设置 vm 中的成员的时候，做一些干预操作 Object.defineProperty(vm, 'msg', &#123; enumerable: true, // 可枚举（可遍历） configurable: true, // 可配置（可以使用 delete 删除，可以通过 defineProperty 重新定义） get: () =&gt; &#123; console.log('get:',data.msg) return data.msg &#125;, set: (newVal) =&gt; &#123; console.log('set:',data.msg) if (newVal === data.msg)&#123; return &#125; data.msg = newVal document.getElementsByClassName('h1')[0].textContent = data.msg &#125; &#125;) &#125;)&#125;// vm.msg = 'Hello World'console.log(vm.msg)&lt;/script&gt; Vue3.xproxy它直接监听对象，而非属性。ES6 中新增的，不兼容 IE，性能由浏览器优化。 123456789101112131415161718192021222324&lt;h1 class="h1"&gt; hello&lt;/h1&gt;&lt;script&gt;let data = &#123; msg: 'hello', tip: 'hello world'&#125;// 创建代理对象 vm，获取 msg 属性可以通过 代理属性 vm 获取var vmp = new Proxy(data, &#123; // 第一个属性被代理的对象，第二个参数是一个包含了代理行为的对象 get (target, key)&#123; // target 被代理对象，key 要访问对象属性 return target[key] &#125;, set (target, key, newValue) &#123; if(target[key] === newValue) &#123; return &#125; target[key] = newValue document.getElementsByClassName('h2')[0].textContent = target[key] // 可直接访问多个属性 &#125;&#125;)&lt;/script&gt; 发布/订阅模式发布订阅模式：订阅者、发布者、信号中心。 当某个任务执行完成，就像信号中心“发布”（publish）一个信号，其它任务可以向信号中心“订阅”（subscribe）这个信号，从而知道自己什么时候可以开始执行，这就叫“发布订阅模式”（publish-subscribe pattern）。 Vue 的自定义事件，以及 node 中的事件机制，都是基于发布/订阅模式的。 12345678910111213&lt;script&gt; let vm = new Vue() vm.$on(&apos;dataChange&apos;, () =&gt; &#123; console.log(&apos;dataChange&apos;) &#125;) vm.$on(&apos;dataChange&apos;, () =&gt; &#123; // 触发后的监听 console.log(&apos;dataChange1&apos;) &#125;) vm.$emit(&apos;dataChange&apos;) // 触发&lt;/script&gt; 兄弟组件通信过程： 1234567891011121314151617181920&lt;script&gt; // eventBus.js // 事件中心 let eventHub = new Vue() // ComponentA.vue // 发布者 addTodo: function() &#123; // 发布消息事件 eventHub.$emit(&apos;add-todo&apos;, &#123; text: this.newTodoText &#125;) this.newTodoText = &apos;&apos; &#125; // ComponentB.vue // 订阅者 created: function() &#123; // 订阅者事件 eventHub.$on(&apos;add-todo&apos;, this.addTodo) &#125;&lt;/script&gt; 模拟自定义事件的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;script&gt; let vm = new Vue() // 注册事件（订阅消息） vm.$on(&apos;dataChange&apos;, () =&gt; &#123; console.log(&apos;dataChange&apos;) &#125;) // 触发事件（发布消息） vm.$on(&apos;dataChange&apos;, () =&gt; &#123; // 触发后的监听 console.log(&apos;dataChange1&apos;) &#125;) vm.$emit(&apos;dataChange&apos;) // 触发 // $on: &#123; &apos;click&apos;: [fn1, fn2, fn3], &apos;change&apos;: [fn] &#125; // $emit : 根据属性名称找到对应的函数之后依次执行&lt;/script&gt;&lt;script&gt; // 事件触发器 class EventEmitter &#123; constructor () &#123; // &#123; &apos;click&apos;: [fn1, fn2, fn3], &apos;change&apos;: [fn] &#125; this.subs = Object.create(null) // &#123;&#125;, null 表示不需要原型，提高性能 &#125; // 注册事件 $on(eventType, handler) &#123; this.subs[eventType] = this.subs[eventType] || [] this.subs[eventType].push(handler) &#125; // 触发事件 $emit(eventType) &#123; if (this.subs[eventType]) &#123; this.subs[eventType].forEach(handler=&gt;&#123; handler() &#125;) &#125; &#125; &#125; let em = new EventEmitter() em.$on(&apos;click&apos;, () =&gt; &#123; console.log(&apos;click1&apos;) &#125;) em.$on(&apos;click&apos;, () =&gt; &#123; console.log(&apos;click2&apos;) &#125;) em.$emit(&apos;click&apos;)&lt;/script&gt; 观察者模式观察者（订阅者）：Watcher update(): 当事件发生时，具体要做的事情。 目标（发布者）：Dep subs 数组：存储所有的观察者。 addSub()：添加观察者。 notify()：当事件发生，调用所有观察者的 update() 方法。 没有事件中心 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; // 发布者 —— 目标 class Dep &#123; constructor () &#123; // 记录所有的订阅者 this.subs = [] &#125; addSub (sub) &#123; // 用来添加观察者 if (sub &amp;&amp; sub.update) &#123; // sub 订阅者存在，并且订阅者有 update 方法 this.subs.push(sub) &#125; &#125; notify () &#123; // 当事件发生，调用所有观察者的 update() 方法。 this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125; &#125; // 订阅者 —— 观察者 class Watcher &#123; update () &#123; console.log(&apos;Watcher update&apos;) &#125; &#125; // 测试 let dep = new Dep() let watcher = new Watcher() dep.addSub(watcher) dep.notify()&lt;/script&gt; 观察者模式、发布订阅者模式的区别： 观察者模式：是由具体目标调度，比如当前事件触发，Dep 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。 发布订阅者模式：由统一调度中心调度，因此发布者和订阅者不需要知道对方的存在。 VUE 响应式原理模拟 所要模拟的项 Vue、Compiler（解析指令）、Observer（数据劫持）、Watcher（观察者）、Dep（发布者）。 打印Vue实例可以看出，构造函数内部会把data中的数据转换为 getter/setter 注入到Vue实例上。这样在其他地方使用的时候就可以用使用 this 来调用了。 $data 中记录了data并转换为了 getter/setter，它是真正监听数据变化的地方。 $options 中记录了构造函数的参数。 _data 和 $data 指向的是同一个对象。_data私有成员，$data公共成员。 $el 对应选项中的 el。注意 el选项可以是选择器，也可以说是DOM对象。 测试代码：test.html： 12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;h1&gt;差值表达式&lt;/h1&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123; count &#125;&#125;&lt;/h3&gt; &lt;h1&gt;v-text&lt;/h1&gt; &lt;div v-text="msg"&gt;&lt;/div&gt; &lt;h1&gt;v-model&lt;/h1&gt; &lt;input type="text" v-model="msg"&gt; &lt;input type="text" v-model="count"&gt;&lt;/div&gt;&lt;script src="./js/dep.js"&gt;&lt;/script&gt;&lt;script src="./js/watcher.js"&gt;&lt;/script&gt;&lt;script src="./js/compiler.js"&gt;&lt;/script&gt;&lt;script src="./js/observer.js"&gt;&lt;/script&gt;&lt;script src="./js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; msg: '你好', count: 100, person: &#123; name: 'zs' &#125; &#125; &#125;) console.log(vm)&lt;/script&gt; 模拟Vue实现功能： 负责接收初始化的参数（选项）。 负责把 data 中的属性注入到 Vue 实例，转换为 getter/setter。 负责调用 observer 监听 data 中所有属性的变化。 负责调用 compiler 解析指令、差值表达式。 结构：Vue: $option / $el / $data 和 _proxyData()。 代码： vue.js： 1234567891011121314151617181920212223242526272829303132333435363738394041class Vue &#123; constructor(options) &#123; // 1. 通过属性保存选项的数据。 // 2. 把 data 中的成员转换成 getter/setter。 this.$options = options || &#123;&#125; this.$data = options.data || &#123;&#125; this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el this._proxyData(this.$data) // 3. 调用 observer 对象，监听数据的变化。 new Observer(this.$data) // 4. 调用 compiler 对象，解析指令和差值表达式。 debugger new Compiler(this) &#125; _proxyData (data) &#123; // 遍历 data 对象，调用 Object.defineProperty 将data中的属性其注入到实例 this 中（方便调用） Object.keys(data).forEach(key =&gt; &#123; // 箭头函数未改变 this 指向实例，如果是 function 指向 window Object.defineProperty(this, key, &#123; enumerable: true, configurable: true, get () &#123; return data[key] &#125;, set (newValue) &#123; if(newValue === data[key])&#123; return &#125; data[key] = newValue &#125; &#125;) &#125;) &#125;&#125; 模拟 Observer实现功能： 负责把 data 选项中的属性转换成响应式数据。 data 中的某个属性也是对象，把该属性转换成响应式数据。 数据变化发生通知。 结构：Observer：walk(data)（遍历 data 属性）、defineReactive(data, key, value)（转换为 getter/setter 定义响应式数据）。 代码： Observer.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Observer &#123; constructor(data)&#123; this.walk(data) &#125; walk (data) &#123; // 1. 判断 data 是否为对象，增强代码健壮性 if( !data || typeof data !== 'object' ) &#123; // null 非对象直接返回 return &#125; // 2. 遍历 data 对象的所有属性，将其转换为 getter、setter Object.keys(data).forEach(key =&gt; &#123; this.defineReactive(data, key, data[key]) &#125;) &#125; /** * 定义响应式数据 * * @param &#123;*&#125; obj data 对象 * @param &#123;*&#125; key 属性 * @param &#123;*&#125; val 属性对应的值 * @memberof Observer */ defineReactive (obj, key, val) &#123; let that = this // set 内部调用 walk 使用 let dep = new Dep() // 负责收集依赖，将来 // 如果 val 是对象，递归调用，将 val 内部的属性也准换为响应式数据。 this.walk(val) // 调用 this.walk，walk内部有判断，只有在 val 是对象时生效。 Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get () &#123; Dep.target &amp;&amp; dep.addSub(Dep.target) // 收集依赖，将来数据变化时发送通知 // 这里不能使用 obj[key]，当 vm.val 调用时会发生死递归 return val // val 可以 是因为外部data对get有引用，在此处产生了 Closure 闭包， // 使val可以延续作用域 &#125;, set (newVal) &#123; if (newVal === val) &#123; return &#125; val = newVal that.walk(newVal) // 确保修改后为对象的内部属性数据也是响应式的。 // 发送通知 dep.notify() &#125; &#125;) &#125;&#125; 注意： 要确保数据中的对象的属性也是响应式的。 在将普通数据改变为对象时也确保内部属性是响应式数据。 都是利用递归调用解决的。 模拟 Compiler实现功能：（操作DOM） 编译模板，解析指令、差值表达式。 负责页面的首次渲染。 当数据变化后重新渲染视图。 结构：Compiler: el（DOM） / vm（实例）、compile(el) / compilerElement(node) / compileText(node)（dom操作） 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164class Compiler &#123; constructor(vm)&#123; this.el = vm.$el this.vm = vm debugger this.compile(this.el) // 创建 Compile 立即调用 compile 函数 &#125; /** *编译模板处理文本节点 和 元素节点 * * @param &#123;*&#125; el * @memberof Compiler */ compile (el) &#123; debugger // el就是 id="app" 的这个div，我们要遍历其中所有的节点（不是元素） // childNodes（不是 children 子元素） let childNodes = el.childNodes // 伪数组 拿到的只是第一层子结点 Array.from(childNodes).forEach(node =&gt; &#123; if (this.isTextNode(node)) &#123; debugger // 如果是文本节点 this.compileText(node) &#125; else if (this.isElementNode(node)) &#123; // 处理元素节点 this.compileElement(node) &#125; // 判断 node节点 是否有子节点，如果有递归调用 compile if (node.childNodes &amp;&amp; node.childNodes.length) &#123; this.compile(node) &#125; &#125;) &#125; /** *编译元素节点，处理指令 * 1.遍历所有的属性节点 * 2.判断是否有指令 * @param &#123;*&#125; node 要处理的元素 * @memberof Compiler */ compileElement (node) &#123; // 1.遍历所有的属性节点 Array.from(node.attributes).forEach((attr) =&gt;&#123; let attrName = attr.name if (this.isDirective(attrName)) &#123; attrName = attrName.substring(2) // 去掉 v- 方便之后封装指令方法调用 update() let key = attr.value this.update(node, key, attrName) &#125; &#125;) console.dir(node.attributes) &#125; /** *封装调用指令方法的名字 * * @param &#123;*&#125; node * @param &#123;*&#125; key * @param &#123;*&#125; attrName * @memberof Compiler */ update (node, key, attrName) &#123; let updateFn = this[attrName + 'Updater'] // this.~Updater // updateFn &amp;&amp; updateFn(node, this.vm[key], key) updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key) // 改变 this 指向 Compiler，使watcher可以调用 this.vm &#125; /** *处理 v-text 指令 * * @param &#123;*&#125; node 元素 * @param &#123;*&#125; value 值 * @param &#123;*&#125; key 属性名key * @memberof Compiler */ textUpdater (node, value, key) &#123; node.textContent = value new Watcher(this.vm, key, (newValue) =&gt; &#123; node.textContent = newValue &#125;) &#125; /** *处理 v-model 指令 * * @param &#123;*&#125; node 元素 * @param &#123;*&#125; value 值 * @param &#123;*&#125; key 属性名key * @memberof Compiler */ modelUpdater (node, value, key) &#123; node.value = value // 表单属性获取值用 node.value new Watcher(this.vm, key, (newValue) =&gt; &#123; node.value = newValue &#125;) // 给表单元素绑定 input 事件，解决双向绑定问题。 node.addEventListener('input', () =&gt; &#123; this.vm[key] = node.value &#125;) &#125; /** *编译文本，处理差值表达式 * * @param &#123;*&#125; node * @memberof Compiler */ compileText (node) &#123; // 使用正则 &#123;&#123; msg &#125;&#125; let reg = /\&#123;\&#123;(.+?)\&#125;\&#125;/ // .+ 匹配任意多的字符，? 表示非贪婪模式，尽可能早的结束匹配 let value = node.textContent if (reg.test(value)) &#123; let key = RegExp.$1.trim() // 获取到第一个分组的内容（空格内部内容） 并去除空格 node.textContent = value.replace(reg, this.vm[key]) // 创建 Watcher 对象，当数据改变更新视图 new Watcher(this.vm, key, (newValue) =&gt; &#123; node.textContent = newValue &#125;) &#125; &#125; /** *判断元素属性是否是指令 * * @param &#123;*&#125; attrName 属性名字 * @memberof Compiler */ isDirective (attrName) &#123; return attrName.startsWith('v-') &#125; /** *判断节点是否是文本节点 * * @param &#123;*&#125; node * @memberof Compiler */ isTextNode (node) &#123; debugger // 节点有个属性为 nodeType , 3为文本节点，1为元素节点，nodeValue 为节点的值 return node.nodeType === 3 &#125; /** *判断节点是否是元素节点 * * @param &#123;*&#125; node 元素 * @memberof Compiler */ isElementNode (node) &#123; // 节点有个属性为 nodeType , 3为文本节点，1为元素节点，nodeValue 为节点的值 return node.nodeType === 1 &#125;&#125; 模拟发布者 Dep实现功能： 收集依赖，添加观察者（watcher）。 通知所有观察者。 结构：Dep：subs、addSub()/notify() 代码： 1234567891011121314151617181920212223242526272829class Dep &#123; constructor () &#123; // 存储所有的观察者 this.subs = [] &#125; /** *添加观察者 * * @param &#123;*&#125; sub * @memberof Dep */ addSub (sub) &#123; if (sub &amp;&amp; sub.update) &#123; // 默认观察者都有一个 update 方法，判断是否是观察者 this.subs.push(sub) &#125; &#125; /** *发送通知 * * @memberof Dep */ notify () &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125; 模拟 Watcher 类实现功能： 当数据变化触发依赖 dep，dep 通知所有的 Watcher 实例更新视图。 自身实例化的时候往 dep 对象中添加自己。 结构：Dep：vm / key / cb / oldValue、update() 代码： 123456789101112131415161718192021222324252627class Watcher &#123; constructor (vm, key, cb) &#123; this.vm = vm this.key = key // data 中的属性名称 this.cb = cb // 回调函数负责更新视图 // 把watcher对象记录到 Dep 类的静态属性 target 中 Dep.target = this // 触发 get 方法，在 get 方法中会调用 addSub this.oldValue = vm[key] // 访问就会触发 get Dep.target = null &#125; /** *当数据发生变化时更新视图 * * @memberof Watcher */ update () &#123; // 在调用 update 时，数据已经发生了变化，先获取新值 let newValue = this.vm[this.key] if (newValue === this.oldValue) &#123; return &#125; this.cb(newValue) &#125;&#125; 解决双向绑定问题解决视图变化，数据跟着变化：给表单元素绑定 input 事件。 12345678910111213141516171819/** *处理 v-model 指令 * * @param &#123;*&#125; node 元素 * @param &#123;*&#125; value 值 * @param &#123;*&#125; key 属性名key * @memberof Compiler */modelUpdater (node, value, key) &#123; node.value = value // 表单属性获取值用 node.value new Watcher(this.vm, key, (newValue) =&gt; &#123; node.value = newValue &#125;) // 给表单元素绑定 input 事件，解决双向绑定问题。 node.addEventListener('input', () =&gt; &#123; this.vm[key] = node.value &#125;)&#125; 注意 将 data 中的属性重新赋值成对象，是响应式的。 通过 vm.b = &#39;b&#39; 新添加一个属性是非响应式的，未遍历转换为 getter/setter。可以通过 Vue.set(object, propertyName, value) 实现，实际上是单独调用了转换为 getter/setter 的方法。 参考 [https://cn.vuejs.org/v2/guide/reactivity.html] https://github.com/answershuto/learnVue/blob/master/docs/响应式原理.MarkDown https://blog.fundebug.com/2019/07/10/responsive-vue/ https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>vue响应式原理</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 原理深度剖析（一）]]></title>
    <url>%2F2020%2F09%2F01%2FVue_1_vueRouter%2F</url>
    <content type="text"><![CDATA[从vue-Router开始… vue 基础语法vue.js 的基础结构 一般结构，利用template模板双向绑定数据。 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p&gt;公司名称：&#123;&#123;company.name&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn....&quot;&gt;&lt;script&gt;&lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: &#123; company: &#123; name: &apos;la&apos;, &#125; &#125; &#125;)&lt;/script&gt; 利用 render 方法，它的参数 h函数 是为了创建虚拟DOM。$mount是将虚拟 DOM 转换为真实 DOM。 12345678910111213141516&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn....&quot;&gt;&lt;script&gt;&lt;script&gt; new Vue(&#123; data: &#123; company: &#123; name: &apos;la&apos;, &#125;, render(h)&#123; return h(&apos;div&apos;, [ h(&apos;p&apos;, &apos;公司名称：&apos; + this.company.name) ]) &#125; &#125; &#125;).$mount(&apos;#app&apos;)&lt;/script&gt; 这两种的方式不同，结果相同 vue.js 的生命周期略 如果使用构造生成文件（例如构造单文件组件），模板编译将提前执行。（推荐） 常用语法和概念差值表达式、指令（自定义指令）、计算属性和侦听器、Class/Style 绑定、条件/列表渲染、表单输入绑定……(略) 组件（可复用vue实例）、插槽、插件（VueRouter/VueX…）、混入 mixin（多个组件有相同的选项，将相同的选项进行合并，使代码可重用）、响应式原理（利用监听代理机制）、不同构建版本的Vue vue Router 原理分析与实现 [https://router.vuejs.org/zh/] 基本使用略： 1234567891011121314151617181920212223242526272829import VueRouter from 'vue-router' // 引入Vue.use(VueRouter) // 注册路由插件const routes = [ // 路由规则 &#123; path: '/', name: 'Index', component: Index &#125;,]const router = new VueRouter(&#123; // 创建路由对象 routes&#125;)export default router// 在实例上注册 router 对象new Vue(&#123; router, // 将$route（存储了路径及参数） // $router（一个路由对象实例，提供一些与路由相关的方法） 注册到实例上&#125;)// 组件上// &lt;router-link to="/"&gt;&lt;/router-link&gt; 类似 a 连接// &lt;router-view&gt;&lt;/router-view&gt; 占位符，用来替换路由组件 动态路由两种方式： 1234567891011121314151617181920212223const routes = [ // 路由规则 &#123; path: '/', name: 'Index', component: Index &#125;, &#123; path: '/detail/:id', name: 'Detail', // 开启 props,会把 URL 中的参数传递给组价，在组件中通过 props 来接收 props: true, component: () =&gt; import(/*webpackChunkName: "detail"*/ '../views/Detail.vue') &#125;,]// 组件获取// &#123;&#123; $route.param.id&#125;&#125; // 通过 $route 获取// &#123;&#123;id&#125;&#125; 通过 props 传参，类似父子组件传值 推荐第二种export default &#123; name: 'Detail', props: ['id'] // 接收id&#125; 嵌套路由 略，提取了组件相同的“父”部分作为父组件，不同的部分作为子组件。 编程式导航就是通过按钮进行页面跳转： 123456this.$router.push('/') // 传入对象 或者 地址字符串// this.$router.push(&#123;name: 'Home', params: &#123; id: 1&#125;&#125;) // 传入对象this.$router.replace('/login') // 和 push 效果相同，但是不会记入历史记录this.$router.go(-2) // 负数即后退，如果是 -1 的话，就相当于 this.$router.back() Chrome 长按后退按钮可以展示出所有的后退历史 hash模式 和 history模式 这两种模式都是客户端实现路由的模式：当页面发生变化的时候，不会向服务端发起请求，只是用JS监听路由的变化，根据不同的地址渲染不同的内容，如果需要服务端的内容会向服务端发送 AJAX 请求。 区别hash模式： https://....../#/pla?id=1 ，路径中会带有与数据无关的符号，“#”，“?”… 原理：基于锚点，以及 onhashchange 事件。 history模式: https://....../pla/1 ，但需要服务端配置支持。 原理：基于 HTML5 中的 History API。 history.pushState() （IE10之后支持） / history.replaceState() 将路径放到历史记录里。 history模式 单页面应用中，服务端不存在 https://....../pla/1 这样的地址，会报错，404找不到地址。服务端应配置，除了静态资源都返回单页面应用的 index.html。 1234567891011121314// 默认是 hash 模式，需要将 mode 改为 history 模式const router = new VueRouter(&#123; mode: 'history', routes&#125;)const routes = [ // 路由规则 &#123; path: '*', name: '404', component: () =&gt; import(/*webpackChunkName: '404'*/ '../views/404.vue') &#125;,] localhost:8080/video 刷新会向服务端发送请求，然后返回 404。为了解决这个问题，需要额外配置。 node 服务器配置 123456789101112131415161718const path = require('path')// 导入处理 history 模式模块const history = require('connect-history-api-fallback')const express = require('express')const app = express()// 注册 处理 history 模式的中间件app.use(history()) // 解决方法// 处理静态资源的中间件，网站根目录 ../webapp.use(express.static(path.join(__dirname, '../web')))app.listen(3000, () =&gt; &#123; console.log('服务器开启，端口：3000')&#125;) 服务器会默认将 index.html 返回，返回后 浏览器再去判断地址后面的参数 nginx 服务器配置： 从官网下载 nginx 的压缩包。 把压缩包解压到 c 盘根目录，c:\nginx-1.18.0 文件夹。 打开命令行，切换到目录 c:\nginx-1.18.0。(目录不能有中文) 1234567891011121314151617# 启动start nginx# 重启nginx -s reload#停止nginx -s stopnginx-1.18.0 |———— conf # 配置文件 | |———— nginx.conf |———— contrib |———— docs |———— html # 存储我们的网站,打包好的内容放到该目录 |———— logs |———— tempnginx.exe nginx.conf： 12345678910111213server&#123; listen 80; # 配置端口号 server_name localhost; # 域名，未绑到线上，默认为 localhost location / &#123; root html; # 指定根目录 html 文件夹 index index.html index.htm; # 默认的首页 try_files $uri $uri/ /index.html; # 配置 history 模式 # 就是尝试请求文件或文件下的 index.html，如果都没有则返回 默认首页 index.html &#125;&#125;# 配置完之后重启 nginx 模拟实现VueRouter 前置知识：插件、混入、Vue.observable()、插槽、render 函数、运行时和完整版的vue vueRouter 实现原理前端路由，判断前端路径加载不同的组件： hash 模式： URL 中 # 后面的内容作为 路径地址。 监听 hashchange 事件。 根据当前路由地址找到对应的组件重新渲染。 history 模式： 路径是普通的URL，通过 history.pushState() 方法改变地址栏，并把当前路径记录到历史记录里，并不会真正的跳转到指定路径，就不会向服务器发送请求。 监听 popstate 事件，监听浏览器历史记录的变化。 根据当前路由地址找到对应组件重新渲染。 pushState() / replaceState() 并不会触发该事件。back/forward事件才会被触发。 核心代码分析12345678910111213141516// 注册插件 Vue 功能的强大主要就是插件机制，比如VueX，VueRouter 等。Vue.use(VueRouter) // Vue.use() 传入函数或者对象，传入函数直接调用，传入对象，调用其中的 install 方法。// 创建路由对象const router = new VueRouter(&#123; routes: [ &#123; name: 'home', path: '/', component: homeComponent &#125; ]&#125;)// 创建 Vue 实例，注册 router 对象new Vue(&#123; router, render: h =&gt; h(app)&#125;).$mount('#app') VueRouter（对象）： 属性 options 传入的对象 路由规则 data 对象，其中的 current 属性记录当前路由，利用 Vue.observable()方法将其设置为响应式的。 方法 Constructor(options):VueRouter 初始化实例属性和方法。 _install(Vue):void 静态方法，用来实现vue的插件机制。 init():void 为了调用下面三个方法。 initEvent():void popstate 事件，监听浏览器历史记录的变化。 createRouteMap():void 初始化 routeMap 属性。将传入的路由规则转换为键值对的存储到 routeMap 对象中。路由地址对应组件 initComponents(Vue):void 用来创建 router-link 和 router-view 组价的。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148let _Vue = null; // 用来记录 vue，将其作为全局变量export default class VueRouter &#123; /** * 静态方法，用来实现vue的插件机制 * * @static * @param &#123;*&#125; Vue vue的构造函数 * @param &#123;*&#125; options 可选的选项对象 * @memberof VueRouter */ static install (Vue, options) &#123; // 1. 判断当前插件是否已经安装 // 2. 把 vue 的构造函数记录到全局变量中来，方便后面使用 vue 的构造函数，比如后面创建 vue-link vue-view 需要用到 vue.component // 3. 把创建 vue 实例时传入的 router 对象，给它注入到所有 vue 实例上。vue.$router 就是在这个时候注入到实例上的。 // 1.... 它检查它自己 if (VueRouter.install.installed) &#123; return &#125; VueRouter.install.installed = true; // 2.... _Vue = Vue; // 3.... // _Vue.prototype.$router = this.$options.router // 使用混入 _Vue.mixin(&#123; // 会给所有组件设置该选项 beforeCreate () &#123; // this 指向实例 if (this.$options.router) &#123; // 仅在实例上挂载 $router 属性， // 在组件的该 $options 选项中不存在 router,因此不会挂载 _Vue.prototype.$router = this.$options.router this.$options.router.init() &#125; &#125; &#125;) &#125; /** * Creates an instance of VueRouter. * 初始化实例属性和方法。 * - options 传入的对象 路由规则 * - data 对象，其中的 current 属性记录当前路由，利用 `Vue.observable()`方法将其设置为响应式的。 * - routeMap 对象，记录路由和地址的对应关系 * @param &#123;*&#125; options * @memberof VueRouter */ constructor (options) &#123; this.options = options; this.routeMap = &#123;&#125;; this.data = _Vue.observable(&#123; // 响应式的对象，这点很重要 current: '/' &#125;) &#125; /** * 包装下面的方法，方便调用 * * @memberof VueRouter */ init () &#123; this.createRouteMap(); this.initComponents(_Vue); this.initEvent() &#125; /** *遍历所有的路由规则，把路由规则解析成键值对的形式，存储到 routeMap 中 * * @memberof VueRouter */ createRouteMap () &#123; this.options.routes.forEach(route =&gt; &#123; this.routeMap[route.path] = route.component &#125;) &#125; /** * 创建组件 router-link / router-view * * @param &#123;*&#125; Vue vue构造函数，也可以使用全局变量 _vue * @memberof VueRouter */ initComponents (Vue) &#123; Vue.component('router-link', &#123; props: &#123; to: String &#125;, // template: '&lt;slot&gt;&lt;/slot&gt;' render (h) &#123; // h 是用来创建虚拟 dom 的 // 第一个参数是选择器，第二个参数是要创建的 dom 的属性对象，第三个参数是子元素数组 return h('a', &#123; attrs: &#123; href: this.to &#125;, on: &#123; // 注册事件 click: this.clickHandler // 不要写成事件调用 &#125; &#125;, [this.$slots.default]) &#125;, methods: &#123; clickHandler (e) &#123; history.pushState(&#123;&#125;, '', this.to); // 事件对象参数，网页标题，跳转地址 this.$router.data.current = this.to // this 当前 router-link 组件，使用是挂载到了vue 实例上， // 因此所有组件都可以拿到 $router e.preventDefault(); // 阻止 a 链接的事件调用 &#125; &#125;, &#125;) const self = this; // 存储 vueRouter 实例 Vue.component('router-view', &#123; render(h)&#123; // 调用 h 函数，返回虚拟 DOM // 找到路由地址，根据 routeMap 找到对应的组件， // 再利用 h 函数转换为虚拟 DOM，直接返回 // 要改变地址栏的地址，而不让它去请求服务器，调用方法 history.pushState() // 然后把当前地址记录到 当前路由地址 self.data.current const component = self.routeMap[ self.data.current ] // 根据当前路由地址找到组件 return h(component) &#125; &#125;) &#125; /** *点击前进后退改变组件 * * @memberof VueRouter */ initEvent () &#123; window.addEventListener('popstate', () =&gt; &#123; this.data.current = window.location.pathname &#125;) &#125;&#125; 将其引入替代原来的 vueRouter 问题报错： 运行时版：不支持 template 模板，需要打包的时候提前编译。vue-cli 默认为运行时版本，效率更高。 完整版：包含运行时和编译器，体积比运行时版本大 10k 左右，程序运行时把模板转换为 render 函数。 解决： 通过配置将运行时版本转为完整版 12345// 创建 vue.config.js 并将其中的 runtimeCompiler 默认值 false 设置为 truemodule.exports = &#123; // 选项... runtimeCompiler: true&#125; 通过渲染函数（render()），在运行时版本解决 123456789101112131415161718// 问题原因所在就是 运行时版本不带编译器，无法将 template 预编译成 render 函数。initComponents (Vue) &#123; Vue.component('router-link', &#123; props: &#123; to: String &#125;, // template: '&lt;slot&gt;&lt;/slot&gt;' render (h) &#123; // h 是用来创建虚拟 dom 的 // 第一个参数是选择器，第二个参数是要创建的 dom 的属性对象， // 第三个参数是子元素数组 return h('a', &#123; attrs: &#123; href: this.to &#125; &#125;, [this.$slots.default]) &#125; &#125;)&#125; 浏览器前进后退问题问题：浏览器，前进后退按钮改变地址栏地址，但组件没有响应。 解决：地址栏发生改变，加载响应的组件。利用 popState()会在历史发生变化时触发，pushState() / replaceState() 并不会触发该事件。back/forward事件才会被触发。 详见：initEvent()函数。 参考 mixin render [https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event]]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>vueRouter</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个 node 环境 npm 打包 errno 134]]></title>
    <url>%2F2020%2F08%2F25%2FB%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[#errno 134 问题 报错信息 JS 堆栈溢出 errno 134 https://stackoverflow.com/questions/38558989/node-js-heap-out-of-memory 解决 setx NODE_OPTIONS –max_old_space_size=8192 https://stackoverflow.com/questions/38558989/node-js-heap-out-of-memory 重启 vscode 总结有多种问题都会出现 errno 134： 一种解决方法如上，node JS溢出，解决方法如上。 还有一种是清除 npm 缓存，及 package-lock.json node_modules 重新 install。 https://stackoverflow.com/questions/57605441/error-this-is-probably-not-a-problem-with-npm-there-is-likely-additional-loggi]]></content>
      <categories>
        <category>前端 问题</category>
        <category>node npm 打包问题</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node npm 打包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化——了解Rollup/parcsell]]></title>
    <url>%2F2020%2F08%2F19%2FAWebTool_%E6%A8%A1%E5%9D%97%E5%8C%96_Rollup_parcell%2F</url>
    <content type="text"><![CDATA[RollupESModule打包器，作用与webpack类似，但是比webpack更加轻量级。它没有像webpack一样的插件机制，仅仅作为一个打包器存在着。 它主要是充分利用了ECM的特性，用来构建扁平化高性能的类库。 简单使用安装1npm install rollup --save-dev 使用123rollup ./src/index.js --format iife --file dist/bundle.js# 指定打包入口文件 --format指定输出格式 使用自调用格式# --file 指定打包的输出路径 rollup 会自动默认打开 treeShaking ，只打包使用到的模块，来优化我们打包结果。 打包的结果及其精简。 配置文件rollup.config.js 配置文件，同样运行在 node 环境中，但它会对该文件另行处理，所以可以继续沿用 ESM 的模块化方式。 1234567export default &#123; input: 'src/index.js', // 入口路径 output: &#123; // 出口配置 file: 'dist/bundle.js' , // 出口路径 format: 'iife' // format 打包格式 &#125;&#125; 告诉命令行使用配置文件： 12rollup --config# 也可以指定名称 `rollup --config rollup.config.js` 使用插件 当我们需要加载其它类型的资源文件，或导入CommonJS模块，或编译ES的新特性，这些额外的需求也可以使用插件的方式扩展。而且这是它唯一的扩展途径。 1234567891011121314npm install rollup-plugin-json --save-dev # 导入json文件的插件rollup.config.jsimport json from 'rollup-plugin-json'export default &#123; input: 'src/index.js', // 入口路径 output: &#123; // 出口配置 file: 'dist/bundle.js' , // 出口路径 format: 'iife' // format 打包格式 &#125;, plugins: [ json(), // 将调用结果配置进来 ]&#125; 加载 npm 模块node_modules 下面的第三方的模块，它不能直接通过模块名称引用，需要借助插件来磨平该差异。 1234567891011121314151617181920npm install --save-dev rollup-plugin-node-resolve npm install lodash-es # 测试 rollup 默认只能加载 ES模式模块rollup.config.jsimport json from 'rollup-plugin-json'import resolve from 'rollup-plugin-node-resolve';import commonjs from 'rollup-plugin-commonjs';export default &#123; input: 'src/index.js', // 入口路径 output: &#123; // 出口配置 file: 'dist/bundle.js' , // 出口路径 format: 'iife' // format 打包格式 &#125;, plugins: [ json(), // 将调用结果配置进来 resolve(), commonjs() ]&#125; 加载 CommonJS 模块 由于许多 npm 模块还是使用 CommonJS 来导出成员，因此需要对此做出兼容 1npm install --save-dev rollup-plugin-commonjs https://github.com/rollup/rollup-plugin-commonjs 代码拆分 新版本已经支持代码拆分Code Splitting了，并使用 Dynamic Imports 动态导入的方式实现了按需加载 123import('./logger').then((&#123; log &#125;) =&gt; &#123; // 使用动态导入 log('code splitting~')&#125;) 修改，rollup.config.js 123456output: &#123; // 出口配置 // file: 'dist/bundle.js' , // 出口路径 // format: 'iife' // format 打包格式 dir: 'dist', // 指定多个输出文件使用该参数代替 file 参数 format: 'amd' // 使用代码拆分不能使用 iife 这种代码格式&#125;, 多入口打包 多入口打包，会内部会提取代码拆分，公共模块，因此不能再使用 iife 输出格式 修改，rollup.config.js 123456789101112131415export default &#123; // input: 'src/index.js', // 入口路径 input: ['src/index.js', 'src/main.js'] // 1.使用数组或对象 output: &#123; // 出口配置 // file: 'dist/bundle.js' , // 出口路径 // format: 'iife' // format 打包格式 dir: 'dist', format: 'amd' &#125;, plugins: [ json(), // 将调用结果配置进来 resolve(), commonjs() ]&#125; amd 格式不能直接引用到页面上，需要使用实现了amd标准的库加载，比如require.js &lt;script src=&quot;......./require.js&quot; data-main=&quot;foo.js&quot;&gt; &lt;/script&gt; 指定入口模块路径。 使用场景优点： 输出结果干净扁平 自动移除引用的代码 treeshking 打包结果依然完全可读 缺点: 加载非 ESM 的第三方模块比较复杂。 模块最终都被打包到一个函数中，无法实现 HRM 模块热替换。 浏览器环境中，代码拆分功能依赖 AMD 库。 如果开发应用程序，需要大量三方库，并需要HRM这种模块热替换等，就使用webpack。 如果开发一个框架或类库，建议使用 Rollup。 Parcel 极速零配置Web应用打包器。 简单实用安装1npm install parcel-bundler --save-dev 使用 官方建议我们使用 HTML 文件作为文件打包的入口 1parcel src/index.html parcel 会根据 html 文件引入的标签找到打包入口并顺着import语句进行打包。 并且自动开启了一个类似 dev-serve 的开发服务器，并且在修改时会自动刷新服务器。 HMR123456if(module.hot) &#123; // 只接受一个参数 回调函数，即只有当前模块或者当前模块依赖的模块更新才会触发 module.hot.accept(()=&gt;&#123; console.log('hrm') &#125;)&#125; 自动安装依赖 parsel 有自动安装依赖的功能 12import $ from 'jquery' // 直接使用，parsel会自动安装import './style.css' // 引入其他文件，比如 css 对于其它文件的引入也是零配置的，也可以自动更新。 支持动态导入 内部使用动态导入，它也会自动拆分代码 123import('jquery').then($ =&gt; &#123; $('div').append('&lt;p&gt;你好啦&lt;/p&gt;')&#125;) 生产模式打包1parcel build src/index.html # 生产模式打包 parcel 使用的是多进程，相对来说要比 webpack 要快，webpack 需要使用 happypack 插件实现这一点。 特点优点： 零配置，使用简单。 构建速度快。 缺点：2017发出，生态可能不完善 参考 https://www.rollupjs.com/ https://zh.parceljs.org/]]></content>
      <categories>
        <category>前端</category>
        <category>前端 Tool</category>
        <category>模块化 Rollup/parcsell</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端 Tool</tag>
        <tag>模块化 Rollup/parcsell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化——深入Webpack对比]]></title>
    <url>%2F2020%2F08%2F19%2FAWebTool_%E6%A8%A1%E5%9D%97%E5%8C%96_webpack%2F</url>
    <content type="text"><![CDATA[模块化前端范式之一，主流的代码组织方式。 演变过程 文件划分 (script标签) —— 命名空间的方式 —— IIFE —— 引入模块化规范 文件划分，引入全局导致了全局污染，依靠约定。 命名空间，文件划分 的基础上用对象包裹，解决全局污染，没有私有空间，仍可以被外部访问，没有依赖关系。 利用 IIFE 立即执行函数的方式， 封装私有空间，作用域。 向外暴露成员挂载到全局对象 window 上。 利用闭包具有私有变量。 利用自执行函数的参数作为依赖执行。 123;$(function ($) &#123;&#125;)(jQuery) // 依赖了 jQuery 模块化 规范 模块化标准 + 模块加载器（实现自动加载） Common.jsNode提出的一个标准，它约定了以下规范： 一个文件一个模块。 每个模块都有一个单独的作用域。 通过 module.exports 导出成员。 通过 require 函数载入模块。 Common JS 是以同步模式加载模块，node 的执行机制是启动时加载模块，使用再引入，而浏览器端不能使用，同步模式请求过大会引起性能问题。 AMD Asynchronous Module Definition 异步模块化规范，同期 Require.js 库就实现了该规范，并实现了模块加载器的功能。 12const a = require('b') // 加载模块define( ... () =&gt; &#123; return c &#125;) // 定义模块 缺点：使用复杂，模块 JS 文件请求频繁 CMD CMD，通用模块定义规范，sea.js 实现了该规范。它的出现时为了降低学习成本。 最佳实践 Node环境中遵循 CommonJS 规范，浏览器环境遵循 ES Modules 规范。 CommonJS，是内置模块没有兼容等问题。 ES Modules，在新语法中实现，偶尔会有新语法 兼容问题。 ES Modules准备工具： 1// script 标签设置 type="module" 的属性就可以以 ES Module 的标准执行其中的JS了 123456npm initnpm install serve --save-devnpm install browser-sync --save-dev # 具有热更新功能模块npm link browser-syncbrowser-sync . --files **/*.js # 监听所有的 js 文件 基本特性 script 标签设置 type=&quot;module&quot;相对于普通的 script 标签会有不同的特性 自动采用严格模式，忽略 use strict。 123&lt;script type="module"&gt; console.log(this) // 严格模式 undefined 非严格模式 window&lt;/script&gt; 每个 module 都是运行在单独的私有作用域当中。 123456789&lt;!-- 私有作用域 划地为营 --&gt;&lt;script type="module"&gt; var foo = 100; console.log(brr); // 200&lt;/script&gt;&lt;script&gt; var brr = 200; console.log(foo); // undefined&lt;/script&gt; 外部JS文件是通过 CORS 方式请求的，不在同源地址下，响应需要提供有效 CORS 标头，CORS 标头不支持文件请求。 12&lt;script type="module" src="https://unpkg.com/jquery@3.4.1/dist/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="module" src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; ESM 的 script 会自动的延迟执行脚本，等同于 script 中的 defer 属性。script 会阻塞代码的执行，延迟执行，使得渲染完成之后再执行脚本 。 导出导入 export 关键字导出。 import 关键字导入。 https://es6.ruanyifeng.com/#docs/module https://javascript.ruanyifeng.com/nodejs/module.html ESM 兼容性问题ESM in BrowserIE 不支持 ESM： babel 转义为 ES5。 polyfill 兼容方案 npm install browser-es-module-loader 。 npm install promise-ployfill --save-exact。 给 script 标签 nomodule 属性，使其仅在不支持module的浏览器执行 ESM in Node.jsnode &gt; 8.5 可以直接使用 ESM。 index.js 改为 index.mjs node --experimental modules index.mjs 运行试验特性 与 CommonJS 模块交互 ESM 中可以导入 CommonJS 模块。 CommonJS 中不能导入 ESM模块。 CommonJS 始终只会导出一个默认成员。 注意 import 不是解构导出对象。 在 node 中使用 ESM 和 CommonJS 差异注意：导入导出可以被 import和exports 代替，__filename 和 __dirname 需要别的方式代替 新版本支持情况node 12.~： 不需要改文件后缀名，需要将package.json中添加字段 &quot;type&quot;: &quot;module&quot;。 而再想使用 CommonJS 规范，需要将 common.js 改为 common.cjs。 早期 node 兼容方案利用 babel： npm install @babel/node @babel/core @babel/preset-env --save-dev。 运行 babel-node 命令。 preset-env 插件集合。babel-node index.js --preset=@babel/preset-env 配置.babelrc 文件，&quot;presets&quot;: [&quot;@babel/preset-env&quot;]，presets 是一组插件。 使用单独的插件 1npm install @babel/plugin-transform-modules-commonjs --save-dev 配置.babelrc 文件，&quot;plugins&quot;: [&quot;@babel/plugin-transform-modules-commonjs&quot;] 模块化打包工具主要解决问题： 环境兼容问题。比如编译转化各种各样的代码。 将模块化零散的文件打包，减少请求。 支持其他前端资源模块化。 概要webpack： 模块打包器打包。 模块加载器。 代码拆分。（避免打包文件过大） 将资源模块化引入。 模块化工具是解决的是前端整体的模块化。 入门安装12npm init npm install webpack webpack-cli --save-dev 配置文件webpack4.0 版本： 支持零配置打包。 约定 src/index.js 作为入口，dist/main.js 作为出口。 一般配置，会配置在 webpack.config.js 文件里，因为是运行在node环境中，需要按照 CommonJS 规范。 12345678910const path = require('path')module.exports = &#123; mode: 'development', entry: './src/main.js', // 入口 output: &#123; filename: 'bundle.js', // 出口 path: path.join(__dirname, 'output') // 绝对路径 &#125;&#125; 工作模式webpack4.0 新增了 工作模式，指代针对不同环境预设的配置。 123456WARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/# 设置模式webpack --mode development # 启动开发模式打包 默认 production 模式，自动启动优化，优化打包结果。 development 模式，自动添加打包速度，添加一些调试辅助。 none 模式，不会有任何多余的操作。 也可以直接在配置文件中添加 mode 属性 打包结果运行原理 ctrl + K + 0 折叠所有代码 123456789101112131415161718192021222324252627// 源码拆解(function(modules) &#123; // 模块 modules = [fn,fn,fn...] // The module cache 缓存加载过的模块 var installedModules = &#123;&#125;; // The require function 加载模块 function __webpack_require__(moduleId) &#123; // 先从缓存中读取，没有则创建新的模块放到缓存中 &#125; // ========== // 这里是一些数据和工具函数 // ========== // Load entry module and return exports // 加载入口模块并输出 return __webpack_require__(__webpack_require__.s = 0);&#125;)([ (function()&#123;&#125;), // 这里的参数对应的就是源代码里的一个个模块 (function()&#123;&#125;), // 包裹在函数中实现模块私有作用域 (function()&#123; // ... __webpack_require__.r(__webpack_exports__); // 调用r函数，向外表明为 ESModule 模块 // ... &#125;), // ...]) 将各个模块写入到同一个文件当中，并还保持原来的状态关系 资源模块加载 默认的资源加载器Loader，加载 JS 文件，想要加载不同的文件，就要配置不同的 Loader。 12npm install css-loader --save-dev # css 编译为 jsnpm install style-loader --save-dev # 将编译好的追加到 style标签页面上 其它资源的加载配置，配置在配置文件的 modules 字段里 1234567891011module: &#123; rules: [ &#123; test: /.css$/, use: [ 'style-loader', 'css-loader', // 多个 loader 从数组后面开始 ] &#125; ]&#125; 动态导入资源利用 import 在需要的地方导入文件，webpack会自动沿着 import 打包。 代表性 loader文件资源加载器 根据文件匹配到文件，加载器将文件复制到输出目录，然后将文件所在的输出目录的路径作为返回值返回。 1npm install file-loader --save-dev webpack.config.js： 123456789101112131415161718192021222324module.exports = &#123; mode: 'none', entry: './src/main.js', // 入口 output: &#123; filename: 'bundle.js', // 出口 publicPath:'dist/', // 需要指定文件打包后的路径 path: path.join(__dirname, 'dist') // 绝对路径 &#125;, module: &#123; rules: [ &#123; test: /.css$/, use: [ 'style-loader', 'css-loader', // 从数组后面开始 ] &#125;, &#123; test: /.png$/, use: 'file-loader' &#125; ] &#125;&#125; Data URLs/url-loader Data URLs 是特殊的URL协议。 data:[&lt;mediatype&gt;][;base64],&lt;data&gt;，分别为：协议、媒体类型和编码、文件内容。它本身就包含了内容本身，就不会去发送http请求了。 比如： 1data:text/html;charset=UTF-8,&lt;h1&gt;html content&lt;/h1&gt; 如果是图片字体等二进制文件类型，可以先将文件内容经过 base64 编码 1data:image/png;base64,isadhadsofdsjifadisjfa... 在 webpack 打包静态资源时，我们也可以通过这种方式来实现。 需要使用到 url-loader 加载器， 1npm install url-loader --save-dev 之后将 file-loader 改为 url-loader。 最佳的实践方式是： 小文件使用 Data URLs，减少请求次数。 大文件单独提取存放，提高加载速度。 1234567891011121314 module: &#123; rules: [ &#123; test: /.png$/, use: &#123; loader: 'url-loader', options: &#123; limit: 10 * 1024 // 单位是字节，需要乘以 1024 = 10kb &#125; &#125; &#125; ] &#125;// 小于 10kb 使用url-loader,大于10kb自动使用 file-loader,记得安装 file-loader 常用加载器分类编译转换类：这种类型的 loader 会将加载到的资源模块，转换为 JS 代码。比如：CSS-loader。 文件操作类型：将加载到的资源模块，拷贝到输出目录，同时会将访问路径向外导出。比如：file-loader。 代码检查类：将加载到的代码资源进行校验，统一风格，提高代码质量。 处理 ES2015 webpack是一个打包工具，如果需要在打包过程中顺便编译，需要安装一个编译型的loader。 1234567891011121314npm install babel-loader @babel/core @babel/preset-env --save-devmodule: &#123; rules: [ &#123; test: /.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; ] &#125; 模块加载方式 基于 ESM标准的 import 声明。 遵循 CommonJS 标准的 require 函数。 遵循 AMD 标准的 defined 函数和 require 函数。 模块加载模式不要混用，不利于维护。 loader 加载的非 js 也会触发资源的加载。比如： 样式代码中的 @import 指令和 url 函数。 HTML 代码中图片标签的 src 属性。 webpack 根据不同的文件，找到相应的loader进行加载。 1npm install html-loader --save-dev 配置： 12345678910111213141516171819202122232425262728module: &#123; rules: [ &#123; test: /.html$/, use: &#123; loader: 'html-loader', options: &#123; attributes: &#123; list: [ &#123; // Tag name tag: 'a', // Attribute name attribute: 'href', // Type of processing, can be `src` or `scrset` type: 'src', // Allow to filter some attributes filter: (tag, attribute, attributes, resourcePath) =&gt; &#123; return true; &#125;, &#125; ] &#125;, &#125; &#125; &#125; ] &#125; 核心工作原理 从打包入口开始，根据代码中出现的 import require等模块语句，解析推断出模块之间的依赖关系。 形成依赖关系的依赖树。 遍历，递归这个依赖树，找到对应的资源文件。 根据配置文件的 rules 属性，找到对应的模块的加载器加载该模块。 将加载结果放到输出文件中，实现整个项目的打包。 loader机制 是 webpack 的核心 开发my loader 实现 markdown-loader 文件加载器，实现可以在代码中直接导入md文件的功能。 md文件是转换为html后呈现到页面上的，实现导入的md文件就是html字符串 loader 函数类似管道，可以链式调用。（loader 要返回 JS 代码或者新的加载器） 12345678910111213141516webpack.config.jsmodule: &#123; rules: [ &#123; test: /.md$/, use: [ &apos;./markdown-loader&apos;, ] &#125;, ] &#125;markdown-loader.jsmodule.exports = source =&gt; &#123; // source接收输入 console.log(source); return &apos;console.log(&quot;i am md&quot;)&apos;; // return js 代码&#125; marked md 解析模块 1234567891011121314151617181920212223242526272829npm install marked --save-dev # 用来解析md模块npm install html-loader --save-dev # 用来解析解析完成后的 html webpack.config.jsmodule: &#123; rules: [ &#123; test: /.md$/, use: [ 'html-loader', './markdown-loader', ] &#125;, ] &#125;loaderconst marked = require('marked')module.exports = source =&gt; &#123; // source接收输入 const html = marked(source) // 返回一个 JS 代码 // return `module.exports = "$&#123;html&#125;"` 换行符等拼接可能会存在语法错误 // return `module.exports =$&#123;JSON.stringify(html)&#125;` // return `export default $&#123;JSON.stringify(html)&#125;` // 返回的 html 字符串交给下一个 loader 处理 return html&#125; 插件机制 Loader 专注实现资源模块加载，插件（plugin）解决其它自动化的工作，比如：清除dist目录，拷贝静态文件，压缩代码……。 常用的插件clean-webpack-plugin1234567npm install clean-webpack-plugin --save-devwebpack.config.jsconst &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')// ...plugins: [ new CleanWebpackPlugin()] html-webpack-pluginHTML参与webpack构建，自动生成html文件解决： html 和 dist不同包，要同时发布两个的问题 配置变化，路径变化，html 中的路径要跟着变化问题 1234567891011121314151617181920212223242526272829303132npm install html-webpack-plugin --save-devwebpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin')const copyWebpackPlugin= require('copy-webpack-plugin')plugins: [ new CleanWebpackPlugin(), // 用于生成index.html new HtmlWebpackPlugin(&#123; title: 'my webpack sample', meta: &#123; viewport: 'width=device-width' &#125;, template: './src/index.html' // 使用模板 &#125;), // 用于生成 多个html页面就多次调用该实例 new HtmlWebpackPlugin(&#123; filename: 'about.html' &#125;), new HtmlWebpackPlugin(&#123; template: 'entry/index.html', title: 'CSStoryEditor', filename: 'edit.html', chunks: ['app'], favicon: 'entry/favicon.ico' &#125;), new CopyWebpackPlugin(&#123; patterns: [ 'public' ] &#125;)] copy-webpack-plugin 对于不需要构建的静态文件，在打包时可以一并输出到输出目录。 1npm install copy-webpack-plugin --save-dev https://github.com/webpack-contrib/copy-webpack-plugin 开发一个插件插件机制工作原理 插件机制基于钩子机制。 Hooks：https://webpack.docschina.org/api/compiler-hooks/ webpack 要求我们的插件必须是个函数或者是一个包含apply方法的对象。 需求：删除打包后的js中多余的注释：/*****/。 利用到的钩子函数： emit 输出 asset 到目录之前执行。 12345678910111213141516171819202122232425262728class MyPlugin &#123; apply(complier)&#123; console.log('myPlugin') // 通过complier的hooks属性访问emit钩子函数，通过tap方法注册一个钩子函数。 // 第一个参数插件的名称，第二个参数需要挂载的函数 complier.hooks.emit.tap('MyPlugin', compilation =&gt; &#123; // compilation 是个对象，是此次打包的上下文 console.log("compilation =======&gt; "+ compilation.assets) for(const name in compilation.assets)&#123; console.log(name) // 文件名 // console.log(compilation.assets[name].source()) // 文件内容 if (name.endsWith('.js'))&#123; const contents = compilation.assets[name].source() const withoutComments =contents.replace(/\/\*\*+\*\//g, '') compilation.assets[name] = &#123; source: () =&gt; withoutComments, // 同样将source的返回值该为替换后的内容 size: () =&gt; withoutComments.length // webpack 要求的必须的方法 &#125; &#125; &#125; &#125;) &#125;&#125;plugins: [ new MyPlugin()] 插件的工作原理，是通过往 webpack 的生命周期的钩子中挂载函数实现扩展的。 开发体验 传统：编写源代码，webpack打包，运行，刷新浏览器 设想理想的开发环境需要： 以 HTTP Server 运行。 可以更加接近生产环境的状态。 支持ajax等API。 自动编译可自动刷新。 简化开发。 提供 sourceMap 支持。 利于调试。 实现自动编译利用 watch 的工作模式，监视源文件 1webpack --watch webpack 会以监视模式去运行，在打包完成之后，不会马上退出，它会等待文件变化，直到手动退出。 在另一个控制台打开服务，但仍需要手动刷新浏览器实现刷新。 自动刷新浏览器123npm install -g browser-syncbrowser-sync dist --files &quot;**/*&quot; 利用 watch 模式，自动编译，利用 browser-sync 自动刷新浏览器 但需要同时使用两个工具，并且进行了两次磁盘读写操作。 webpack Dev Serverwebpack 官方工具，提供用于开发的 HTTP Server，并且集成了 自动编译和自动刷新浏览器等功能。 1npm install webpack-dev-server --save-dev 集成了以上的所有功能，但是它并没有将打包结果放到磁盘中，而是放到了内存中，提高运行效率 静态资源访问如果有静态资源需要作为开发服务器的资源被访问，可以配置 webpack.config.js 中的 devServer 字段。 123devServer: &#123; contentBase: ['./public'] // 指定 额外的静态资源路径&#125;, new CopyWebpackPlugin() 在上线前才会使用。 代理 API 服务开发环境和生产环境的API不一致会有跨域问题： 如果该API支持CORS，则可以使用跨域资源共享（CORS）解决。 如果同源部署，可以是用dev-Server提供的代理配置来解决。 12345678910111213141516171819devServer: &#123; contentBase: ['./public'], // 指定 额外的静态资源路径 proxy: &#123; '/api': &#123; // key 代理de 请求路径前缀，值为代理规则配置 // https://localhost:8080/api/users ——&gt; https://api.github.com/api/users target: 'https://api.github.com', // https://localhost:8080/api/users ——&gt; https://api.github.com/users pathRewrite: &#123; '^api': '' &#125;, // 不能使用 localhost:8080 作为请求 GitHub 的主机名 // 请求会将 localhost:8080 这个主机名带向服务器，服务器不认识， // 需要修改为代理的地址 changeOrigin: true &#125; &#125;&#125;, test.js：顺便复习一下原生js 12345678let xhr = new XMLHttpRequest();xhr.open('GET', 'https://api.github.com/users', true);xhr.send();xhr.onreadystatechange = function(e)&#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText) &#125;&#125; SourceMap 问：运行代码和源码不同，将难于调试，因此引入 Source Map。用来映射运行代码和源代码之间的关系。 映射一般在 min.map 格式文件夹下。 添加注释：//# sourceMappingURL-jquery-3.4.1.min.map 就会自动请求该map文件。根据该内容逆向解析出源文件。 webpack.config.js 配置方式： 1devtool: sourceMap devtool 可以配置很多模式，生成sourceMap文件的方式有很多种，每种方式的效率和效果不同。 大致规律如下： eval - 是否使用 eval 执行模块代码。 cheap - Source Map 是否包含行信息。 module - 是否能够得到 Loader 处理之前的源代码。 inline - sourcemap以 data-url 的方式嵌入到代码当中。 hidden - 生成但是未引入该文件，比如：jQuery等。 nosources - 提供位置，但不提供源代码，保护生产环境中的代码。 公司项目中使用的是 eval-source-map 模式，错误可以定位到行和列。 https://webpack.js.org/configuration/devtool/ 选择合适的 SourceMap 1cheap-module-eval-source-map 开发阶段。 需要定位经过 loader。 首次打包速度慢，重写打包相对快。 none / nosources-source-map 生产环境保密性。 HMR 模块热替换：在页面不更新的情况下更新代码模块。只更新修改的模块。 开启： webpack-dev-server --hot 命令开启。 devServer:{hot: true} 配置文件开启。 12345const webpack = require('webpack')plugins: [ new webpack.HotModuleReplacementPlugin()]// 样式文件可以直接进行热更新 手动处理模块热替换逻辑： 框架下开发有时框架内部会集成提供热更新。 使用热更新的APIs 1module.hot.accept('./main.js',()=&gt;&#123;&#125;) // hmr 模块 图片热替换 hmr问题 使用 hot-only 解决报错会自动更新问题。 module.hot 模块来自hmr，可以先判断是否引入 hmr。 生产环境优化 webpack 添加额外的代码实现其功能，在生产模式很多是不必要的。 生产环境更注重运行效率。比如：使用 webpack 的预设配置 mode。 可以配置文件根据环境不同导出不同的配置。(适用于中小型项目) 1234567891011121314151617181920212223/** * * * @param &#123;*&#125; env 通过 CLI 传递的环境名参数 * @param &#123;*&#125; args 运行 cli 过程中所有参数 */module.exports = (env, args) =&gt; &#123; const config = &#123; // 开发模式下的配置 &#125; if (env === 'production') &#123; config.mode = 'prodution' config.devtool = false config.plugin = [ ...config.plugin, new CleanWebpackPlugin(), new CopyWebpackPlugin([`public`]) ] &#125; return config&#125;webpack --env production # 给 env 传递了一个参数，参数值为 production 也可以在全局直接判断环境变量来导出不同的配置。 一个环境对应一个配置文件。 公共配置文件，抽象开发生产配置。webpack.common.js 再者是两个配置文件。webpack.dev.js/webpack.prod.js 1234567891011121314151617npm install webpack-merge --save-dev # 用来深拷贝并合并对象，使用common时使用# 也可以使用其它库的merge方法webpack --config webpack.prod.js # 运行时命令，可以写进 script 里webpack.prod.jsconst common = require('./webpack.common');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const copyWebpackPlugin = require('copy-webpack-plugin');const merge = require('webpack-merge')module.exports = merge(common, &#123; // merge 专门用来合并webpack配置文件的 mode: 'production', plugins: [ new CleanWebpackPlugin(), new copyWebpackPlugin(['public']) ]&#125;) DefinePlugin 一个为代码注入全局成员的插件。production 模式下默认启用，并注入了一个常量 process.env.NODE_ENV ，许多模块就是依据这个成员来判断运行环境的。 1234567891011const webpack = require('webpack')module.exports = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; // 接收一个对象，对象中的每个键值都会注入到我们的代码中 API_BASE_URL: `"string"` // 会将所有代码中 API_BASE_URL 转换为 "string" // 该 差价 所传的值是JS代码片段 // 如果想要值，可以将其表示为代码片段，比如：JSON.stringify('string'),结果为string值 &#125;) ]&#125; TreeShaking 检测未引用代码，并移除，它会在生产模式下自动开启。 123456optimization: &#123; // 这里集中配置webpack内部的优化功能。 usedExports: true, // 表示在输出结果中只导出外部使用了模块 minmize: true, // 压缩代码 concatenateModules: true, // 把所有模块合并到一起放到同一个函数里 Scope Hoisting&#125; concatenateModules 合并模块函数，模块会被放到函数当中作为参数，模块过多会增加代码体积，降低运行效率。 Tree-shaking&amp;Babel疑问：使用 Babel 无法使用 TreeShinking 问题？ TreeShaking 使用的前提，就是要使用 ESM 来组织我们的代码，实现我们的模块化。 babel 在转换时会将ESM转换为 CommonJS，在最新版本中默认关闭了该转换。 1234567options: [ // 强制将 ESM 转换为 commonjs,TreeShinking将失效 ['@babel/preset-env', &#123; modules: 'commonjs' &#125;] // 确保不会转换 ['@babel/preset-env', &#123; modules: false &#125;] ] sideEffects 副作用，允许我们通过配置，来表示我们的代码是否有副作用 副作用：指，模块执行时除了导出成员之外所做的事情。 sideEffects：一般用来在开发 npm 包时标记是否有副作用。它会在生产模式下自动开启。 123456optimization: &#123; // 这里集中配置webpack内部的优化功能。 sideEffects: true, // 开启功能&#125;// package.json"sideEffects": false // 标示当前代码package.json所影响的项目，没有副作用 没有副作用的模块也没有引入的情况下，就会被移除。 注意sideEffects 使用的关键在于确定模块没有副作用。 12345// package.json 标示哪些有副作用"sideEffects": [ './src/*', '*.css'] Code Splitting 代码分包/代码分割，在应用工作时，并不是所有模块都是必须要加载进来的，此时代码分割就显的尤为重要。 加之http1.1版本的许多缺陷： 它在同域的并行请求受到了限制。 每次请求都会有一定的延迟。 请求的 Header 浪费带宽流量。 在这之上，我们需要打包并分包，按需加载。方式：多入口打包、动态导入。 多入口打包 适用传统的多页应用程序。一个页面对应一个打包入口，公共部分单独提取。 123456789101112131415161718192021222324252627282930313233343536373839const HtmlWebpackPlugin = require('html-webpack-plugin')/*...*/entry: &#123; // 注意 entry 这里是一个对象而不是一个数组，数组是将多个文件打包到一起 index: './src/index.js', main: './src/main.js'&#125;output: &#123; filename: '[name].bundle.js' // name 会替换为 入口名&#125;/*...*/plugins: &#123; new HtmlWebpackPlugin(&#123; title: 'index', meta: &#123; viewport: 'width=device-width' &#125;, filename: 'index.html', template: './src/index.html', chunks: ['index'] &#125;), new HtmlWebpackPlugin(&#123; title: 'main', meta: &#123; viewport: 'width=device-width' &#125;, filename: 'main.html', template: './src/main.html', // chunks 将各自引入的js引入各自的html, 避免引入同一个HTML文件。指定需要注入的bundle chunks: ['main'] &#125;),&#125; 提取公共模块 我们需要将公共模块打包到同一个文件 12345optimization: &#123; splitChunks: &#123; chunks: 'all' // 会将所有的公共模块打包到一起 &#125;&#125; 动态导入 按需加载，在我们需要某个模块时，我们再加载这个模块。webpack利用动态导入来实现按需加载，动态导入的模块会被自动分包。 静态导入1234567891011// 静态导入import index from './index/index'import main from './main/main'/*...*/if (hash === '#index')&#123; dom.appendChild(index())&#125; else if (hash === '#main') &#123; dom.appendChild(main())&#125; 动态导入1234567891011121314151617// 动态导入// import index from './index/index'// import main from './main/main'/*...*/if (hash === '#index')&#123; // dom.appendChild(index()) import('./index/index').then((&#123; default: index&#125;) =&gt; &#123; dom.appendChild(index()) &#125;)&#125; else if (hash === '#main') &#123; // dom.appendChild(main()) import('./main/main').then((&#123; default: main&#125;) =&gt; &#123; dom.appendChild(main()) &#125;)&#125; 按照ESM动态导入成员的方式导入模块，webpack 会自动进行分包、提取公共模块、按需加载。 使用框架进行单页面开发，路由模块可以使用动态导入按需加载。 魔法注释 webpack分包默认为 bundel1.js … ，给 webpack 分包命名使用特定的注释。 1234import(/* webpackChunkName: 'main'*/'./main/main').then((&#123; default: main&#125;) =&gt; &#123; dom.appendChild(main())&#125;)// /* webpackChunkName: 'main'*/ 设置的名字相同就会被打包到同一个文件。 MiniCssExtractPlugin 将 CSS 代码打包到单独的文件的插件，它可以实现 CSS 的按需加载。 css代码不大没有必要进行该操作，到大小超过150kb时再使用该插件。 12345678910111213141516171819202122npm install mini-css-extract-plugin --save-devwebpack.config.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin')/*...*/rule: [ &#123; test: /\.css$/, use: [ // 'style-loader' MiniCssExtractPlugin.loader, 'css-loader' ] &#125;]/*...*/plugins: &#123; new MiniCssExtractPlugin()&#125; OptimizeCssAssetsWebpackPlugin 压缩输出的 CSS 文件。webpack内部的压缩仅仅针对引入js文件的压缩，其它压缩均需要额外插件。 123456789npm install optimize-css-assets-webpack-plugin --save-devwebpack.config.jsconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')/*...*/plugins: &#123; new OptimizeCssAssetsWebpackPlugin() // 在任何模式都会压缩&#125; webpack 推荐将所有压缩类插件配置到 optimization 下的 minimizer 下便于控制： 1234567891011const TerserWebpackPlugin = require('terser-webpack-plugin')/*...*/optimization: &#123; minimizer: [ // 生产模式下自动启用该特性，webpack默认启用自定义压缩文件，原本的js压缩将失效，将重新配置压缩 new OptimizeCssAssetsWebpackPlugin()， new TerserWebpackPlugin() // 压缩js文件 ]&#125; 输出文件名 Hash 前端部署前端资源时，会启用服务器的静态资源缓存，对于用户的浏览器而言就会缓存住静态资源，从而减少请求。 问题：设置缓存的时间不能过短，过短就会失去了缓存的意义，时间过长服务器更新资源不能得到及时更新。 在生产环境下，给文件名使用 Hash 值，当资源更新时，文件名也会随之变化，对于客户端就会对新的文件进行请求，从而解决缓存的问题，将时间设置的长一点也无所谓了。 设置哈希的三种方式： filename: &#39;[name]-[hash].bundle.js&#39; 给 filename 设置项目级别的hash，任意代码更新，全部hash都会发生变化。 filename: &#39;[name]-[chunkhash].bundle.js&#39; chunk块级别的打包，根据打包的模块进行块更新。 filename: &#39;[name]-[contenthash].bundle.js&#39; 设置文件级别的hash，文件改变就会改变hash值。 [contenthash:8] 指定hash的长度，控制缓存推荐该 hash 模式。 参考 https://imweb.io/topic/55994b358555272639cb031b https://fe.rualc.com/note/js-modular.html https://www.webpackjs.com/loaders/html-loader/ https://imweb.io/topic/5d4a94a08db073cf44ca8cd0]]></content>
      <categories>
        <category>前端</category>
        <category>前端 Tool</category>
        <category>模块化 Webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端 Tool</tag>
        <tag>模块化 Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[规范化——ESLint]]></title>
    <url>%2F2020%2F08%2F19%2FAWebTool_%E8%A7%84%E8%8C%83%E5%8C%96_ESLint%2F</url>
    <content type="text"><![CDATA[规范化标准团队项目需要明确的统一编码标准，降低项目的沟通及维护成本。 代码、文档、提交日志均需要统一标准，其中代码规范最为重要。 代码方面比如：空格场景，缩进方式，函数变量命名规范。 如今已经以从认为规定到使用工具来实现，Lint。 ESLint 一个主流的 JavaScript Lint 工具 监测 JS 代码质量。 带来什么？统一开发者编码风格。提高开发者编码能力。 安装123npm initnpm install eslint --save-devnpx eslint -v 配置1npx exlint --init 市面上三种主流风格： Airbnb: https://github.com/airbnb/javascriptStandard: https://github.com/standard/standardGoogle: https://github.com/google/eslint-config-google 使用1234npx exlint xx.js# 6 errors and 0 warnings potentially fixable with the `--fix` option.npx exlint xx.js --fix # 修正大多数格式问题 常见错误： 1:7 error ‘foo’ is assigned a value but never used no-unused-vars // 没用到10:1 error ‘syy’ is not defined no-unde // undefinedf 配置文件12345678910111213141516171819.eslintrc.jsmodule.exports = &#123; env: &#123; // 运行环境 Environment 可以同时配置多个环境 browser: true, // 浏览器 这里并不影响使用浏览器API，因为它被继承的 standard 规格覆盖了 es2020: true &#125;, extends: [ // 继承 继承了 standard 的风格 也同时可以继承多个共享配置 &apos;standard&apos; ], parserOptions: &#123; // parser Options 解析器选项 （语法解析器） ecmaVersion: 11 &#125;, rules: &#123; // 校验规则的开启和关闭 在 standard 里也开启了许多规则 &apos;no-alert&apos;: &quot;error&quot; // warn error off 警告 报错 关闭 &#125;, globals: &#123; // 最新版本默认配置中已没有再体现该选项了 &apos;jQuery&apos;: &quot;readonly&quot; &#125;&#125; 官网上有可以配置的所有的规则 配置注释 为个别违反规范的编码配置格式 123const str = '$&#123;name&#125; is a coder' // eslint-disable-line no-template-curly-in-stringconsole.log(str) eslint-disable-line 标示不检测该行，no-template-curly-in-string 不检测的规则名称（会在报错时给出） http://eslint.cn/docs/user-guide/configuring#configuring-rules ESLint 结合自动化工具 与项目统一，方便管理 gulp 完成相应的依赖安装 准备 gulp项目 完成 eslint 模块安装 创建 eslint 配置文件配置 完成 gulp-eslint 模块安装 12345678910gulpfile.jsconst script = () =&gt; &#123; return src(&apos;src/assets/script/*.js&apos;, &#123; base: &quot;src&quot; &#125;) .pipe(plugins.eslint()) // 它只能检查代码中的问题，并不能做出任何反馈 .pipe(plugins.eslint.format()) // 打印错误 .pipe(plugins.eslint.failAfterError()) // 终止管道 .pipe(plugins.babel(&#123; presets: [&apos;@babel/preset-env&apos;] &#125;)) .pipe(dest(&apos;temp&apos;)) .pipe(bs.reload(&#123; stream: true &#125;))&#125; webpack 完成相应的依赖安装 准备 webpack项目 完成 eslint 模块安装 安装 eslint-loader 模块 创建 eslint 配置文件配置 12345678rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: 'eslint-loader', enforce: 'pre' &#125;] 后续配置1234567891011121314151617181920212223242526272829303132333435363738394041424344npm install eslint-plugin-react --save-dev.eslintrc.jsmodule.exports = &#123; env: &#123; // 运行环境 Environment 可以同时配置多个环境 browser: true, // 浏览器 这里并不影响使用浏览器API，因为它被继承的 standard 规格覆盖了 es2020: true &#125;, extends: [ // 继承 继承了 standard 的风格 也同时可以继承多个共享配置 'standard' ], parserOptions: &#123; // parser Options 解析器选项 （语法解析器） ecmaVersion: 11 &#125;, rules: &#123; // 校验规则的开启和关闭 在 standard 里也开启了许多规则 'no-alert': "error", // warn error off 警告 报错 关闭 'react/jsx-uses-react': 2, // 2 error 开启检测，可以避免定义未使用的报错 'react/jsx-uses-vars': 2, &#125;, plugins: &#123; 'react' &#125;&#125;// 以继承的方式配置module.exports = &#123; env: &#123; // 运行环境 Environment 可以同时配置多个环境 browser: true, // 浏览器 这里并不影响使用浏览器API，因为它被继承的 standard 规格覆盖了 es2020: true &#125;, extends: [ // 继承 继承了 standard 的风格 也同时可以继承多个共享配置 'standard', 'plugin:react/recommended' // 继承实现后续配置 ], parserOptions: &#123; // parser Options 解析器选项 （语法解析器） ecmaVersion: 11 &#125;, rules: &#123; // 校验规则的开启和关闭 在 standard 里也开启了许多规则 'no-alert': "error", // warn error off 警告 报错 关闭 // 'react/jsx-uses-react': 2, // 2 error 开启检测，可以避免定义未使用的报错 // 'react/jsx-uses-vars': 2, &#125;, // plugins: &#123; // 'react' // &#125;&#125; 现代项目集成 ESLint vue 和 React 框架生态集成了这些规范化标准的工具。 123npm install @vue/cli -gvue create my-vue # 禁止大写字母 注意：选择配置，lint on save 表示webpack打包是调用。lint and fix on commit 表示 利用git钩子，提交时调用。（建议都进行选择 a）。 结合 typeScript 使用ESLint 配合 typescript 插件进行检查 1234npm initnpm install -g typescriptnpm install eslint --save-devnpx eslint --init 生成配置文件： 12345678910111213141516171819module.exports = &#123; env: &#123; browser: true, es2020: true &#125;, extends: [ 'standard' ], parser: '@typescript-eslint/parser', // 多了一个解析器 parserOptions: &#123; ecmaVersion: 11, sourceType: 'module' &#125;, plugins: [ '@typescript-eslint' ], rules: &#123; &#125;&#125; Stylelint 提供默认的代码检查规则，提供了 CLI 工具以供使用，通过插件实现 SASS Less PostCSS 的代码检查，支持Gulp/webpack 的集成 1234567npm install stylelint -Dnpm install stylelint-config-standard # 手动安装共享配置模块npx stylelint style.css --fix # 执行并修复部分问题npm install style-config-sass-guidelines # sass 检测模块安装 手动新建文件.stylelintrc.js： 1234567module.exports = &#123; // 它没有可继承的共享配置配置，需要自己安装 npm install stylelint-config-standard extends: [ "stylelint-config-standard", "stylelint-config-sass-guidelines" ] &#125; less 等类似 prettier 的使用 一款通用的前端代码格式化工具。 123npm install prettier -Dnpx prettier style.css --write # 默认将格式化代码打印到控制台，添加 --write 覆盖源文件npx prettier . --write # 统配所有文件 Git Hooks 介绍 问题：代码提交至仓库前未执行 lint 工作？ 利用 GIT Hooks，在提交代码之前强制执行 lint 操作。 git Hooks ，就是git的钩子，每个钩子对应一个任务。比如：commit 、push 等等。 我们可以通过 shell 脚本编写钩子任务，使其在触发时执行具体要求的执行操作。 找到文件 .git ——&gt; hooks ——&gt; pre-commit.sample 在提交代码之前会触发该钩子。 Copy 去掉 .sample 文件后缀名即可修改该文件。 编写 shell 脚本，（#!/bin/sh 指明了运行环境）。 12#!/bin/shecho "before commit" # 这样 就将命令挂载到了 提交代码之前 git init 后看不到.git文件夹，在任务管理器勾选查看 ==&gt; 隐藏文件 参考 https://cn.eslint.org/ http://stylelint.cn/ https://www.npmjs.com/package/prettier]]></content>
      <categories>
        <category>前端</category>
        <category>前端 Tool</category>
        <category>规范化 ESLint</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端 Tool</tag>
        <tag>规范化 ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化——有关于gulp对比]]></title>
    <url>%2F2020%2F08%2F12%2FAWebTool_%E8%87%AA%E5%8A%A8%E5%8C%96_gulp_grunt_FIS%2F</url>
    <content type="text"><![CDATA[自动化构建自动化构建：就是将 开发阶段产生的源代码 自动化的转换成 生产环境中可以运行的代码或程序。 自动化构建工作流： 尽可能的脱离运行环境的兼容带来的种种问题。 使用提高效率的语法、规范和标准。比如： es next、sass、模板引擎……。 自动化构建工具：就是将浏览器不能直接支持的以上的特性，转换为能够执行的代码。 终极目标就是提高我们的编码效率。 NPM Scripts解决重复调用命令的问题。在 package.json 的 scripts 字段配置。 12345678// 配置命令，当在命令行运行时，它会自动在 ./node_module/bin/[module_name] 中找。"scripts": &#123; "build": "sass scss/main.scss css/style.css --watch", // --watch 会监听变化自动编译 "preserve": "npm run build", // preserve 会在运行serve之前运行 build // --file 监听文件变化自动更新浏览器文件，省略刷新 "serve": "browser-sync --files \"css/*.css\"", // 自动起一个 web 服务器 "start": "run-p build serve" // build 和 serve同时执行 &#125;, npm run dev / yarn dev。 npm install browser-sync --save-dev。 npm install npm-run-all --save-dev，为了并行执行命令。 npx原理在运行的时候，会到 node_modules/.bin 路径和环境变量 $PATH 里检查命令是否存在。所以系统命令也可以调用： 12$ npx ls# 等同于 ls 注意，Bash 内置的命令不在$PATH里面，所以不能用。比如，cd是 Bash 命令，因此就不能用npx cd。 调用项目安装的模块举例，项目中安装了Mocha，一般是在 package.json 的 scripts 字段里配置，如果要在命令行下调用就可以使用 npx： 12345# 原本在命令行中调用$ node-modules/.bin/mocha --version# 利用 npx$ npx mocha --version 避免全局安装模块npx 会将全局安装的模块下载到一个临时目录，使用后删除，并且允许指定版本，比如： 12345# 运行 全局模块 create-react-app$ npx create-react-app my-react-app# 指定 uglify-js 版本$ npx uglify-js@3.1.0 main.js -o ./dist/main.js 只要 npx 后面的模块无法在本地发现，就会下载同名模块。 --no-install 参数和 --ignore-existing 参数--no-install：强行使用本地模块，不下载远程。 1$ npx --no-install http-server --ignore-existing：忽略本地模块，强制安装远程模块。 1$ npx --ignore-existing create-react-app my-react-app 使用不同版本的 node12$ npx node@12.18.3 -v# 使用 node 12.18.3 版本执行 -v 命令 -p 参数1234$ npx -p node@12.18.3 node -v# 同上$ npx -p lolcatjs -p cowsay [command]# 安装多个模块场景 -c 参数如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。 参数可以将所有命令都用 npx 解释。 可以将环境变量带入所要执行的命令。 执行 GitHub 源码12345# 执行 Gist 代码$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32# 执行仓库代码$ npx github:piuccio/cowsay hello 注意，远程代码必须是一个模块，即必须包含package.json和入口脚本。 常用的自动化构建工具Grunt、Gulp、FIS（自动化构建工具） Webpack（严格意义上是模块打包工具） 对比： Grunt 出现的早，生态完善。 构建过程基于临时文件，磁盘读写操作频繁，构建速度较慢。 Gulp 基于内存实现，速度快。 默认支持同时执行多个任务。 使用方式易懂。 流行，论坛参与度高。 FIS 微内核，封装大而全，适合初学者。 Grunt简单使用123npm init --yes npm install grunt # ???code gruntfile.js # 定义需要 grunt 自动执行的任务 配置 gruntfile.jsgrunt.registerTask API 注册任务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// g 需要导出一个函数，内部提供创建任务的 APImodule.exports = grunt =&gt;&#123; grunt.registerTask('foo', ()=&gt;&#123; // 任务名字，任务函数 console.log('hello grunt-') &#125;) grunt.registerTask('bar', '任务描述', ()=&gt;&#123; // 任务名字，任务描述, 任务函数 console.log('hello task-') &#125;) // grunt.registerTask('default', '任务描述', ()=&gt;&#123; // 自动调用 // console.log('hello default-') // &#125;) grunt.registerTask('default', ['foo', 'bar']) // 自动调用指定任务 // grunt.registerTask('async-task', () =&gt; &#123; // 无法运行 // setTimeout(() =&gt; &#123; // console.log('async task working-') // &#125;, 1000) // &#125;) grunt.registerTask('async-task', function ()&#123; const done = this.async() setTimeout(() =&gt; &#123; console.log('async task working-') done() &#125;, 1000) &#125;) // ========= 标记任务失败，不影响接下来的任务的执行 grunt.registerTask('bad',function() &#123; console.log('i am bad-') return false // 标记任务失败 &#125;) grunt.registerTask('afterBad',['foo','bad','bar']) // `grunt default --force` # 强制执行所有任务，错误下面的也会执行 grunt.registerTask('async-task1', function ()&#123; const done = this.async() // ? setTimeout(() =&gt; &#123; console.log('async task1 working-') done(false) // 异步任务标记失败 &#125;, 1000) &#125;)&#125; grunt.initConfig API 配置选项方法123456789101112grunt.initConfig(&#123; foo: 'FOO 配置对象？？？', foo1: &#123; bar1: 123456 &#125;&#125;)grunt.registerTask('initConfigFOO',() =&gt; &#123; const init = grunt.config('foo') // grunt.config 获取 grunt.initConfig 值 const init1 = grunt.config('foo1') console.log(init,init1.bar1)&#125;) grunt.registerMultiTask API 构建多目标任务1234567891011121314151617181920212223// ================== 多目标任务模式，可以让任务根据配置形成多个子任务grunt.initConfig(&#123; multiTask: &#123; // 多目标任务模式，相当于以多个子任务进行 options:&#123; // 其它的 key值 作为子目标，options 选项则作为任务的配置项 foo: 'bar' &#125;, css: &#123; options: &#123; foo: 'css bar' // 会覆盖掉 上一个options &#125; &#125;, js: '2' &#125;&#125;)grunt.registerMultiTask('multiTask',function()&#123; console.log('Muli Task _') // 相当于执行了两遍，每一遍的 this 都是当前的子任务 console.log(`target:$&#123;this.target&#125;, data:$&#123;this.data&#125;`) console.log(this.options()) // 拿到配置项&#125;) Grunt插件简单使用大多任务都是通用的（压缩代码等等），因此 Grunt 的插件是 Grunt 的核心。 安装： 12# grunt-contrib-clean 自动清除开发过程中产生的临时文件npm install grunt-contrib-clean gruntfile.js 引入使用 123456789module.exports = grunt =&gt;&#123; grunt.loadNpmTasks('grunt-contrib-clean') grunt.initConfig(&#123; clean: &#123; temp: 'temp/*.txt' // 需要配置清除路径 &#125; &#125;)&#125; 运行： 1npm run grunt clean # npm run 是因为我配置到了npmScript里了 常用插件Sassnpm grunt-sass，依赖 npm 使用 sass，好处是对环境的依赖少。 1npm install grunt-sass sass --dev 使用： 1234567891011121314151617const sass = require('sass')module.exports = grunt =&gt; &#123; grunt.initConfig(&#123; sass: &#123; options: &#123; sourceMap: true, // 自动生成 sourceMap 文件 implementation: sass // 表示使用哪个模块编译 &#125;, main: &#123; files: &#123; 'dist/css/main.css': 'src/scss/main.scss' &#125; &#125; &#125; &#125;) grunt.loadNpmTasks('grunt-sass')&#125; 运行： 1npm run grunt sass https://www.npmjs.com/package/grunt-sass babel安装：依赖babel核心模块和预设 123npm install grunt-babel @babel/core @babel/preset-env --save-devnpm install load-grunt-tasks --dev # 随着loadNpmTasks 增多，这是一个简化的工具 使用： 123456789101112131415161718192021222324252627282930const sass = require('sass')const loadGruntTasks = require('load-grunt-tasks')module.exports = grunt =&gt; &#123; grunt.initConfig(&#123; sass: &#123; options: &#123; sourceMap: true, // 自动生成 sourceMap 文件 implementation: sass // 表示使用哪个模块编译 &#125;, main: &#123; files: &#123; 'dist/css/main.css': 'src/scss/main.scss' &#125; &#125; &#125;, babel: &#123; options: &#123; sourceMap: true, presets: ['@babel/preset-env'] // 根据最新的特性进行转换 &#125;, main: &#123; files: &#123; // 输入输出文件 'dist/js/main.js': 'src/js/main.js' &#125; &#125; &#125; &#125;) // grunt.loadNpmTasks('grunt-sass') loadGruntTasks(grunt) &#125; https://www.npmjs.com/package/grunt-babel https://www.npmjs.com/package/load-grunt-tasks 热更新（自动编译）安装：文件改变，自动编译 1npm install grunt-contrib-watch --save-dev 使用： 1234567891011121314151617181920212223242526272829303132333435363738394041const sass = require('sass')const loadGruntTasks = require('load-grunt-tasks')module.exports = grunt =&gt; &#123; grunt.initConfig(&#123; sass: &#123; options: &#123; sourceMap: true, // 自动生成 sourceMap 文件 implementation: sass // 表示使用哪个模块编译 &#125;, main: &#123; files: &#123; // 输入输出文件 'dist/css/main.css': 'src/scss/main.scss' &#125; &#125; &#125;, babel: &#123; options: &#123; sourceMap: true, presets: ['@babel/preset-env'] // 根据最新的特性进行转换 &#125;, main: &#123; files: &#123; // 输出输入文件 'dist/js/main.js': 'src/js/main.js' &#125; &#125; &#125;, watch: &#123; js: &#123; files: ['src/js/*.js'], // 所要监视的文件 tasks: ['babel'] &#125;, css: &#123; files: ['src/scss/*.scss'], tasks: ['sass'] &#125;, &#125; &#125;)loadGruntTasks(grunt) grunt.registerTask('default', ['sass', 'babel', 'watch']) // 做映射，确保在启动时先执行一次编译&#125; 运行： 123npm run grunt watch # npm run grunt # 做完映射后命令 https://www.npmjs.com/package/grunt-contrib-watch Gulp基本使用安装 根据官网安装 123npm init --yesnpm install gulp --dev # 同时安装了 gulpClicode gulpfile.js # 定义需要 grunt 自动执行的任务 Gulpfile内容gulpfile.js 文件，在执行 gulp 命令时都会被自动加载，这里面会写着 gulpAPI，还有纯 js 或 node 模块，以及任何导出（export）的函数都将注册到 gulp 的任务（task）系统中。 其它语言使用其它转译语言，安装模块后使用： 对于 TypeScript，重命名为 gulpfile.ts 并安装 ts-node 模块。 对于 Babel，重命名为 gulpfile.babel.js 并安装 @babel/register 模块。 模块化随着项目增大，使用 import 分割。 示例1234567function defaultTask(cd) &#123; // please code for your default task here console.log('i am gulp') cd() // 不写回调会报提示，因为最新版取消了同步模式，需要用回调标记完成&#125;exports.default = defaultTask // default 默认任务 gulp 自动运行 约定每个任务为异步任务 gulp 4.0之前：(已不推荐) 12345const gulp = require('gulp')gulp.task('bar', done =&gt; &#123; console.log('bar workig~') done()&#125;) Task导出任务 公开私有只是设计上导出和未导出的区别而已 公开任务从 gulpfile 中被导出（export），可以通过 gulp 命令直接调用。 私有任务被设计为在内部使用，通常作为 series() 或 parallel() 组合的组成部分。 组合任务顺序执行（串行模式）使用 series() ，并发执行使用 parallel()。 1234567891011121314151617181920212223const &#123;series, parallel&#125; = require('gulp')function task1(done)&#123; setTimeout(()=&gt;&#123; console.log('task1') &#125;, 1000) done()&#125;function task2(done)&#123; setTimeout(()=&gt;&#123; console.log('task2') &#125;, 1000) done()&#125;function task3(done)&#123; setTimeout(()=&gt;&#123; console.log('task3') &#125;, 1000) done()&#125;exports.task = series(task1, task2, task3)exports.taskP = parallel(task1, task2, task3) 异步执行 新版 gulp 不再支持同步任务 ，不使用以下几种方式，会发出 “Did you forget to signal async completion?” 警告 。 Node 库以多种方式处理异步功能。最常见的模式是 error-first callbacks，但是你还可能会遇到 streams、promises、event emitters、child processes, 或 observables。gulp 任务（task）规范化了所有这些类型的异步功能 （？？？） 常用的几种任务（task）完成通知： callback 123456789101112function callback (cb) &#123; console.log('callback') cb()&#125;exports.callback = callback// 错误优先 （一种标准）function callback_error (cb) &#123; console.log('callback_error') cb(new Error('i am error')) // 同时会阻塞后续任务&#125;exports.callback_e = callback_error promise 12345678910111213// promisefunction callback_promise () &#123; console.log('callback_promise') return Promise.resolve('resolve of promise') // gulp 会忽略掉这里传的值&#125;exports.callback_p = callback_promise// rejectfunction callback_promise_r () &#123; console.log('callback_promise') return Promise.reject(new Error(failed)) // gulp 会忽略掉这里传的值&#125;exports.callback_pr = callback_promise_r async/await （node 8版本以上可用） 1234567891011121314// async awaitfunction setTime(time)&#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve,time) &#125;)&#125;async function async()&#123; await setTime(1000) console.log('async await -')&#125;exports.callback_a = async 流操作，结束时机是 return readStream 触发了Stream中的 end() 事件 12345678const fs = require('fs')function callback_stream ()&#123; const readStream = fs.createReadStream('package.json') const writeStream = fs.createWriteStream('json.txt') readStream.pipe(writeStream) // 相当于从一个池子往另一个池子倒水, 起到文件复制的作用 return readStream&#125;exports.callback_s = callback_stream 模拟： 12345678function callback_stream (done)&#123; const readStream = fs.createReadStream('package.json') const writeStream = fs.createWriteStream('json.txt') readStream.pipe(writeStream) // 相当于从一个池子往另一个池子倒水, 起到文件复制的作用 readStream.on('end', () =&gt; &#123; done() &#125;)&#125; 构建过程及原理 The streaming build system 基于流的构建系统 总体步骤：输入——加工——输出。比如：读取文件——压缩文件——写入文件。 例，简单的压缩实现 12345678910111213141516171819202122232425// 读取流 转换流 写入流const fs = require('fs')function myCompress()&#123; // 文件读取流 const read = fs.createReadStream('normalize.css') // 文件写入流 const write = fs.createWriteStream('normalize.min.css') // 文件转化流 const transform = new Transform(&#123; transform: (chunk, encoding, callback) =&gt; &#123; // 转换过程实现 // chunk 可以拿到读取流中读取到的内容（Buffer） const input = chunk.toString() // 读出来是一个字节数组，因此要转换成字符串 const output = input.replace(/\s+/g,'').replace(/\/\*.+?\*\//g,'') // 替换掉空白格和注释 callback(null, output) // 这是个错误优先的回调函数，没有错误对象传空null &#125; &#125;) // 把读取的文件流导出写入文件流 read .pipe(transform) // 转换 .pipe(write) // 写入 return read&#125;exports.callback_m = myCompress 文件操作的API 文件操作的API及插件的使用，相对于node封装的更加强大 src()：创建一个流，用于从文件系统读取 Vinyl 对象。 利用插件转换。 dest()：创建一个用于将 Vinyl 对象写入到文件系统的流。destination缩写，目标位置。 123# 装 css 转换流插件npm install gulp-clean-css --save-devnpm install gulp-rename --save-dev gulpfile.js： 1234567891011const &#123;src, dest&#125; = require('gulp') // 引入const cssClean = require('gulp-clean-css')const rename = require('gulp-rename')function srcAndDist() &#123; return src('src/*.scss') .pipe(cssClean()) .pipe(rename(&#123;extname: '.min.css'&#125;)) .pipe(dest('dist'))&#125;exports.sad = srcAndDist 自动化构建工作流（案例）样式1234# 装 css 转换流插件npm install gulp-clean-css --save-devnpm install gulp-rename --save-devnpm install gulp-sass --save-dev # node-sass 部分依赖于国外，需要配置镜像源 引入 sass 编译 12345678910111213const &#123;src, dest&#125; = require('gulp') // 引入const cssClean = require('gulp-clean-css')const rename = require('gulp-rename')const sass = require('gulp-sass')function srcCSS() &#123; return src('src/*.scss') // sass会忽略掉 ‘_’ 开头的文件，参数可以指定输出样式 .pipe(sass(&#123; outputStyle: 'expanded' &#125;)) .pipe(cssClean()) .pipe(rename(&#123;extname: '.min.css'&#125;)) .pipe(dest('dist'))&#125; 脚本12npm install gulp-babel --save-devnpm install gulp-babel @babel/core @babel/preset-env --save-dev 引入： 1234567const babel = require('gulp-babel')function script () &#123; return src('src/js/*.js', &#123;base: 'src'&#125;) // @babel/preset-env 是转换打包的集合，没有配置会没有效果 .pipe(babel(&#123; presets: ['@babel/preset-env'] &#125;)) .pipe(dest('dist'))&#125; 模板1npm install gulp-swig --save-dev 引入： 12345678910const swig = require('gulp-swig')const data = &#123; // 模拟数据 hello: '你好'&#125;function page()&#123; // ** 表示src任意子目录下的 html 文件 return src('src/**.html', &#123;base:'src'&#125;) .pipe(swig(&#123;data&#125;)) .pipe(dest('dist'))&#125; 组合1234567891011// 组合const &#123;series, parallel&#125; = require('gulp')const compile = parallel(srcCSS, script, page)module.exports = &#123; srcAndDist, script, page, image, font, compile&#125; 字体/图片图片12# 依赖模块涉及c++，需要下载二进制程序集，大多在github，无法配置镜像，需要使用其它方式npm install gulp-imagemin --save-dve 引入： 123456const imagemin = require('gulp-imagemin')const image = () =&gt; &#123; return src('src/assets/images/**', &#123;base: 'src'&#125;) .pipe(imagemin()) .pipe(dest('dist'))&#125; 字体12345const font = () =&gt; &#123; return src('src/assets/font/**',&#123;base: 'src'&#125;) .pipe(imagemin()) .pipe(dest('dist'))&#125; 额外文件1234567const extra = () =&gt; &#123; // 额外文件打包 return src('public/**', &#123; base: 'public' &#125;) .pipe(dest('dist'))&#125;const compile = parallel(style, script, page, image, font)const build = parallel(compile, extra) 自动清除目录文件1npm install del --save-dev 引入： 12345const del = require('del')const clean = () =&gt; &#123; return del(['dist']) // 返回的是一个 promise 对象&#125;const build = series(clean, parallel(compile, extra)) // 需要串行进行 del 不是 gulp 的插件，但是可以在 gulp 中使用 自动加载插件汇总 require 操作 1npm install gulp-load-plugins --save-dev 引入： 123const loadPlugins = require('gulp-load-plugins')const plugins = loadPlugins()// 使用到插件的地方需要全部改为 plugins.sass...不需要 require,可自动加载 热更新开发服务器1npm install browser-sync --save-dev 相对与 express 开发的普通的web服务器，它功能更强大支持热更新等 引入： 12345678910111213141516171819const browserSync = require('browser-sync')const bs = browserSync.create() // 创建const serve = () =&gt; &#123; bs.init(&#123; notify: false, port: 2080, // opent: false, files: 'dist/**', server: &#123; baseDir: 'dist', // 指定监听文件 routes: &#123; '/node_modules' : 'node_modules' &#125; &#125; &#125;)&#125;module.exports =&#123; serve&#125; 监听变化构建优化调用 gulp watch API 对文件进行监视 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const &#123;watch&#125; = require('gulp')const browserSync = require('browser-sync')const bs = browserSync.create() // 创建const serve = () =&gt; &#123; // 文件改变触发相应的编译任务，再进行热更新 watch('src/assets/styles/*.scss', style) watch('src/assets/scripts/*.js', script) watch('src/*.html', page) // watch('src/assets/images/**', image) // watch('src/assets/fonts/**', font) // watch('public/**', extra) watch([ 'src/assets/images/**', 'src/assets/fonts/**', 'public/**', ], bs.reload) bs.init(&#123; notify: false, port: 2080, // opent: false, files: 'dist/**', // 也可以在每个任务中使用 .pipe(bs.reload(&#123;stream: ture&#125;)) server: &#123; // 指定监听文件 找不到依次向后找 baseDir: ['dist', 'src', 'public'], // src public 只是拷贝不影响呈现，因此开发阶段直接使用源文件，加快编译效率 routes: &#123; '/node_modules' : 'node_modules' // 开发阶段为三方做了路由映射 &#125; &#125; &#125;)&#125;// 子任务const compile = parallel(style, script, page)// 上线之前执行任务const build = series(clean, parallel(compile, image, font, extra))// 开发阶段热更新const develop = series(compile, serve)module.exports =&#123; compile, build, develop&#125; 页面缓存的机制导致swig不发生变化？？？swig 选项 cache 设置为 false useref 解决文件引用问题问题： 12&lt;!-- 开发环境使用的 node_module 文件并不能引入到生产环境问题 --&gt;&lt;link rel="stylesheet" href="/node_module/bootstrap/dist/css/bootstrap.css"&gt; 安装： 1npm install gulp-useref --save-dev 引入： 1234567891011const useref = () =&gt; &#123; return src('dist/*.html', 'dist') .pipe(plugins.useref(&#123; searchPath: ['dist', '.']&#125;)) // dist 根目录下面找 // 生成新的文件可以在此处写入其它操作：压缩等 .pipe(dest('dist'))&#125;module.exports = &#123; // ... useref&#125; 解决： 123&lt;!-- build:css assets/styles/vendor.css --&gt;&lt;link rel="stylesheet" href="/node_module/bootstrap/dist/css/bootstrap.css"&gt;&lt;!-- endbuild --&gt; 结果： 12&lt;!-- 它会将 build 标记的内容全部合并到指定的路径里并引用 --&gt;&lt;link rel="stylesheet" href="assets/styles/vendor.css"&gt; 文件压缩安装： 1234npm install gulp-htmlmin --save-dev # htmlnpm install gulp-uglify --save-dev # jsnpm install gulp-clean-css --save-dev # cssnpm install gulp-if --save-dev 使用： 123456789101112131415161718const useref = () =&gt; &#123; return src('dist/*.html', 'dist') .pipe(plugins.useref(&#123; searchPath: ['dist', '.']&#125;)) // dist 根目录下面找 .pipe(plugins.if(/\.js$/, plugin.uglify())) .pipe(plugins.if(/\.css$/, plugin.cleanCss())) .pipe(plugins.if(/\.html$/, plugin.htmlmin(&#123; collapseWhitespace: true, // 折叠空白格 minifyCSS: true, // 压缩行内css minifyJS: true // 压缩行内JS ... &#125;))) // .pipe(dest('dist')) 解决读写冲突问题 .pipe(dest('release'))&#125;``module.exports = &#123; // ... useref&#125;// 先执行 compile 再执行 useref 解决重建目录问题 问题：为了解决读写冲突，我们将压缩文件放入到了 release 文件，但是与原来静态资源的位置不一致 解决： 将原本读取到 dist 文件的文件放入到临时文件 temp 文件中，在 useref 中从临时文件 temp 中读取到 dist文件中 补充 暴露必要接口。 写进 package.json 的 scripts 属性。 .gitignore 忽略掉临时文件，比如：temp/dist。 封装自动化构建工作流问题：gulpfile.js 公用在多个项目当中，当修改 gulpfile.js 或升级配置时，需要修改多个文件。 提取多个项目共同的自动化构建过程：利用 CLI + gulpfile.js FIS3123npm install fis3 --save-devnpm run fis3 release # https://fis.baidu.com/ 问题全局配置 https://segmentfault.com/a/1190000012505272 https://blog.csdn.net/HuangsTing/article/details/89134874 123npm get config profix*******npm set config profix ******* npm科学上网npm 科学上网导致的问题 https://segmentfault.com/a/1190000022881608 参考 https://www.gulpjs.com.cn/docs/getting-started/quick-start/ https://www.ruanyifeng.com/blog/2019/02/npx.html https://www.npmjs.com/package/npx https://fis.baidu.com/]]></content>
      <categories>
        <category>前端</category>
        <category>前端 Tool</category>
        <category>自动化 gulp</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端 Tool</tag>
        <tag>自动化 gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程化CLI——Yeoman与plop]]></title>
    <url>%2F2020%2F08%2F05%2FAWebTool_%E5%B7%A5%E7%A8%8B%E5%8C%96Cli_yeoman_plop%2F</url>
    <content type="text"><![CDATA[工程化解决的问题 转译新特性语言。 使用CSS预编译。 使用模块化，组件化。 手动压缩代码及资源，手动部署。 多人协同开发，无法硬性统一大家的代码风格。 从仓库pull下来的代码质量无法保证。 部分前端开发需要等待后端服务接口提前完成。 语言、模块组件化、自动化、风格质量保证、与后端解耦 一般流程 创建项目阶段——编码阶段——预览测试阶段——提交阶段——部署阶段 创建项目阶段：创建项目结构、特定类型文件 编码阶段：格式化代码、校验代码、编译构建打包 预览测试阶段：webServer（阿帕奇、Nginx）、MOCK（模拟后端接口）、Live Reloading、HMR、Source Map（定位源代码问题使用） 提交阶段：Git Hooks、Lint-staged、持续集成（提交检查，风格质量，提交日志等检查） 部署阶段：CI/CD 自动上传发布 脚手架作用根据信息创建对应的项目基础结构。（特定文件及配置） Yeoman：通用性项目脚手架工具。 Plop：用于创建特定类型的文件，例如：创建一个组件、模块所需要的文件。 常用工具Yeoman基于 node 通用脚手架工具，可利用其 generator 创造自己的脚手架工具。 安装入门 https://yeoman.io/learning/ 1234567891011# 全局安装 yonpm install -g yo# 全局安装 generator-node 模块，用例使用npm install -g generator-node # 不同的 generator 生成不同的项目 # 创建 my-module 文件作为根目录mkdir my-module# 运行 generator-node 模块yo node 输入选择 12345678910111213# 创建选择? Module Name azhong? Description learn yo? Project homepage url https://f-lancer.github.io? Author's Name azhong? Author's Email ? Author's Homepage https://f-lancer.github.io? Package keywords (comma to split) module,node? Send coverage reports to coveralls Yes? Enter Node versions (comma separated) ? Enter Node versions (comma separated) ? GitHub username or organization ? Which license do you want to use? MIT 基本使用Sub Generator （模块子集） 在已有项目上添加特定的配置文件，比如 .babelrc、.eslintrc 等文件。 1234# 利用 node 子集的 cli，将项目变成 cli 应用yo node:cli? Overwrite package.json? overwrite # 是否重写该文件 generator-node 子集：https://github.com/yeoman/generator-node 通用步骤 明确需求。 合适的 generator。 全局安装。 yo 命令运行。 命令交互行填写。 生成项目结构。 webapp：https://yeoman.io/learning/ 自定义 Generator 创建 Generator 本质上是创建一个 npm 模块 Generator 基本结构普通结构： 1234|————generators/ ......生成器目录| |————app/ ......默认生成目录| |————index.js ......默认生成器实现|————package.json ......模块包配置文件 带子生成器的结构： 123456|————generators/ ......生成器目录| |————app/ ......默认生成目录| | |————index.js ......默认生成器实现| |————component/ ......其它生成器目录| |————index.js ......其它生成器实现|————package.json ......模块包配置文件 名称格式：generator-&lt;name&gt; 实施 创建文件 generator-sample ，安装 yeoman-generator。 123mkdir generator-sample npm initnpm install yeoman-generator # 提供了生成器基类，基类中提供了工具函数 文件 generator-sample 内 构建基本结构 1234|————generators/ ......生成器目录| |————app/ ......默认生成目录| |————index.js ......默认生成器实现|————package.json ......模块包配置文件 index.js 中写入简单功能 123456789101112131415// 此文件 是 Generator 的核心入口，需要导出一个继承自 Yeoman Generator 的类型// Yeoman Generator 其中的一些生命周期函数会被自动调用，我们可以在这些生命周期中调用// 父类提供的一些工具方法实现一些功能，例如文件写入const Generator = require('yeoman-generator')module.exports = class extends Generator &#123; writing () &#123; // Yeoman 自动生成文件阶段调用此方法 // 这里尝试往项目目录中写入文件 this.fs.write( this.destinationPath('temp.txt'), Math.random().toString() ) &#125;&#125; link 到全局 1234567npm link # link到全局，使之成为一个全局模块包，可以在全局使用cd ..mkdir my-proj # 构建新的项目cd my-projyo sample # 使用 结果会在 my-proj 文件中生成一个新的temp.txt文件 根据模板创建文件因为我们创建文件一般比较多且复杂，因此我们可以根据模板模板创建文件 结构改变： 123456|————generators/ ......生成器目录| |————app/ ......默认生成目录| |————templates| |————foo.txt ....模板文件| |————index.js ......默认生成器实现|————package.json ......模块包配置文件 这是个模板文件，所有的模板文件都可以放到这个 templates 文件夹下，内部可以使用 EJS 模板标记语法输出数据 写模板文件foo.txt： 1234561. 这是个模板文件，所有的模板文件都可以放到这个 templates 文件夹下2. 内部可以使用 EJS 模板标记语法输出数据&lt;%= title %&gt;&lt;% if(!success) &#123;%&gt;success 成功了&lt;%&#125;%&gt; 入口文件index.js改变： 1234567891011121314const Generator = require('yeoman-generator')module.exports = class extends Generator &#123; writing () &#123; // 模板文件路径 const temp = this.templatePath('foo.txt') // 输出目标路径 const output = this.destinationPath('foo.txt') // 模板数据上下文 const context = &#123;title: 'hello', success: false&#125; // 会自动将模板文件映射到输出文件 this.fs.copyTpl(temp, output , context) &#125;&#125; 运行 1yo sample 接收用户输入使用 prompting 在命令行中和用户交互： 1234567891011121314151617181920212223242526272829303132const Generator = require('yeoman-generator')module.exports = class extends Generator &#123; prompting() &#123; // Yo 在询问用户输入时会调用该方法 // 此方法会调用父类里的 prompt 方法发出对用户的命令行询问 return this.prompt([ // return 是为了后面更好的异步流程控制 &#123; type: 'input', // 类型 name: 'name', // 最终得到的键 message: 'Your project name', // 用户提示信息 default: this.appname // 默认为当前文件夹名字 &#125; ]) .then(answers =&gt; &#123; // answers =&gt; &#123; name: 'user input value' &#125; this.answers = answers &#125;) &#125; writing () &#123; // 模板文件路径 const temp = this.templatePath('foo.txt') // 输出目标路径 const output = this.destinationPath('foo.txt') // 模板数据上下文 // const context = &#123;title: 'hello', success: false&#125; // 会自动将模板文件映射到输出文件 this.fs.copyTpl(temp, output , this.answers) &#125;&#125; Vue Generator 案例 结构： 1234567|————generators/ ......生成器目录| |————app/ ......默认生成目录| |————templates| |————.vue ....vue项目结构| |————.... ....其它模板文件| |————index.js ......默认生成器实现|————package.json ......模块包配置文件 index.js 生成器入口： 12345678910111213141516171819202122232425262728293031323334353637const Generator = require('yeoman-generator')module.exports = class extends Generator &#123; prompting() &#123; // Yo 在询问用户输入时会调用该方法 // 此方法会调用父类里的 prompt 方法发出对用户的命令行询问 return this.prompt([ // return 是为了后面更好的异步流程控制 &#123; type: 'input', // 类型 name: 'name', // 最终得到的键 message: 'Your project name', // 用户提示信息 default: this.appname // 默认为当前文件夹名字 &#125; ]) .then(answers =&gt; &#123; // answers =&gt; &#123; name: 'user input value' &#125; this.answers = answers &#125;) &#125; writing () &#123; // 把每个文件都通过模板转换到目标路径 const templates = [ // template 绝对路径 'x.vue', 'y.js', 'README' //'...' ] templates.forEach(item =&gt; &#123; // 将 用户输入的answers循环至每个用到的模板文件 this.fs.copyTpl( this.templatePath(item), this.destinationPath(item), this.answers ) &#125;) &#125;&#125; 实际上就是一个利用一些 Generator API 将用户输入的，利用 EJS 模板替换到项目需要自定义的地方，从而使其可以复用。 发布 Generator 实际上就是发布一个 npm 模块。 源代码托管到仓库： 123456789101112131415161718192021echo node_modules &gt; .gitignore # 创建忽略文件git init # 初始化本地空仓库git status # 查看状态git add . # 当前目录所有下文件git commit -m 'feat:initial commit' # 创建一次提交# 到远端仓库创建一个新的仓库 获取远端仓库地址git remote add origin https://github... # 添加远端 origin 别名git push -u origin master # 推送到远端npm push # 发布npm publish --registry=https://... # 淘宝镜像报错默认使用官方镜像# 添加关键词使得 yeoman 可见 plop精小的脚手架工具，一般会集成到项目中，用来创建相同类型的项目文件。 场景在创建新组建时会需要新建同类型的文件、文件结构及基础代码，我们可以使用 plop 来帮我们做这件事。 基本使用 安装 1npm install plop --dev # 开发依赖 新建并配置 plopfile.js。 123456789101112131415161718192021222324252627282930module.exports = plop =&gt; &#123; plop.setGenerator('component', &#123; description: 'create a component', prompts: [ &#123; type: 'input', name: 'name', message: 'component name' default: 'MyComponent' &#125; ], actions: [ &#123; type: 'add', path: 'src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js', templateFile: 'plop-templates/component.hbs' &#125;, &#123; type: 'add', path: 'src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.css', templateFile: 'plop-templates/component.css.hbs' &#125;, &#123; type: 'add', path: 'src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.test.js', templateFile: 'plop-templates/component.test.hbs' &#125;, ] &#125;)&#125; 运行 1npm plop component 总结 安装 —— 创建配置 plopfile.js文件 —— 编写配置模板 —— 运行plop提供的脚手架工具 脚手架工作原理 本质上是创建一个 CLI 应用 建立简单的 CLI 应用：azhongCli 初始化123mkdir azhongClicd azhongClinpm init 指定入口文件： 12345678910111213&#123; "name": "azhongcli", "version": "1.0.0", "description": "", "main": "index.js", "bin":"cli.js", // 添加bin字段，指定入口文件为 cli.jss "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "azhongcli": "azhongcli" &#125;, "author": "", "license": "ISC"&#125; 注意入口文件 cli.js 文件头 1#!/usr/bin/env node link到全局失败.. 12npm link ./npm run azhongcli # link 到本地配置 scripts字段 构建 通过命令行交互询问用户问题。 根据用户回答结果生成文件。 12npm install inquirer # 命令行npm install ejs # 模板引擎 写入12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env node// Node CLI 应用入口文件必须要有这样特定的文件头，// 如果是 LINUX 或者 macOS还需要修改此文件的读写权限为 755，通过 chmod 755 cli.js实现修改// 脚手架工作过程：// 1. 通过命令行交互询问用户问题// 2. 根据用户回答生成文件const inquirer = require('inquirer') // 用来进行命令行交互const ejs = require('ejs')const path = require('path')const fs = require('fs')inquirer.prompt([ &#123; type: 'input', name: 'name', massage: 'Project name?' &#125;]).then(answers=&gt;&#123; // 拿到模板目录 const tmplDir = path.join(__dirname, 'templates') // 目标目录 const destDir = process.cwd() // 命令行执行的目录 // 读取输出到目标目录 fs.readdir(tmplDir, (err, files) =&gt; &#123; if(err) throw err files.forEach(file=&gt;&#123; ejs.renderFile(path.join(tmplDir, file), answers, (err, result) =&gt; &#123; if (err) throw err fs.writeFileSync(path.join(destDir, file), result) console.log(destDir) &#125;) &#125;) &#125;)&#125;) 参考 https://yeoman.io/authoring/user-interactions.html]]></content>
      <categories>
        <category>前端</category>
        <category>前端 Tool</category>
        <category>工程化CLI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端 Tool</tag>
        <tag>工程化CLI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析安全问题]]></title>
    <url>%2F2020%2F07%2F28%2FWeb_Security%2F</url>
    <content type="text"><![CDATA[XSS攻击概述Cross-site script，跨站脚本攻击。 XSS攻击就是允许攻击者上传任意HTML文件到你的网站，恶意加载执行文件，造成网站丑化或导致用户账号被盗用等。 来自 用户的UGC信息（User Generated Content 用户生成信息）。 来自第三方的链接 URL参数 POST参数 Referer（Referer 请求头包含了请求页面的来源地址，可能来自不信任来源） Cookie（可能来自其它子域注入） Types Of XSS存储式 XSS 漏洞（stored XSS）、反射式漏洞（reflected XSS）、基于DOM的（DOM-based XSS）。 类型 存储区 插入点 存储型 XSS 后端数据库 HTML 反射型 XSS URL HTML DOM 型 XSS 后端数据库/前端存储/URL 前端 JavaScript stored XSS允许用户存储数据的web应用容易遭受的存储式攻击。 用户在输入的地方输入js等非法代码，服务器未经验证就存储，再次返回给客户时就可以被利用了。浏览器无法辨别，响应执行，恶意代码窃取用户的数据并发送到攻击者网站，或冒充用户行为，调用目标网站接口执行攻击者指定操作。 输入用户名等时。 在论坛的新帖子输入html,然后论坛将其提供给他人。 商品评论，用户私信。 reflected XSS诱骗用户点击恶意链接或诱导客户提交一个伪造表单，将代码注入web服务器，服务端将恶意代码从URL中取出，拼接在 HTML 中返回给浏览器。 email 社交软件，服务器包含注入代码回复返回，浏览器会执行注入的代码 DOM-based XSS这种攻击针对有漏洞的客户端侧 JS ，web服务器一开始就没见到恶意注入的代码，取出和执行恶意代码都是由浏览器端完成的，但是具有同样的攻击效果。 但是它仍然可以窃取登陆凭证，或诱骗受害者下载恶意软件，攻击的后果相当于有人黑进了FTP服务器，上传自己的HTML。 预防XSS难以防范的主要原因是页面中会出现以下上下文：html元素、属性 js 、css、 url。 控制输入控制输入，对规则数据进行输入校验，比如电话号码中只能是数字及邮件地址等格式是固定的。 但是输入并不是只有那些可见的输入框和url，还可能融入比如cookie，上传文件的文件名，HTTP头，参数名等。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。 输入存储转义在存储到数据库前进行转义。 但是无法确定输出这些数据会被用在哪里，如果作为页面在html文件里拼接可以正常显示，但是当通过js赋值给字符串等无法转义回来的地方时，就会产生乱码问题。 纯前端渲染先加载一个静态 HTML（无业务数据），执行 JS，通过 AJAX 加载数据，调用 DOM API更新页面。浏览器会自己判断该在哪里插入什么，而不是直接将拼接好的扔给它。 但是： 纯前端渲染要避免 DOM-based XSS~。 纯前端适合内部等管理系统，但是对于优化性能及SEO的服务端渲染仍然需要拼接HTML。 转义HTML根据目标上下文将所有输出进行实体编码（编码需在服务端侧进行）。转义HTML，主要是对特殊字符进行转义，为了完备的根据不同的上下文进行转义，最好是使用成熟的转义库。 预防DOM型XSS预防DOM型，需要前端的代码规范： 不将不可信的数据插入到页面上，小心使用 .innerHTML、.outerHTML、document.write() ，应尽量使用 .textContent、.setAttribute() 等。 使用vue等框架是不使用 v-html，dangerouslySetInnerHTML，避免类似 .innerHTML、.outerHTML的隐患。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。 不要将不可信的数据拼接给这些API。 其它CSPContent Security Policy（内容安全策略）。 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题 其他安全 限制输入内容长度（增加攻击难度）。 HTTP-only Cookie：HTTP头，禁止 JS 读取该 Cookie 。 使用验证码，防止脚本操作。 CSRFCross-site request forgery，跨站请求伪造。 伪造链接页面，诱导客户点击，及将被攻击的网站的注册凭证（比如Cookie），通过发送跨站请求将其发送给第三方网站，攻击者根据该凭证绕过后台的用户验证，冒充用户执行操作。 即：在不登出A的情况下，访问危险网站 B。 因此防御也主要是检查发起请求的来源。 来自图片，超链接等嵌入在第三方网站的论坛，文章中等。 跨站请求可以用各种方式，跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 Type Of CSRF请求型GET 类型和POST 类型在访问该黑客的页面的时候就会触发请求，携带着还未退出的要攻击的网站的cookie，进行了攻击。 Post 类型，在个人网站、博客、上传的页面都可能是攻击来源，不可轻视。 链接型常常在论坛中发布的图片中嵌入恶意链接，以广告等形式诱导用户点击。 预防主要是从检查攻击来源的方式进行防御。 Samesite Cookie Samesite属性作为cookie的属性之一，允许声明是否将 Cookie 限制为第一方或同一站点。（部分浏览器暂不兼容，未来的趋势） Samesite = Strict，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie。 Samesite = Lax，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie SameSite属性在配置了Secure属性(cookie只能通过https传输)的情况下才会生效, 单独使用不会生效 同源检测 Origin Header 指明了请求来自哪个站点。 - IE11 不会在跨站 CORS 请求中添加Origin标头。 - 302 重定向，浏览器不想将Origin泄露到新的服务器上，所以在302，重定向之后，Origin不包含在重定向中的请求中。 Referer Header 记录了请求页面的来源页面的地址。以下两种情况referer不会被发送。 - 来源采用的协议是表示本地文件，即“file”或“data” URI不会。 - 当前请求页面显示的是非安全协议，而来源页面采用的是安全协议（HTTPS）。 这两个header会被自动带上，且不能由前端自定义内容。 同源验证是一个相对简单的防范方法，能够防范，绝大多数的 CRFS 攻击，但是如果也有许多例外情况，比如来源是搜索引擎，或者在本域发起评论等信息，又或者攻击者可以在自己的请求中隐藏Referer。 CSRF Token 攻击者利用客户的信息进行请求，但是我们可以用攻击者无法获取的信息进行认证，Token。 主要的表现为在表单或者cookie中加入一个hidden的token值 将 CSRF Token 输出到页面。 请求时携带 Token。 服务器验证 Token 是否正确。 工作量巨大，且容易有遗漏 双重Cookie验证 防止网站被利用 严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。 添加Header X-Content-Type-Options: nosniff 防止黑客上传HTML内容的资源（例如图片）被解析为网页。 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。 总结 CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。 CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。 参考https://juejin.im/entry/58bad941128fe100643fb35b https://tech.meituan.com/2018/09/27/fe-security.html https://tech.meituan.com/2018/10/11/fe-security-csrf.html https://www.anquanke.com/post/id/204052]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lodash 之 函数式编程指北 之 一路向北]]></title>
    <url>%2F2020%2F07%2F18%2FJS_FunctionalProgramming%2F</url>
    <content type="text"><![CDATA[lodash函数式编程指北 之 一路向北前置基础 Object this Function 闭包 ……. 一等公民一等公民：是指函数和其它对象及数据类型一样，可以存在数组里，作为参数，赋值给变量等等。 123456789let obj = &#123; fnA (a,b) &#123;return function(a,b)&#123;a*b&#125;&#125;&#125;let obj = &#123; fnA (a,b) &#123;(a,b)=&gt;&#123;a*b&#125;&#125;&#125;let obj = &#123; fnA : (a,b)=&gt;&#123;a*b&#125;&#125; 函数式编成尽量避免使用 this，因此会大量的使用到 bind apply call 高阶函数 即，将函数作为参数，返回值的函数 纯函数 纯函数的定义：相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 1234567// 比如 slice splice 的使用：slice不改变原数组，splice改变了原数组var arr = [1,2,3,4]arr.slice(0,2); // [1,2]arr.slice(0,2); // [1,2]arr.splice(0,2); // [1,2]arr.splice(0,2); // [] 优点 可缓存性（柯里化可以很好地证明…） 可测试性（相同的输入，总得到相同的输出） 可并行执行（不改变原数组，不会访问及影响共享的数据源） 可移植/自文档化（依赖明显，便于观察理解使用） 合理性（即，变得更加的可推导，对于代码的理解重构很有好处） 副作用 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。 包括但不限于：更改文件系统、往数据库插入记录、发送一个 http 请求、可变数据、打印/log、获取用户输入、DOM 查询、访问系统状态…. 当我们依赖外部输入的参数时都使得程序变得不纯，副作用不可避免，我们只能将其控制在可控的范围内。 柯里化（curry） 柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 lodash 使用12345678910// lodash 效果var _ = require('lodash');var sum = function (a,b,c) &#123; return a + b + c;&#125;;var curried = _.curry(sum);curried(1)(2)(3); // 6curried(1,3,2); // 6curried(1,2)(3); // 6 效防 curry12345678910function curried (func)&#123; return function curriedFn(...args) &#123; if (args.length &lt; func.length) &#123; return function (...arguments)&#123; return curriedFn(...args,...arguments) &#125; &#125; return func(...args) &#125;&#125; 简化1234567function curried (func)&#123; return function curriedFn(...args) &#123; return args.length &lt; func.length ? (...arguments) =&gt; curriedFn(...args,...arguments) : func(...args) &#125;&#125; 代码组合（compose） 将多个函数组合后返回一个新的函数 简单的compose1234567891011121314151617181920212223var compose = function(f,g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;;// 简单例子function compose(f, g) &#123; return (x) =&gt; &#123; f(g(x)) &#125;&#125;function g(arr) &#123; return arr.reverse();&#125;function f(arr) &#123; return arr[0]&#125;let myCompose = compose(f,g);myCompose([1,2,12,5,8,9,6]); // 6 函数的合成还要满足结合律 12345compose(f, compose(g, h))// 等同于compose(compose(f, g), h)// 等同于compose(f, g, h) lodash中的组合函数flow() 是从左到右。 flowRight() 是从右到左。 创建一个函数。 返回的结果是调用提供函数的结果，this 会绑定到创建函数。 每一个连续调用，传入的参数都是前一个函数返回的结果。 模拟实现 flowRight()主要是 reduce 的使用 https://www.runoob.com/jsref/jsref-reduce.html 1234567891011121314151617function composeRight (...args) &#123; return function (value) &#123; return args.reverse().reduce(function(startValue,itemFn)&#123; return itemFn(startValue) &#125;, value) &#125;&#125;// 用例function g(arr) &#123; return arr.reverse();&#125;function f(arr) &#123; return arr[0]&#125;let myComposeRight = composeRight(f,g);myComposeRight([1,2,3,4,5,6]) 简化1234function composeRight (...args) &#123; return (value) =&gt; args.reverse().reduce((startValue,itemFn) =&gt; itemFn(startValue), value)&#125;// reduce(function(初始值，当前项)&#123;&#125;,'初始值传入') *当前项这里是一个个函数* trace调试12345const _ = require('lodash'); // 利用 lodash curry 函数var trace = _.curry((tag,x)=&gt;&#123; console.log(tag,x); // console 出来以便于查看 tag 标记及之后的值 x return x; // 依然返回 x ,不影响组合函数继续向下个函数传值&#125;) lodash 中的 FP 模块 该模块提供了实用的对函数式编程友好的方法： 就是将多参数的方法进行了封装，该封装具有 柯里化，函数优先，数据随后的特点。 123456789101112// 与 lodash 模块的区别const _ = require('lodash');_.map(['a', 'b', 'c'], _.toUpper);_.split('hello world', ' ');// fp 模块const fp = require('lodash/fp');fp.map(fp.toUpper, ['a', 'b', 'c']); // 函数优先fp.map(fp.toUpper)(['a', 'b', 'c']); // 柯里化fp.split(' ', 'hello World');fp.split(' ')('hello World'); 注意：map方法在 fp 模块有一定的区别。 12345const _ = require('lodash');const fp = require('lodash/fp');console.log(_.map(['23', '8', '10'], parseInt)) // [ 23, NaN, 2 ]console.log(fp.map(parseInt, ['23', '8', '10'])) // [ 23, 8, 10 ] pointfree pointFree 不在乎数据，只是将简单的运算步骤进行组合，而组合当中多参数函数又需要进行柯里化，因此：pointfree = Curry（柯里化提取参数） + Compose(组合函数)。 12var f = fp.flowRight(fp.replace(/\s+/g, '-'), fp.toLower)console.log(f('HOLL woadksf')) 函子 functor 一峰说： 函子不仅可以用于同一个范畴中的值的转换，还可以将一个范畴转为另一个范畴。即，它是包含了 值与值、范畴与范畴的变形关系。 一般约定，函子的标志就是容器具有 map 方法。该方法将容器里面的每个值，映射到另个容器。（通透） 学习函数式编程，实际上就是学习函子的运算。 12345678910// 一峰表示：任何具有 map 方法的数据结构，都可以当做函子的实现class Functor &#123; constructor(val) &#123; this.val = val &#125; map(f) &#123; return new Function(f(this.val)) &#125;&#125; 指北表示：Container 是一个容器： Container 是只有一个属性的对象。 _value 不能是一个某个特定的类型，毕竟 Container 是一个 “容器”。 数据一旦存在那里，就会一直待在那里。 1234567891011121314// 指北表示var Container = function(x)&#123; this._value = x;&#125;// 使用 Cantainer.of 作为构造器（constructor）Container.of = function(x) &#123; return new Container(x) &#125;;// 需要让 别的函数（map）能够操作它Container.prototype.map = function(f)&#123; // 再放回 Container 就可以连续的调用 map return Container.of(f(this.__value))&#125;// 就是将改变值的方法放进map，return 出改变值后的 Container，其中也包含 map，即可连续调用了。 of 方法 函数式编程约定，用 of 来生成新的容器。 12345678// 定义Functor.of = function(val) &#123; return new Functor(val);&#125;;// 使用Functor.of(2).map( (count) =&gt; count+2 )// return Functor(4) 薛定谔的 Maybe (Maybe函子) 和 Container 类似，不同的是：Maybe 会先检查自己的值是否为空，然后调用传进来的函数。 就像平时工作中写的，先检查是否为 null，继而继续执行。避免因为 null 而报错。 12345678910111213141516171819class Maybe &#123; constructor (value) &#123; this._value = value; &#125; static of (value) &#123; return new Maybe(value); &#125; map(fn) &#123; return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this._value)); &#125; isNothing() &#123; return this._value === value || this._value === undefined; &#125;&#125;Maybe.of('hello world').map(x =&gt; x.toUpperCase())Maybe.of(null).map(x =&gt; x.toUpperCase()) 纯错误处理 Either（Either函子） Either 函子表达了条件运算。并利用条件运算，代替了 try ... catch。 12345678910111213141516class Either &#123; constructor(left, right) &#123; this._left = left; // 正常值 不存在 默认值 this._right = right; // 正常值 &#125; static of(left, right) &#123; return new Either(left, right); &#125; map(fn) &#123; return this._right ? Either.of(this._left, fn(this._right)) : Either.of(fn(this._left), this.right) &#125;&#125; Either 普通使用123456789var addOne = function (x) &#123; return x + 1;&#125;;Either.of(5, 6).map(addOne);// Either(5, 7);Either.of(1, null).map(addOne);// Either(2, null); Either try ... catch1234567function parseJSON(json) &#123; try &#123; return Either.of(null, JSON.parse(json)); &#125; catch (e: Error) &#123; return Either.of(e, null); &#125;&#125; IO 函子 IO函子的 _value 是一个函数，它可以将不纯的函数存在这里，以使得只有在调用的时候才执行这个不纯的函数，以达到控制副作用的目的。 12345678910111213141516171819class IO&#123; constructor (fn)&#123; this._value = fn; &#125; static of(x_value)&#123; return new IO(function()&#123; // 当我们调用的时候返回的是一个函数，当再次调用的时候才返回该值 return x_value &#125;) &#125; map(fn)&#123; return new IO(fp.flowRight(fn, this._value)) &#125;&#125;var io = IO.of(process).map(p=&gt;p.execPath)console.log(io._value()) // D:\node\Node\node.exe Folktale 里的 Task 函子 folktale：一个标准的函数式编程库，它没有提供很多功能函数，只提供了一些函数式处理的操作，及一些函子。 Task 函子12345678910111213141516171819202122232425const fs = require('fs');const &#123; task &#125; = require('folktale/concurrency/task');const &#123; split, find &#125; = require('lodash/fp');function readFile (filename) &#123; return task(resolver =&gt; &#123; fs.readFile(filename, 'utf-8', (err, data) =&gt;&#123; if (err) resolver.reject(err) resolver.resolve(data) &#125;) &#125;)&#125;readFile('../package-lock.json') .map(split('\n')) .map(find(x =&gt; x.includes('version'))) .run() .listen(&#123; onRejected: err=&gt;&#123; console.log(err) &#125;, onResolved: value=&gt;&#123; console.log(value) &#125; &#125;) pointed 函子 实现 of 静态 方法的函子，使用of方法初始化容器中的值，使用map来处理值。 monad 函子 解决函子嵌套问题 参考补充https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/?q= http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html https://www.lodashjs.com/ https://juejin.im/post/5d767e1d6fb9a06b032025ea https://f-lancer.github.io/2020/03/26/JS_Function/#more https://f-lancer.github.io/2020/02/14/JS_Object/#more]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>FP</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化]]></title>
    <url>%2F2020%2F07%2F12%2FThree_DataChart%2F</url>
    <content type="text"><![CDATA[数据可视化初探初探…………… 2D数据可视化SVG/CanvasSVG注意： 一个简单的SVG文档由&lt;svg&gt;根元素和基本的形状元素构成。以及&lt;g&gt;元素来将基本形状编成一个组。 需要遵从 （标准）XML 语法。 XML区分大小写。 属性值必须用数值引起来。 注意兼容。 元素参考 ，接口参考 坐标：单位分为 绝对大小和相对大小。（viewBox定义画布上可显示的区域） 基本元素：123456789101112&lt;!--rect Rectangular 矩形--&gt; rx ry 圆角xy方位半径&lt;!--circle--&gt; r cx cy 半径圆心位置&lt;!--ellipse 椭圆--&gt; rx ry cx cy 椭圆xy半径&lt;!--polyline 折线--&gt; points 点坐标&lt;!--polygon 多边形--&gt; points 点坐标&lt;!--path 曲线--&gt; d &lt;!--line 直线--&gt;&lt;!--text 文字--&gt; &lt;!--tspan 用来标记文本的子部分--&gt; &lt;!--tref 元素允许引用已经定义的文本--&gt; &lt;!--textPath 可以使文字沿着定义好的路径走--&gt;&lt;!--&lt;defs&gt;--&gt; SVG里的style标签 line:M：（Move To）M x y/m dx dy 起始坐标。 L：（Line To）L x y (or l dx dy) 从当前位置到新位置，画一条线。 H、V：H x (or h dx) V y (or v dy) 绘制水平线、垂直线。 Z：Z (or z) 闭合路径命令。 使用小写字母时，并不是明确的目标，是表示相对于它前面的点需要移动多少距离。 在path元素里，只存在两种贝塞尔曲线：三次贝塞尔曲线C，和二次贝塞尔曲线Q。 …等 FillFill 上色，fill-opacity 控制填充色的不透明度。 StrokeStroke 描边，stroke-opacity控制描边的不透明度 。 其它 &lt;g&gt; 组合 使用属性transform实现变换等。 了解底层基础是为了开启D3.js的路。 D3/echartD3 SVG基础，包含svg属性介绍以及svg内部元素基础内容。 D3 API文档，内包含低版本、高版本的多语言文档。 D3 图表demo，基本的图表类型实例都能找到。 http://christopheviau.com/d3_tutorial/ echart ECharts Examples，提供大量实例，基本的图表类型都能找到。 ECharts 使用文档 教程，包括使用教程，API，配置项等等。 ECharts 主题构建工具，可构建通用主题，在初始化实例时，注册即可。 对比echart 封装完善，直接填写配置项即可使用。使用简单，但不够灵活。 使用Canvas来绘制图形。canvas不支持事件的处理器，只能展示数据，不能修改。 兼容IE6以上。 D3 学习成本大，但使用灵活。 使用SVG绘制图形，可以操作DOM，但当数据改变图表会重新渲染，消耗性能。 兼容IE9以上。 场景 只做展示建议采用 echart。需要和用户交互采用D3。 项目中大量常规图，采用 echart。特殊图表，流程图等采用D3。 3D数据可视化webGL/Three.js参考 https://developer.mozilla.org/zh-CN/docs/Web/SVG https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API https://juejin.im/entry/5b90ecf25188255c781c97b5 https://juejin.im/post/5cd65a41e51d456e89634ad3 https://www.cnblogs.com/zhangdi/p/3690284.html?utm_source=tuicool&amp;utm_medium=referral https://zhuanlan.zhihu.com/p/21897086]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeAccumlation]]></title>
    <url>%2F2020%2F07%2F12%2FJS_CodeAccumulation%2F</url>
    <content type="text"><![CDATA[CodeAccumlation手撕一些常见代码，加深理解 JS。 Debounce 在事件被触发 n 秒后再执行回调，如果在 n 内，又被触发，则重新计算 简版123456789101112// 简版防抖函数 let timer; function debounce() &#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; console.log(1) testDebounce() &#125;,1000) &#125; function testDebounce()&#123; console.log(2) &#125; 优化123456789101112131415161718192021// 优化防抖函数 let debounce = function (fn, delay) &#123; let timer; return function (...args) &#123; let that = this if (timer) clearTimeout(timer); timer = setTimeout(()=&gt;&#123; // 传入函数才有效 fn.apply(that,args) &#125;, delay) &#125; &#125; function testDebounce(count)&#123; let arr = [...count] arr.shift() console.log(arr) &#125; let b = debounce(testDebounce,1000) let el = document.getElementById('myId') el.addEventListener("click",()=&gt;&#123;b([2,3,4,5])&#125;) // 传入参数要写进函数里 状态码$Ajax POST 请求要data转字符串，传输格式不对会报 400；传输 contentType 格式错误 报错 415 400 请求错误，不能响应该请求，或不存在域名。 415 Unsupported Media Type 是一种HTTP协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。 参考 https://www.runoob.com/w3cnote/http-400.html https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/415 参考 https://juejin.im/post/5de7286e6fb9a016107952f7]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>CodeAccumlation</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2020%2F06%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据结构与算法数据结构、算法基础…….de复习~。 复杂度f(n) 的代码复杂度是f(n) —&gt;O(f(n)) O(n) 表示，复杂度与计算实例的个数 n 线性相关。 O(logn) 表示，复杂度与计算实例的个数 n 对数相关。 计算原则 复杂度与具体的常系数无关。 O(2n)与O(n)复杂度一致。 多项式级的复杂度相加的时候，选择高者作为结果。 O(n²)+O(n) = O(n²+n) O(1) 表示某任务通过有限可数的资源即可完成。 定义一个新的空间与原空间一致，则空间复杂度为O(n)。未定义则为O(1) 复杂度与代码结构的关系时间复杂度与 代码的结构设计 有着非常紧密的关系。 空间复杂度与 数据结构的设计 有关。 常用的经验性结论： 顺序结构的代码，事件复杂度为O(1)。 二分查找，即，采用二分策略，时间复杂度为O(logn)。 一个for循环，时间复杂度为O(n)。 两个顺序执行的for循环也为O(n)。 两个嵌套的for循环为O(n²) 降低复杂度 梳理减除无效程序。 常用 降低时间复杂度 的方法有：递归、二分法、排序算法、动态规划等。 降低空间复杂度 的核心思路：尽量用低复杂度的数据结构解决问题。 空间复杂度换取时间复杂度。 问：如何在一个无序数组中查找出出现次数最多的数字？ 增删查数据处理的操作，即： 找到需要处理的数据。查。 将结果存到新的内存空间。增。 删除旧结果，将新的结果存入内存空间。删。 遇到优化算法思路： 分析代码对数据进行了哪些操作。 根据分析出来的数据操作，找到合理的数据结构。 查找 根据 元素的位置或索引 来进行查找。 根据 元素的数值特征 来查找。 例1：查找第几个元素？ 如果是数组，具有索引，查找第二个元素时间复杂度为 O(1)。 如果是链表，需要进行一个一个查找。时间复杂度为O(n)。 例2：查找等于 5 的元素？ 数组和链表都为O(n)。 能在O(1)的时间复杂度内完成查找动作的数据结构，只有字典类型。 新增 在复杂数据结构的最后，新增一条数据。 在复杂数据结构的中间某个位置，新增一条数据。 区别：新增了数据之后，是否会导致原有数据结构中数据的位置顺序改变。 删除 在复杂数据结构的最后，删除一条数据。 在复杂数据结构的中间某个位置，删除一条数据。 区别：删除了数据之后，是否会导致原有数据结构中数据的位置顺序改变。 线性表线性表是 n 个数据元素的有限序列，最常用的是链式表达，通常也叫作线性链表或者链表。数据元素也叫作结点，一个结点存储的就是一条数据记录。 链表单项链表 第一是具体的数据值。 第二是指向下一个结点的指针。 最后一个指向空。 循环链表 对于单项链表，让最后一个元素的指针指向第一个元素就是循环链表。 双向链表 除了指向下一个结点的指针，增加一个指向上一个结点的指针，就得到了双向链表。 双向循环链表 将双向链表和循环列表融合。 新增删除为O(1)，查找为O(n)。 线性表真正的价值在于，它对数据的存储方式是按照顺序的存储： 适用场景 如果数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。 如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合些。 问： 链表反转？（对当前、前、后，元素进行缓存） 奇数个元素链表，查找中间位置的结点数值？（暴力解法、快慢指针） 判断链表是否有环？（快慢指针相遇） 栈一种特殊的线性表。栈和线性表的不同主要是增删操作，栈必须先进后出，即，对线性表的操作进行了限制。 顺序栈栈的顺序存储可以借助数组来实现： 把数组的首元素存在栈底，最后一个元素放在栈顶。 定义一个 top 指针来指示栈顶元素在数组中的位置。 假设栈中只有一个数据元素，则 top = 0。一般以 top 是否为 -1 来判定是否为空栈。 当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。 当需要新增数据元素，即入栈操作时，就需要将新插入元素放在栈顶，并将栈顶指针增加 1。 JS 中可以用数组中的push和pop来模拟进栈出栈的操作。 对于栈的查找操作，也需要遍历整个栈来完成基于某些条件的数值查找。 链栈用链表的方式对栈的表示。 对于链栈新增删除没有进行循环操作都为O(1)，但只能在栈顶进行操作。 对于链栈的查找操作，也需要遍历整个栈来完成基于某些条件的数值查找。 适用场景 当你面对的问题需要高频使用新增、删除操作，且新增和删除操作的数据执行顺序具备后来居上的相反关系时，栈就是个不错的选择。 问：利用栈 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。 浏览器的页面访问都包含了后退和前进功能，利用栈如何实现？（前进栈、后退栈）。 大多数程序运行环境都有的子程序的调用，函数的递归调用。 队列也是一种特殊的线性表。队列和线性表的不同主要也是增删操作，栈必须先进后出，而队列是先进先出，同样对线性表的操作进行了限制。即，只能在队列末端进入，始端删除。 顺序队列同样，根据两种存储方式，顺序队列是依赖数组来实现的，数据在内存中也是顺序存储的。 出现了假溢出的问题 假溢出不断进行增加删除操作两指针会向后移动，队列长度是有限的，最终会出现假溢出的问题。 解决： 移动整体数据，但是消耗的时间复杂度是O(n)。 开辟足够大的内存空间，确保数组不会越界。 通过队列的特殊变种 循环队列 解决。 循环队列新增数据：首先判断队列是否为满。如果不满，则可以将新元素赋值给队尾，然后让 rear 指针向后移动一个位置。如果已经排到队列最后的位置，则 rea r指针重新指向头部。 删除操作：需要判断队列是否为空，然后将队头元素赋值给返回值，front 指针向后移一个位置。如果已经排到队列最后的位置，就把 front 指针重新指向到头部。 出现了新的问题，当队列为空，对头（front）和队尾（rear）就指向了同一结点。，那么如何判断空满呢？ 常用操作：设置标志变量 flag 来区别 链式队列依赖链表实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表。 一个增加了 front 和 rear 指针，通常同时会增加一个不存任何数据的头结点，用来辅助标识的单链表。 当最后一个结点删除时，rear 指针变成了野指针，因此需要对队尾指针重新赋值（指向头结点） 如此便彰显了 头指针 的意义 数值的查找仍然是 O(n)。 适用场景时间复杂度：增删为O(1)，查找为O(n)。 空间复杂度： 循环队列必须有一个固定的长度，因此存在存储元素数量和空间上的浪费。 链式队列，则不存在这个问题。 在可以确定队列长度最大值时，建议使用循环队列。 无法确定队列长度时，应考虑使用链式队列。 队列最大的特点还是先进先出的特点。 约瑟夫环问题 数组数组可以看成是线性表的一种推广，属于另外一种数据结构。可以理解为，用来存放若干个相同类型的容器。 过于常见，略。 基本操作存储数组时，是按顺序存储的，在内存中也是连续的，这使得它具有增删困难，查找容易的特点（按索引查找O(1)，按数值查找依然为O(n)）。 但是和 栈和队列 相比，它可以在任何位置进行删除新增操作，操作更加灵活。 在数组最后增删O(1)，但在数组中间、前面增删，需要依次挪动位置，时间复杂度是O(n)。比如 JS 中的 shift() 高级语言中对于数组的增删封装好了函数方法： 新增系列的 push()、unshift()、concat()、splice()。 删除系列的pop()、shift()、slice() 查找系列的indexOf()、lastIndexOf() 封装好的时间复杂度依然不会改变。 对比对比链表 链表长度可变，数组则是固定的，需要提前在内存中预估好若干空间。 链表不会根据有序位置存储，想要充分利用内存空间就只能顺序存储。（且需要在不取不删数据的情况下才能实现）。 适用场景数组适合： 数据数量确定。 较少的新增和删除的操作场景下。 数据对位置敏感的场景下。 高频查找时很适用。 案例打分案例，去掉一个最高分和一个最低分并计算平均分。 不允许开辟O(n)空间复杂度的复杂数据结构。 字符串 过于常见，定义略。 特殊的字符串 空串 空格串 子串：串中任意连续字符组成的字符串叫做该串的子串。 主串 存储结构分为，顺序存储、链式存储。 顺序存储一般用定长数组，一组连续存储单元存储来实现。有些语言用\0表示传值终结。 链式存储一个结点存储一个字符会造成空间浪费，一般一个结点存储多个字符。 增删查顺序存储和数组类似。增删在中间需要挪移(O(n))。 案例字符串匹配： 在 主串n 中匹配 模式串m 查找AB两字符串的最大公共子串。 匹配、动态规划 逐个反转字符串中的每个单词。 树和二叉树树 emmmm，过于常见，定义略 二叉树 常用的树结构，定义略。 满二叉树 即，满 完全二叉树 并 “不完全”，除了叶子结点外，所有叶子结点都有两个子结点，且不满的叶子结点都靠左排列。 存储基于指针的链式存储方式。 基于数组的顺序存储方式。 结点下标为 i ，左子节点存储在 2i 的位置，右子结点存储在2i+1的位置。之所以完全二叉树称为“完全”，就是因为在顺序存储中节省了空间。 基本操作遍历前、中、后遍历。时间复杂度为O(n)。 前中后都是相对父结点而言的，父左右为前，左父右为中… 增删只需要通过指针建立关系即可。 对于没有任何特殊性质的二叉树而言，抛开遍历的时间复杂度以外，真正执行增加和删除操作的时间复杂度是 O(1)。树数据的查找操作和链表一样，都需要遍历每一个数据去判断，所以时间复杂度是 O(n)。 特性二叉查找树的特性 在二叉查找树中，左边子结点的值 &lt; 该结点 &lt; 右子树结点的值 。 尽可能规避两个结点数值相等的情况（尽量？）。 对二叉查找树中序遍历（左中右）即可得到一个从小到大的有序数据队列。 查找操作利用的是“二分查找”思想，时间复杂度为O(logn)： 如果根节点即是查找数据，直接返回。 如果大于根节点值，递归向右子树执行查找动作，直到叶子结点。 如果小于根节点值，递归向左子树执行查找动作，直到叶子结点。 插入操作同样与根节点比大小，直到找到为空的子结点尝试插入操作。 查找时间复杂度为O(logn)，插入操作时间复杂度为O(1)。 删除操作 如果删除的是叶子结点，直接删除，父结点指向 null。 如果要删除结点只有一个子结点，则直接删除，父结点直接指向删除结点的子结点。 如果要删除的结点有两个子结点： 找到左子树最大的结点替换当前结点。 找到右子树最小结点替换当前结点。 左子树最大和右子树最小都是 “最中间” 的元素 案例 输入字符串，判断它在已有的字符串集合中是否出现过？ 暴力解法。 利用 Trie 树。Trie树特点： 根结点不包含字符。 一个结点一个字符。 从根到叶构成一个字符串。 步骤：构建 Trie 树，看是否可以走到叶子节点。 哈希线性表在于顺序。数字字符串在于数据类型的统一。树在于层次结构。但是它们在按数值进行查找操作时都需要遍历。由此引入哈希（散列表） 思想采用了函数映射的思想，数组是通过索引和值形成一一对应的关系。哈希则是通过，哈希函数实现 地址 = f(关键字) 的映射关系。 哈希函数因此哈希函数设计的好坏会直接影响到对哈希表的操作效率。 设计哈希函数常用的方法： 直接定址法。即哈希函数为，关键字到地址的线性函数。 数字分析法。由均匀分布的特征值组成哈希地址。 平方取中法。 折叠法。 除留余数法。 哈希冲突再者，哈希函数存在哈希冲突，即通过哈希函数的映射，将多个关键字映射到了同一个地方，这个现象称为：哈希冲突。 解决哈希冲突的常用方法： 开放定址法： 线性探测法 链地址法 哈希表对于顺序是不敏感的，且key值是不允许重复的，在重复性高的数据中，哈希表不是好多选择。 基本操作在高级语言中，对哈希函数以及哈希冲突进行了黑盒化处理，一般都可以在常数级时间复杂度查找到数据。在哈希表中的增删操作都不涉及对数据的挪移问题，因此主要在于查找。 如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。 案例例 1，将关键字序列 {7, 8, 30, 11, 18, 9, 14} 存储到哈希表中。哈希函数为： H (key) = (key * 3) % 7，处理冲突采用线性探测法。 例 2，假设有一个在线系统，可以实时接收用户提交的字符串型关键字，并实时返回给用户累积至今这个关键字被提交的次数。 常用算法递归 常见：略 注意： 递归主体：可以将问题分解为多个完全相同的小问题来进行解决。 终止条件：要有明确的结束条件。 主要利用了，数学归纳法。即，在n=1成立，n=2成立，需推导出n=n时同样成立。 案例 对树的中序遍历。 汉诺塔问题。 分治 分而治之，简单：略 难度降低 问题可分 解可合并 相互独立 海量数据体现优势 案例 排序算法中的快速排序和归并排序。 n个元素的无序数组，从小到大打印。 有序数组，判断是否出现过数字C。 遍历 以下情况考虑二分法 有序 时间复杂度O(logn) 循环次数不确定，（while循环） 1毫米纸折叠多少次可以得到从地球到月球的距离。39次。 有序数组查找第一个大于9的数字。 经典排序衡量排序问题的优劣：时间复杂度，空间复杂度和稳定性（指相等的数据对象，在排序之后，顺序是否能保持不变）。 冒泡 两两比较，每次将最大的值传向最前方。性能： 1. 最好的时间复杂度是O(n)（顺序）。 2. 最差的时间复杂度为O(n*n)（逆序）。 3. 当输入的数组随机，平均时间复杂度为**O(n*n)**。 4. 相等数据并未交换位置，**稳定**。 5. 原地排序（O(1)）。 插入 维护一个已排好序的数组，依次将值插入合适的位置 性能： 最好的时间复杂度是 O(n)（顺序）。 最差的时间复杂度为 O(n*n)（逆序）。 当输入的数组随机，平均时间复杂度为 O(n*n)。 相等数据并未交换位置，稳定。 原地排序（O(1)）。 归并 分治法。二分至只有一个数字，然后合并。 最好的时间复杂度是 O(n*logn)（n次二分法）。 最差的时间复杂度为 O(n*logn)（n次二分法）。 当输入的数组随机，平均时间复杂度为 O(n*logn)。 相等数据并未交换位置，稳定。 每次开辟新的空间（O(n)）。 快排 选值比较交换，分治（二分）. 最好的时间复杂度是 O(n*logn)（每次选到中位数）。 最差的时间复杂度为 O(n*n)（每次选到最大最小值）。 当输入的数组随机，平均时间复杂度为 O(n*logn)。 使用了交换法，相等数据交换位置，不稳定。 每次开辟新的空间（O(1)）。 分析 数据规模小，采用O(n*n)。（冒泡，插入） 数据规模大，采用O(n*logn)。（归并，快排） 归并稳定，消耗空间。 快速排序，不稳定。 动态规划（？）分治需要满足其可被分治的条件，当不满足时，引入了动态规划。 运筹学方法，在多轮决策中选择最优的方法。 状态，可选择的结果。 基本方法（宏观层面） 分阶段，将原问题划分成几个子问题。 找状态，选择合适的状态变量Sk（k表示多轮决策的第k轮），它需要具备多轮决策的演变。 做决策，确定决策变量uk，比如D2可能的决策动作是：D2-&gt;E2和D2-&gt;E3。 状态转移方程，即Sk+1 = Uk(Sk)。 定目标，写出多轮决策目标的指标函数Vk,n 寻找终止条件。 决策集合称为策略。所有可能的策略称为策略集合 场景概述 最优子结构，原问题的最优解，所包含的子问题的解也是最优的。 无后效性，某阶段的决策，不影响先前状态。 有重叠子问题，子问题间不独立，（区别于分治）。 案例 最短路径问题 暴力方法，求出所有可能的结果。 动态规划 最大公共字串]]></content>
      <categories>
        <category>技术</category>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>技术</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2020%2F06%2F27%2FHttp%2F</url>
    <content type="text"><![CDATA[HTTPTCP：TCP头和数据部分。 HTTP：header + body 结构。 1起始行 + 头部 + 空行 + 实体 起始行 请求报文，方法 + 路径 + http版本，例：GET /home HTTP/1.1。 响应报文，http版本 + 状态码 + 原因，例：HTTP/1.1 200 OK。 头部 涉及诸多特性 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers 头部字段格式 字段名不区分大小写。 字段名不允许出现空格，不可以出现下划线_。 字段名后面必须紧接着：。 空行用来区分开头部 和 实体。 问：如果说在头部中间故意加一个空行会怎么样？ 答：空行后的内容全部被视为实体。 实体body部分，具体数据。分别对应 请求体 和 响应体。 理解请求方法前端涉及的最多的就是请求头中的请求方法。 GET：获取资源。 HEAD：获取资源的元信息。 POST：提交数据，即上传数据。 PUT：修改数据。 DELETE：删除资源。 CONNECT：建立隧道，用于代理服务器（？）。 OPTIONS：列出对资源实行的请求方法，用来跨域请求（？）。 TRACE：追踪请求-响应的传输路径。 GET/POST区别 语义。 缓存：GET请求会被浏览器主动缓存下来留下历史记录，POST不会。 编码：GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。 参数：GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。 幂等性：GET 是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的) TCP：GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包) URI scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。 user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。 host:port 表示主机名和端口。 path 表示请求路径，标记资源所在位置。 query 表示查询参数，为key=val这种形式，多个键值对之间用&amp;隔开。 fragment 表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。 URI编码URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。 因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。 状态码略。 HTTP特点优点： 灵活可扩展。 可靠传输。 请求-应答。 无状态。 缺点： 需要长连接的场景中，无状态就是缺点。 明文传输，（WIFI陷阱？） 队头阻塞问题。 Accept系列字段指定了，数据格式、压缩方式、支持语言、字符集。 定长和不定长数据定长包体发送端头部会带上 content-Length，来指定包体的长度。 Content-Length 对于http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输的失败。 不定长包体利用头部字段 Transfer-Encoding:chunked 表示分块传输数据，设置这个字段会产生两个效果： Content-Length 字段会被忽略。 基于长连接持续推送动态的内容。 处理大文件传输采取 范围请求 ，允许客户端仅仅请求一个资源的一部分。 范围请求—服务端添加响应头 Accept-Ranges: none 用来告知客户端支持范围请求。 范围请求—客户端客户端需要指定请求哪一部分，通过 Range 这个请求头字段，格式为 bytes=x-y： 0-499表示从开始到第 499 个字节。 500- 表示从第 500 字节到文件终点。 -100表示文件的最后100个字节。 服务端验证是否合法，越界报 416 ，否则读取相应片段，返回206状态码。 响应格式响应格式分为，单/多段数据 服务端添加字段 Content-Range 字段： 请求头： 1234// 单段数据Range: bytes=0-9// 多段数据Range: bytes=0-9, 30-39 响应头：单段数据 1234HTTP/1.1 206 Partial ContentContent-Length: 10Accept-Ranges: bytesContent-Range: bytes 0-9/100 // 0-9表示请求的返回，100表示资源的总大小 多段数据： 123456789101112131415161718HTTP/1.1 206 Partial ContentContent-Type: multipart/byteranges; boundary=00000010101Content-Length: 189Connection: keep-aliveAccept-Ranges: bytes--00000010101Content-Type: text/plainContent-Range: bytes 0-9/96i am xxxxx--00000010101Content-Type: text/plainContent-Range: bytes 20-29/96eex jspy e--00000010101-- Content-Type: multipart/byteranges;boundary=00000010101，它代表了信息量是这样的: 请求一定是多段数据请求 响应体中的分隔符是 00000010101 因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上 -- 表示结束。 HTTP处理表单提交利用 Content-Type ，根据取值不同有两种方法： application/x-www-form-urlencoded multipart/form-data 特点application/x-www-form-urlencoded ： 数据会被编码成以 &amp; 分隔的键值对。 字符以URL编码方式编码。 12// 转换过程: &#123;a: 1, b: 2&#125; -&gt; a=1&amp;b=2 -&gt; 如下(最终形式)"a%3D1%26b%3D2" multipart/form-data： 每个表单元素都是独立的资源表述。（略） 对比实际场景中，对于 图片等文件的上传 ，基本采用 multipart/form-data 而不用 application/x-www-form-urlencoded，因为没有必要做 URL 编码，带来巨大耗时的同时也占用更多的空间。 解决队头阻塞问题队头阻塞HTTP 传输是基于 请求-应答 的模式进行，报文必须是一发一收，里面的任务被放到了一个任务队列中串行执行，一旦对首的请求处理太慢就会阻塞后面的请求处理。 并发连接对于一个域名允许分配多个长连接，相当于增加了任务队列，不至于一个队伍的任务阻塞了其它所有的任务，现代浏览器的标准中，可以并发许多，Chrome上限是6个。 域名分片一个域名并发6个长连接，一个域名下可以分出多个二级域名，它们都指向同样的一台服务器，能够并发的长连接数就更多了。 Cookie生命周期Cookie 的有效期通过属性 Expires 和 Max-Age 两个属性设置。 Expires：表示过期时间。 Max-Age：用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。 如果 Cookie 过期，则会被删除，也就不会发送到服务端。 作用域绑定了域名和路径的两个属性： Domain：绑定了域名。 path：绑定了路径。对于路径来说，/表示任意路径下都可以使用。 如果发现域名或者路径不匹配，就不会带上Cookie。 安全相关 Secure：如果带上 Secure，说明只能通过 HTTPS 传输 cookie。 HttpOnly：说明只能通过 HTTP 协议传输，不能通过 JS 访问，这是预防 XSS 攻击的重要手段。 SameSite：为了防御 CSRF 的攻击。一共有三个属性： Strict，浏览器完全禁止三方请求携带 Cookie，该网站只能在其自己的域名下携带 Cookie ，在其他情况下均不能。 Lax，只能在get方法提交表单 时，或 a 标签发送 get 请求 的情况下可以携带 Cookie ，其他情况不能。 None，默认模式，请求会自动携带 Cookie。 缺点 容量。Cookie 的体积上限只有 4KB，只能存储少量的信息。 性能。请求会携带上完整的Cookie，随着请求数的增多，携带了很多不必要的内容，造成了巨大的性能浪费，可以通过 Domain 和 Path 指定作用域来解决。 安全缺陷。Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，在有效期内重新发送给服务器是危险的。另外，在HttpOnly 为 false 时，Cookie 信息能直接通过 JS 脚本来读取。 HTTP代理HTTP 是基于 请求-响应 模型，引入代理服务器，代理服务器可以向客户端进行进行响应，对服务端进行请求。 代理服务器功能 负载均衡，代理服务器可以通过特定的算法将请求分发送给不同的源服务器，使各源服务器尽量达到负载均衡。 保障安全，利用心跳机制监控后台的服务器，保障运行。对非法 IP 进行限流，对上下行的数据进行过滤，等。 缓存代理，将内容缓存到代理服务器，使得客户端可直接从代理服务器获得，不必再去源服务器。 相关头部via代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，就通过 Via 字段来记录。 1234567// 客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器// 服务端拿到的 请求头Via: proxy_server1, proxy_server2// 客户端拿到的 响应头Via: proxy_server2, proxy_server1 Via 中代理的顺序即为在HTTP传输中报文传达的顺序。 X-Forwarded-For该字段记录了请求方的IP地址。 仅仅记录的是上一个请求方的一个 IP，会带来两个问题： 代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。 HTTPS 通信加密的过程中，原始报文不允许修改。 解决：使用 代理协议 1234// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222GET / HTTP/1.1... X-Real-IP获取用户真实IP的字段，不管中间经过多少代理，该字段始终记录最初的客户端的IP。 X-Forwarded-Host 和 X-Forwarded-Proto，分别记录客户端(不包括代理)的 域名 和 协议名。 HTTP缓存及缓存代理强缓存和协商缓存Cache-Control 验证强缓存是否可用： 强缓存可用直接使用。 强缓存不可用，进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match 这些条件请求字段检查资源更新。 若资源更新，返回资源和200状态码。 否则，返回304，告诉浏览器直接从缓存获取资源。 代理缓存源服务器存在缓存，比如，Redis，Memcache，但是对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，给与源服务器压力过大。 引入代理缓存机制，客户端缓存过期去代理缓存获取，代理缓存过期去源服务器获取。 代理缓存可以由源服务器端控制，也可以由客户端控制。 源服务器控制根据 Cache-Control 中的取值不同，进行控制： private：禁止代理服务器缓存。 public：允许代理服务器缓存。 must-revalidate：表示看客户端缓存过期后去源服务器获取。 proxy-revalidate：表示代理服务器的缓存过期后到源服务器获取。 s-maxage：限定了缓存在代理服务器中可以存放多久。 max-age：限制了客户端缓存时间。 12Cache-Control: public, max-age=1000, s-maxage=2000// 表示可以使用代理缓存，客户端缓存 1000s，代理缓存 2000s 客户端的缓存控制max-stale：5，表示代理缓存过期了，但在5s之内依然可以使用。 max-fresh: 5，表示要在缓存到期前5s内才可以拿去使用。保证了代理缓存的新鲜度。 only-if-cached，表示客户端只接受代理缓存，代理缓存无效直接返回504（gateway Timeout）。 跨域跨域，即scheme（协议）、host（主机）、port（端口）相同即为“同源”。 同源策略做出了如下限制： 不能读取和修改对方DOM。 不能访问对方的 Cookie、IndexDB、LocalStorage。 限制 XMLHttpRequest 请求。 跨域请求一般响应是成功到达客户端了，但是会被浏览器拦截。 进程间通信网络进程将数据传递给主进程，主进程接收后发出网络请求，服务端处理完数据后返回，主进程检查到跨域，并且没有 cors 响应头，则将响应体全部丢掉，不会发送给渲染进程，从而达到了拦截的目的。 CORSCORS，跨域资源共享。 简单请求/非简单请求 请求方法为 GET、POST、HEAD。 请求头的取值范围：Accept，Accept-Language、Content-Language、Content-Type（只限于三个值，application/x-www-from-urlencoded、multipart/form-data、text/plain）。 浏览器将满足上述条件称为 简单请求，否则为 非简单请求。 简单请求请求头： Origin：该字段会自动被添加到请求头，用来说明请求来自哪个源。 响应头： Access-Control-Allow-Origin：服务器拿到Origin字段，对应添加该字段，如果Origin不在这个字段里，将会被拦截。 其它可选： Access-Control-Allow-Credentials：布尔值，表示是否允许发送Cookie，对于跨域请求，浏览器默认设置为false，如果需要拿到Cookie，需要添加该响应头并设为 true ，前端需要设置 withCredentials 属性。 12let xhr = new XMLHttpRequest();xhr.withCredentials = true; Access-Control-Expose-Headers：给 XMLHttpRequest 对象赋能，包括，Cache-Control/Content-Language/Content-Type/Expires/Last-Modified/Pragma。 12// Access-Control-Expose-Headers: aaaXMLHttpRequest.getResponseHeader('aaa') // 前端可以拿到 aaa 这个字段的值。 非简单请求非简单请求有两点不同：预检请求和响应字段。 12345var url = 'http://xxx.com';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'xxx');xhr.send(); 发送预检请求，请求格式： 12345OPTIONS / HTTP/1.1 // 请求方法Origin: 当前地址 // 源地址Host: xxx.com // 目标地址Access-Control-Request-Method: PUT // CORS 请求用到哪个方法Access-Control-Request-Headers: X-Custom-Header // CORS 请求要加上什么请求 预检请求的响应： 123456789HTTP/1.1 200 OKAccess-Control-Allow-Origin: * // 表示允许请求的源，`*`表示允许任意源请求Access-Control-Allow-Methods: GET, POST, PUT // 表示允许的请求方法列表Access-Control-Allow-Headers: X-Custom-Header // 表示允许发送的请求头字段Access-Control-Allow-Credentials: true // 表示是否允许发送 CookieAccess-Control-Max-Age: 1728000 // 预检请求的有效期，在此期间不用发出另外的检测请求Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0 预检请求的响应返回后，如果请求不满足响应头的条件，会触发XMLHttpRequest 的onerror方法，后面真正的 CORS请求将不会发出去。 CORS后续请求将和简单请求情况一样，浏览器自动加上 Origin 字段…。 JSONP略 NginxVPN是正向代理，VPN获取客户端无法获取的服务器的资源，然后客户端再从VPN获取，即为正向代理。 而反向代理，主要是获取客户端的请求，分发给不同的服务器，以达到维持服务器的负载均衡的问题。 正向代理是获取客户端获取不到的服务端资源。 反向代理是将客户端的请求分发给不同的服务端处理。 其它WebSocket等… TLS1.2HTTP是明文传输协议，传输报文对外透明，不安全。引入HTTPS： HTTPSHTTPS是在HTTP下增加了一层 SSL/TLS 协议。 HTTP是明文通信，存在三个安全问题： 明文可能会被窃听。需要进行通信加密和内容加密。 不验证通信双方，可能遭遇伪装。可以利用 SSL 查明对手证书。 无法证明报文完整性，可能已遭篡改。MD5/PGP防篡改。 HTTS为解决这三个问题应运而生。 加密、解密、密钥对称加密加密、解密同用一个密钥被称为 共享密钥加密 ，也称为 对称密钥加密。 但是也要安全的传输密钥，否则一切就失去了意义。 非对称加密利用公开密钥加密，私有密钥解密，解决密钥传输安全问题。 混合加密机制 交换密钥利用公开密钥加密的方式。 建立通信交换报文使用，共享密钥加密（对称加密）方式。 即，在确保密钥安全的前提下进行对称加密通信。 TLS1.3改进待… HTTP/2改进待… 参考 《图解HTTP》 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview https://juejin.im/post/5e76bd516fb9a07cce750746]]></content>
      <categories>
        <category>前端通信</category>
        <category>前端</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端通信</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2020%2F06%2F16%2FcssBFC%2F</url>
    <content type="text"><![CDATA[BFCCSS布局基础。 概念FC（formatting context）格式化上下文。它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其它元素之间的关系和作用。 常见的FC有：BFC、IFC（行级格式化上下文）、GFC（网格布局格式化上下文）、FFC（自适应格式化上下文）。 一个通俗的解释：BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC 。 触发条件 MDN：https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context 主要因素： 根元素&lt;html&gt;。 float 的值不为 none。 overflow 的值不为 visible。 display 的值为inline-block、table-cell、table-caption。 position 的值为 absolute 或 fixed。 BFC布局规则 内部的Box会在垂直的方向一个接一个放置。 Box之间的距离虽然也可以使用 padding 来控制，但是此时实际上还是属于box内部里面，而且使用padding 来控制的话就不能再使用border属性了 。（.） Box垂直方向的距离由 margin 决定，属于同一个BFC的两个相邻的BOX的 margin 会发生重叠。 例：兄 margin-bottom:20px，弟 margin-top:20px，页面默认显示兄弟之间的 margin 为 20px。并不会累加。 弟 position 设为 absolate 或 fixed 时，兄弟元素的 ”间距“ 值会进行累加，这是利用了将相邻的兄弟元素分属于不同的BFC，来阻止margin重叠。 也可以在弟外面包裹一层 &lt;div&gt; 设置为 overflow: hidden;。将弟设置为另一个BFC内元素。 子元素的 marginbox 左边 与 父元素 borderbox 的相接触，即会进行叠加（从右往左的格式化相反），对于存在浮动也是如此。 BFC 的区域不会与 float box重叠。 例：将第二条中 弟 设置为 float:left;，则兄弟元素的上下的间距值会进行累加。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。 计算BFC的高度时，浮动元素也参与计算。 作用 自适应两栏布局。 兄设置浮动 float:left; ，弟设置BFC overflow:hidden; 。如果不设置BFC，弟一部分会隐藏在兄下面，并不会并排排列。 阻止元素被浮动元素覆盖。 兄元素设为float，弟会忽略其高度，从而隐藏在了兄的下面。将弟设置为单独的BFC即可阻止被覆盖。 可以包含浮动元素——清除内部浮动。 内部浮动元素，引起高度塌陷，给父元素设置为的BFC，使得内部元素都属于BFC区域内，以达到清除浮动，解决浮动引起的高度塌陷问题 分属于不同的BFC时可以阻止margin重叠。 layoutLayout是 IE 中的 “BFC” ，为了处理IE的兼容性，在需要出发 BFC 时，除了以上的出发条件，还要针对IE浏览器使用 zoom:1 来触发 IE 浏览器的 Layout。 演示 演示地址：https://www.cnblogs.com/xiaohuochai/p/5248536.html 参考 https://juejin.im/post/5909db2fda2f60005d2093db https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/%E5%9C%A8Flow%E4%B8%AD%E5%92%8CFlow%E4%B9%8B%E5%A4%96 https://www.cnblogs.com/xiaohuochai/p/5248536.html]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>CSS</category>
        <category>BFC</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F2020%2F06%2F16%2FcssLayout%2F</url>
    <content type="text"><![CDATA[布局梳理布局大致的几种方式。 简介 正常流 布局。 display 属性。 定位（position）。 浮动（float/BFC）。 弹性盒子（display: flex）。 网格（display: gird）。 CSS表格布局（display: table）。 多列布局。 正常流position：static; diplay: block/inline-block/inline; 所有的布局都是在正常流的基础上改动的，我们对布局进行改动时，应该与之协同，而不是与之对抗。 涉及知识点： 默认的块级元素、行内元素。 display、position基本属性特点（top，margin-top）。 盒模型、怪异盒模型。 FC（BFC…）。 定位position: ... ; 易混淆 涉及知识点： relative、absolute：top、margin-top。 position: sticky。 定位上下文。 绝对定位中的 z-index。 FC（BFC）。 浮动float:right/left; 注意高度塌陷。 涉及知识点： 经典布局（双飞翼，皇冠）。 清除浮动的场景和几种方式（clear:both）。 利用BFC清除浮动。 弹性盒子display: flex; 行内弹性盒子：display：inline-flex。 涉及知识点： flex-direction，指定主轴方向。 row-reverse和 column-reverse值反向排列 flex 项目。 flex-wrap ，换行。 flex-flow ，是（1和2）的缩写。 flex: 200px，每个项宽度为200px。（可以指定flex项的动态尺寸） 可以写三个属性（flex-grow、flex-shrink、flex-basis） 水平垂直对齐。 align-item:center，决定在交叉轴（纵轴）上的位置。（垂直居中） align-self：属性可以覆盖 align-item。 justify-content:center，决定在（主轴）横轴上的位置。（水平居中） 常用值 space-around / space-between。 排序 order （！！！） 嵌套 网格布局display:grid 在此之前，我们使用的是 flex 或者三方（bootstrap等UI框架）来实现网格的。 https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout 涉及知识点： grid-gap 网格间隔。 grid-template-columns属性。 repeat() 函数。 fr 单位。 网格实现居中小示例： 12345678910111213141516.father &#123; width: 400px; height: 400px; background-color: aqua; display: grid; grid-template-columns: repeat(4,1fr); /* 四行四列 */ grid-template-rows: repeat(4,1fr);&#125;.son &#123; background-color: aquamarine; /* 缩写：grid-area:2/2/span2/span2; */ grid-column: 2/span 2; /* 第二列开始占两列 */ grid-row: 2/span 2; /* 第二列开始占两列 */&#125; 参考 https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>CSS</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSockets]]></title>
    <url>%2F2020%2F06%2F12%2FHttp_WebSockets%2F</url>
    <content type="text"><![CDATA[双向通信 建立在 TCP 协议之上。 数据格式轻量，性能开销小，通信高效。 可以发送二进制数据。 没有同源限制，可以与任意服务器通信。 协议标示符 ws 加密为 wss。 简单使用123456789101112131415var ws = new WebSocket("wss://echo.websocket.org");ws.onopen = function(evt) &#123; console.log("Connection open ..."); ws.send("Hello WebSockets!");&#125;;ws.onmessage = function(evt) &#123; console.log( "Received Message: " + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log("Connection closed.");&#125;; APIwebSocket 对象提供了用于创建和管理 WebSocket 连接，以及相关的API。 WebSocket.readyState：返回实例对象的当前状态。CONNECTING/OPEN/CLOSING/CLOSED。 WebSocket.onopen：用于指定连接成功后的回调函数。指定多个使用 addEventListener方法。 WebSocket.onclose：用于指定连接关闭后的回调函数。 WebSocket.onmessage：用于指定收到服务器数据后的回调函数。 WebSocket.send：用于向服务器发送数据。 bufferedAmount：表示还有多少字节的二进制数据没有发送出去，可以用来判断发送是否结束。 webSocket.onerror：用于指定报错时的回调函数。 其它通讯对比轮询（短轮询）原理：请求设置定时器，每隔一段时间向浏览器发送http请求。 考验性能，数量级比较大的情况下，基于轮询对服务器的考验较大。 长轮询（comet）原理：Ajax 实现，当服务器收到客户端的请求，会将资源挂起，判断服务器端数据是否更新，如果没有更新则达到一定时间限制返回。客户端处理数据之后再次发起请求，重新建立连接。 连接挂起也会占用资源。 长连接（SSE）Server-Sent Events。它可以允许服务端推送数据到客户端。服务端数据更新可以马上发送到客户端。 ajax实现长连接： 12345678910111213141516171819202122232425$(function () &#123; (function longPolling() &#123; $.ajax(&#123; url: "$&#123;pageContext.request.contextPath&#125;/communication/user/ajax.mvc", data: &#123;"timed": new Date().getTime()&#125;, dataType: "text", timeout: 5000, error: function (XMLHttpRequest, textStatus, errorThrown) &#123; // ... 打印错误信息 if (textStatus == "timeout") &#123; // 请求超时 longPolling(); // 递归调用 // 其他错误，如网络错误等 &#125; else &#123; longPolling(); &#125; &#125;, success: function (data, textStatus) &#123; //... 操作 data if (textStatus == "success") &#123; // 请求成功 longPolling(); &#125; &#125; &#125;); &#125;)();&#125;); 对比从兼容性角度考虑： 短轮询 &gt; 长轮询 &gt; 长连接SSE &gt; WebSocket。 从性能方面考虑： WebSocket &gt; 长连接SSE &gt; 长轮询 &gt; 短轮询。 参考websocket基础 通讯对比]]></content>
      <categories>
        <category>前端通信</category>
        <category>前端</category>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 基础]]></title>
    <url>%2F2020%2F05%2F05%2Fjava%2F</url>
    <content type="text"><![CDATA[计算机基础最近也在看TS，顺便看一下后端语言，康康和JS的区别，发现较大的web项目都是用Java写的，就来了解一下。了解了强类型才能深刻了解弱类型，了解重载，才囊知道非重载，一点一点连成片….. 二进制二进制：逢二进一，每一个0或1叫bit（位）。 十进制转二进制：除以2求余。 字节字节是数据存储单元的最小单位，八位（bit）一个字节（Byte） 1 Byte = 8 bit | 1 KB = 1024 Byte | 1 MB = 1024 KB | 1GB = 1024 MB | 1TB = 1024 GB | 1PB = 1024 TB | 1EB = 1024 PB | 1ZB = 1024 EB CMDwindows 命令提示符。 快捷键：WIN +R。 切换盘符：cd/Tab。 ..返回上级文件夹。 dir 列表。 cls清屏。 exit退出。 开发环境JVMJava Virtual Machine：java虚拟机。 Java 运行在 JVM 上，JVM 的不同版本运行在各个系统上，即由各个系统的不同版本的虚拟机来实现跨平台。 JDK开发工具包 配置环境 变量编译运行java三步骤：编写、编译、（JVM）运行。 javac.exe：编译器。 源代码经过javac.exe编译后生成.class文件。 java.exe：解释器。运行时不带 后缀名。 注意：文件名要和类名保持一致。 注释1234// 单行注释/* 多行注释*/ helloworld12345678// 第一行pubilc class 定义一个类，类是Java当中所有源代码的基本组织单位public class HelloWorld &#123; // 类名要和文件名保持在一致。 // 第二行固定写法，代表main方法，是程序执行的起点。 public static void main(String[] args) &#123; // 语句内容 System.out.printIn("Hello,World!!!"); &#125;&#125; 关键字特征：全小写、编辑器特殊颜色。 标识符定义：自定义的内容就是标识符。 命名规则： 字母（区分大小写）、数字、$、_。 不能以数字开头。 不能是关键字。 命名规范： 类名规范：首字母大写（大驼峰）。 变量及方法名规范：首字母小写（小驼峰）。 常量定义：在 java 程序运行的期间固定不变的数据。 分类： 字符串常量：双引号引起来的部分。 整数常量。 浮点数常量。 字符常量：单引号引起来的单个（有且仅有一个）字符。 布尔常量。 空常量。（不能直接打印输出，报错） 数据类型基本数据类型四类八种。 整数型：byte（1Byte） short（2Byte） int（4Byte） long（8Byte） 浮点型：float（4Byte） double（8Byte 更精确） 字符型：char（2Byte） 布尔型：boolen （1Byte） 字符串不是基本类型。 浮点数是近似值。 数据范围与字节数不一定相关 浮点数默认类型是double，使用float类型要加一个 F 后缀。 整数默认是int类型，使用long类型，加 L 后缀。 引用数据类型类、数组、接口。 数据类型转换自动类型转换特点： 代码不需要处理，自动完成。 需要符合数据范围从小到大的规则（和字节数不一定相关）。 int —&gt;long —&gt; float—&gt;double 强制类型转换特点： 无法自动完成。 格式：范围小的类型 变量名 = （范围小的类型）大范围数据; int num = (int) 100L 逻辑上 范围大 转小会发生数据溢出。 编码表Ascll编码表：0~127 American Standard Code for Information Interchange：美国信息交换标准代码。 Unicode码表：万国码。从128开始添加了其他字符。 打印字符：’a’+ 0 可以查看对应码。 ‘0’—‘48’ ‘A’—‘65’ ‘a’—‘97’ 变量定义：内容可以发生改变的量。 123// 数据类型 变量名称; 创建变量。// 变量名称 = 数据值; 赋值。// 数据类型 变量名称 = 数据值; 缩写。 注意： 变量名不能重复。 FL后缀不能省。 数值不能超过范围。 先声明后使用。 不能超出作用域{}。 运算符四则运算加+减-乘*除/余%： 整数的除/，只看商，不看余。 先转换后计算。 int + double：double + double = double 加号+，char类型先转换，后相加，string类型（首字母大写，非关键字）拼接。 任何类型和字符串连接都转换为字符串。 12String str = "hello";str + 20 + 30 = "hello2030" 自加（++）自减（–） 运算符在前，前加加，先加后使用。否则相反。 常量不能参与运算。30++。 赋值运算符：+=、-=、*=、/=、%= 同样常量不能参与运算。 隐含强制类型转换。 比较运算符，结果为布尔值。 不能连写，1&lt;x&lt;3 报错，1 &lt; x &amp;&amp; x &lt; 3。 逻辑运算符：根据短路原理理解。 三元运算符：指需要三个数据才能进行操作的运算符。 三元运算符的结果必须被赋值/被使用。 1// 数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B 方法定义123456789101112/*修饰符 返回值类型 方法名(参数类型 参数名称,...) &#123; 方法体 代码; return 返回值;&#125;*/public static void funName() &#123; System.out.printIn("播种");&#125;// 方法调用funName(); 先后顺序无所谓。 方法的定义在类中，不能在方法中定义方法产生嵌套包含的关系。 返回值类型为 void 无返回值不能进行单独调用和赋值调用。 重载定义：多个方法的名称一样，但是参数类型不一样。 在 JavaScript 中是没有重载的。 java 会自动去寻找参数相同的方法执行，而在 javaScript 中，名称相同的方法，后者会覆盖前者的功能。 注意： 涉及因素：参数的个数、参数类型不同、参数多类型顺序不同。 不涉及的因素：参数名称、方法的返回值类型无关。 JDK9是最后一个大版本的更新。新特性： JShell脚本工具。 javac 数值未超过变量类型范围，编译器会自动补上强转，超过则报错。右侧为变量则不进行强转。 1234short a = 8;short b = 9;short result = 8 + 9; // int 转 short 不报错short result = 8 + a + 9; // 报错 流程顺序结构、判断结构、选择结构、循环结构。 选择结构switch 语句注意事项： case语句之后的数值不能重复。 switch 后面的数据类型只能是：（JavaScript可以是任何类型） （1）基本数据类型：byte/short/char/int。 （2）引用数据类型：String字符串、enum枚举。 顺序随意，break 语句可省略（省略后会直到遇到break，跳出）。 循环结构for 循环：初始化语句、条件判断、循环体、步进语句。 while 循环：直到逻辑。 1234567/*初始化语句;while (条件判断) &#123; 循环体; 步进语句;&#125;*/ do-while循环：先循环，后判断。 1234567/*初始化语句;do &#123; 循环体; 步进语句;&#125; while (条件判断)*/ 区别：do-while至少循环一次，初始化语句for循环只能在语句内部。 break/continuebreak：打断循环。 continue：跳出本次循环进入下次循环。 死循环之后不能有语句，会报错。 数组特点引用数据类型。 数组当中的多个数据，类型必须统一。（JavaScript 数组中的每一项可以是任意类型。） 数组的长度在程序运行期间不可改变。（JavaScript 数组的长度是动态的。） 创建 动态初始化（指定长度）。 1234// 数组类型[] 数组名称 = new 数据类型[数组长度];int[] array1 = new int[300];String[] array2 = new String[90]; 静态初始化（指定内容）。 12345678910// 数据类型[] 数组名称 = new 数据类型[] &#123; 元素1, 元素2, ... &#125;;int[] array1 = new int[] &#123; 5, 6, 7 &#125;;String[] array2 = new String[] &#123; "Hello", "World" &#125;;// 拆int[] array1;array1 = new int[] &#123; 5, 6, 7 &#125; // 简写 简写模式不支持拆分int[] array3 = &#123; 5, 6, 7 &#125; 使用 直接打印数组名称，得到的是数组对应的，内存地址哈希值。例：[I@75412c2f 数组 int 十六进制数字 12// arrayName[index]arrayName[4]; 动态初始化使用，未赋值拥有默认值。 整数 0 、浮点数0.0、 字符类型 \u0000、 布尔 false、 引用类型 null 。 内存划分 栈（Stack）：存放的都是方法中的局部变量（方法的参数或内部的变量）。 作用域：一旦超出作用域，立刻从栈内存中消失。 堆（Heap）：凡是new出来的东西，都在堆当中。其中的地址值是16进制。且都有默认值。 方法区（Method Area）：存储 .class 的相关信息，包含方法的信息。（方法运行在栈中）。 本地方法栈（Native Method Stack）：与操作系统相关。 寄存器（pc Register）：与 CPU相关。 IDEAProjectproject &gt; module &gt; Package &gt; File 常用快捷键Alt+Enter 导入包，自动修正代码。 Ctrl+Y 删除光标所在行。 Ctrl+D 复制光标所在行的内容，插入到光标位置下面。 Ctrl+Alt+L 格式化代码。 Ctrl+Shift+/ 多行注释。 Alt + Insert 自动生成代码。 Alt+Shift + 上下箭头移动当前行。 Shift + F6 同时选中用到的单词 5fori for循环五次。]]></content>
      <categories>
        <category>技术</category>
        <category>后端技术</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>后端技术</tag>
        <tag>技术</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染机制]]></title>
    <url>%2F2020%2F04%2F09%2FWeb_BrowserRenderingMechanism%2F</url>
    <content type="text"><![CDATA[前言在从浏览器接收到请求后，开始进行浏览器渲染。本文深入浏览器内核的主进程涉及的两个关键引擎，渲染引擎，JS引擎来说明，从而可以更好的理解这个环节上的性能优化。 渲染引擎：深入理解浏览器的渲染机制也有助于我们理解三大框架的生命周期执行时机。 JS引擎：对DOM树的影响、对CSSOM的影响、EventLoop。 服务端渲染：意义及优缺点。 渲染引擎渲染概述从请求到文件到构建渲染树再到调用系统API[GUI]进行渲染进行的一系列过程。 webkit流程图 parser：解析器、sheets：篇/片、render：渲染、attachment：附件、附著、layout：布局。 流程图解析 构建DOM树：请求、解析。 构建CSSOM树：请求、解析。 构建渲染树：Attachment合并，但diplay: none 将不渲染到渲染树。 布局渲染树：layout过程（回流，自动重排），计算定位、坐标、大小、转换行、position、overflow、z-index属性等。 绘制render树：（转换为像素）绘制顺序—背景、浮动、content、padding、border…。 Layout过程JS 动态修改了DOM属性或者CSS属性会导致重新Layout：repaint（重绘）、reflow（重排）。 repaint reflow 触发方式 不改变定位，宽高，改变了元素的展示方式 影响了文档的内容、结构或者元素定位 例 background-color,border-color,visibility等 DOM操作（增删改，变换元素顺序）。内容的变化，Form表单中文字的变化。计算改变CSS属性。增加删除样式表。浏览器窗口操作（改变大小、滚动窗口）激活伪类（如：hover状态） 重新布局 部分 绝大部分 优化过程中尽量不要触发重排（reflow）。 offsetTop/Left/Width/Height、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、IE中的getComputedStyle()，或currentStyle，等。 从上到下解析流程 从上到下解析HTML模板。 遇到.css。（在另一个进程中进行） 不会阻塞DOM解析，阻塞渲染HTML，接着请求.css文件。 解析.css文件。 遇到 DOM节点。 解析DOM 遇到img请求 发起请求，继续渲染下面代码。 请求成功，影响了页面排布，重新渲染这部分代码。 遇到.js等脚本文件 停止所有加载和解析。 请求和执行脚本。 css 不会阻塞DOM树解析。 但是会阻塞DOM树渲染。 css加载会阻塞后面js语句的执行。 优化 使用CDN，会根据网络状况加载最近的文件。 合并及压缩CSS文件，减少请求。 简化和优化CSS选择器。 使用精灵图，减少请求。 合理使用缓存，减少请求。 CSS在前，JS文件在后。 JS引擎触发JS引擎触发js引擎及对渲染引擎的影响： JS引擎触发时机：在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。 JS操作DOM元素带来的影响： 因为 DOM 是属于渲染引擎中的东西，而 JS 是在 JS 引擎中运行的。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个script标签时，DOM构建将暂停，直至脚本完成执行。但由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS。 操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 使用defer和async异步加载JS。 EventLoop定义JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。 此处指的是浏览器引擎中的EventLoop，node中的EventLoop是另一种机制。 引入EventLoop 进程是正在运行着的程序，一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。 为了避免复杂性，发明JS语言时使其是单线程的。即，只有一个主线程（虽然可以创建多个子线程，但是受主线程控制）。 单线程意味着任务都必须排队进行，而Js引擎异步执行Js代码又不会等待，这是因为有了消息队列和事件循环。 在浏览器中，每打开一个标签页就打开了一个进程。一个进程中又包含多个线程，比如：GUI 渲染线程、JavaScript引擎线程、定时触发器线程、定时触发器线程、异步http请求线程。 EventLoop图解 执行栈（主线程） 一个存储函数调用的栈结构，遵循先进后出的原则，形成了执行栈。 栈的大小是有限的。比如，发生死循环栈溢出时会报错：Maximum call stack exceeded。 执行JS文件时，遇到同步任务，即普通调用函数就压入栈中。 当执行栈中的任务完成后，系统会读取任务（消息）队列，并且把它压入执行栈执行。 任务（消息）队列异步的运行结果会放入任务队列里，当主线程（执行栈）空了，就会读取任务队列里的异步结果。 消息队列中的消息Message就是注册异步任务时添加的回调函数。 宏/微任务 任务（消息）队列就是放着注册异步任务时添加的回调函数的队列，而根据不同的任务又分为两种宏任务队列和微任务队列。 macro-task （宏任务队列）：比如script（整体代码）、setTimeout、setInterval、 I/O 操作、UI 渲染等。 micro-task（微任务队列）： 比如new Promise().then(回调)、MutationObserver(html5新特性) 等。 一次eventloop执行机制： 检查上一个micro-task队列是否为空，然后执行一个tasks（macro-task）。 继而执行清空本次所有的micro-task。 本次eventloop中的micro-task队列清空后，再从 1 开始执行。 影响 渲染影响：执行完microtask队列里的任务，有可能会渲染更新。如果在一帧（一次）内多次发生DOM的变动，浏览器不会立即响应，而是会积攒变动以最高60HZ的频率更新视图。 定时器问题：定时器到达预定时间后会将回调函数放到任务队列里，但是需要等执行栈里的代码执行完毕才会开始读取任务队列，因此一般会把定时任务放在代码的最后，为了可以更加准确的读取定时任务的回调函数。 堆对象被分配在堆中。（存储形式，不涉及该处知识点） 例题 单次循环，宏/微任务机制。（基础） 12345678910setTimeout(()=&gt;&#123; console.log(1) Promise.resolve(3).then(data=&gt;&#123; console.log(data) &#125;)&#125;,0)setTimeout(()=&gt;&#123; console.log(2)&#125;,0)// 1,3,2 宏/微任务，先检查上一个微任务是否清空。 1234567891011121314console.log('script start');setTimeout(function() &#123; // 第二轮宏任务 console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; // 第一轮微任务 console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// 1.script start 2.script end 3.promise1 4.promise2 5.setTimeout 加入构造函数 1234567891011121314151617console.time("start"); setTimeout(()=&gt;&#123;console.log(2)&#125;,10); // 第二轮宏任务 new Promise((resolve)=&gt;&#123; // 同步代码，第一轮宏任务 console.log(3); resolve(); console.log(4);&#125;).then(()=&gt;&#123; // 第一轮微任务 console.log(5); console.timeEnd("start");&#125;);console.log(6); // 同步代码，第一轮宏任务console.log(8);requestAnimationFrame(()=&gt;console.log(9)); // 第三轮宏任务// 34685 计时时间 29 优化 减少DOM操作。 将 script 标签放在 body 标签底部。 合理使用defer和async。 定时器放在代码底部。 浏览器查看用浏览器 performance 选项录制，可以查看脚本运行，计算布局render树构建，painting所花费的时间。 其它性能观测待更… 服务端渲染服务端渲染 SSR(server side rendering) ，就是原本在浏览器做的HTML解析这个步骤放到了web服务器来做，解析完后直接发给客户端，来作为构建render树的DOM树。 node.js篇中有说明服务端渲染的优缺点。点击本链接直接搜索服务端渲染即可。 参考css加载会造成阻塞吗？ 浏览器渲染及js eventloop 渲染优化 深入浅出渲染机制原理 MDN—EventLoop 单线程JS ryf 宏/微任务 浅谈SSR 与部分作者意见不一致，谨慎参考。]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>浏览器渲染机制</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 基础]]></title>
    <url>%2F2020%2F04%2F02%2FLinux%2F</url>
    <content type="text"><![CDATA[操作系统简介 用户 —&gt;应用程序—&gt;操作系统—&gt;计算机硬件 操作系统：系统调用 、终端命令、图形窗口，即可以在操作系统上安装高级语言的环境，用高级语言开发程序。 操作系统常见分类 桌面操作系统：Windows 系列、macOS、Linux。 服务器操作系统：Linux、Windows Server。 嵌入式操作系统：Linux。 移动设备操作系统：iOS、Android (基于Linux)。 虚拟机定义：虚拟机指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整的计算机系统。 可以在 VMWare 中安装虚拟机。 Linux历史及版本 C语言 —&gt; Unix—&gt; Linux 内核版本： 是运行程序和管理硬件设备的核心程序。它提供了裸机与应用程序间的抽象层。 内核版又分为：稳定版和开发版，两个版本互相关联，互相循环。 发行版本： 建立在内核版本之上开发的桌面环境、办公套件、媒体播放器、数据库等应用软件。 常见的发行版本：Ubuntu/Redhat/Fedora/openSUSE 等 。 十大 Linux 服务器版 排行榜：http://os.51cto.com/art/201612/526126.html。 文件及目录结构根目录：/ 二级目录： /bin 可执行二进制文件目录。 /etc 系统配置文件存放的目录。 /home 用户家目录。 /lib、/user等等等等。 用户目录：home目录下的 admin 用户—&gt;/admin 用户下目录：/Desktop、/Documents、/Download… 命令格式了解格式，方便查阅。 1234command [-options] [parameter]# ls 查看文件内容# rm main.txt 删除文件# rm -r main 删除 main 目录 command：命令名，相应功能英文单词缩写。 [-options]：选项，对命令进行控制，可以省略。 parameter：传给命令的参数。 查阅命令 --help 12command --help# 显示 command 命令帮助信息 man 12man command# 查阅 command 命令的使用手册 man 是 manual 的缩写，包含了绝大部分命令的详细使用说明 man 操作键： 操作键 功能 空格键 显示手册下一屏 Enter 滚动到下一行 b 回滚下一屏 f 回滚前一屏 q 退出 /word 搜索word字符串 终端实用技巧 自动补全 tab 键，如果没有歧义，系统自动补全，如果有再按一下tab，提示可能存在的命令。 上下光标键 可以切换曾经使用过的命令。 ctrl + c 退出选择。 文件目录特点Linux 文件或者目录 名称最长可以有 256 个字符。 目录 . 代表当前目录。 .. 代表上一级目录。 文件 以 . 开头的文件为隐藏文件，需要用 -a （all）参数才能显示。 常用命令拓展增删改查 命令 对应英文 作用 ls list 查看当前文件夹下的内容 pwd print work directory 查看当前所在文件夹 cd [目录名] change directory 切换文件夹 touch [文件名] touch 如果文件名不存在新建文件 mkdir [目录名] make directory 创建目录 rm [文件名] remove 删除指定文件名 clear clear 清屏 ctrl + shift + = 略 放大终端字体 ctrl + - 略 缩小 字体 ls拓展说明list简写，列出当前文件夹下的内容，类似于 DOS 下的 dir 命令。 常用选项 参数 含义 -a （all） 显示指定目录下的所有目录与文件，包括隐藏文件 -l 以列表形式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 通配符 通配符 含义 * 代表任意个数字符 ？ 代表任意一个字符，至少一个 [] 表示可以匹配字符组中的任意一个 [abc] 匹配 a、b、c中的任意一个 [a-f] 匹配从 a 到 f 范围内的任意一个字符 例： 12345ls 1* # 以 1 开头ls *1 # 以 1 结尾ls *3* # 包含 3 的文件ls ?3.txt # 匹配如 43.txtls [123]45.txt # 匹配 145.txt 245.txt 345.txt cd拓展说明：change directory 的简写，更改当前的工作目录。 注意：Linux 所有的 目录 和 文件名 都是大写小写敏感的 常用方式: 命令 含义 cd 切换到当前用户主目录 cd ~ 切换到当前用户主目录 cd . 当前目录不变 cd .. 上级目录 cd - 在最近两次工作目录之间切换 相/绝对路径绝对路径： /和~开头的就是绝对路径，相对于根目录或家目录。 相对路径：只要不是 /和~开头的就是相对路径，只相对于当前目录。 touch拓展 如果文件不存在，可以创建一个空白文件。 如果存在，修改文件末次修改日期。 mkdir拓展 创建新文件。 -p 可以递归创建目录。例：mkdir -p a/b/c/d 分别创建了 abcd 新建目录名称不能和其他目录重名。 rm拓展 可以删除文件或目录。 -f 强制删除，忽略不存在的文件，不需提示。 -r 递归删除目录下的内容，删除文件夹必须加这个参数。 rm 删除的文件是不能恢复的 拷贝和移动文件 命令 对应英文 作用 tree [目录名] tree 以树状图列出文件目录结构 cp 源文件 目标文件 copy 复制文件或目录 mv 源文件 目标文件 move 移动/重命名文件或目录 tree拓展 以树状图列出文件目录结构。 -d 只显示目录，不再显示文件。 tree ~ 树状显示家目录。 cp拓展 复制命令，相当于 DOS 下的 copy 命令。 -i 覆盖文件前提示“是否覆盖？”。 -r 若给出的源文件是目录文件，将递归 复制该目录下的所有子目录和文件。 mv拓展 可以用来 移动/重命名文件或目录。 覆盖文件前提示“是否覆盖？”。 查看文件内容 命令 对应英文 作用 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 more 文件名 more 分屏显示文件内容 grep 搜索文本 文件名 grep 搜索文本文件内容 cat拓展 查看文件内容时，显示全部（适合文件内容较少的文件）。 -b 输出包括行号，不包括空行。 -n 输出包括行号及空行。 Linux 中还有一个 nl 的命令和 cat -b 的效果等价。 more拓展 查看文件内容时，显示部分，分屏显示。 空格键 Enter键 b 、f 、 q 分别为下一行下一页上一页和退出。 /word 搜索 word 字符串。 grep拓展 grep 允许对文本文件进行模式查找，即，正则表达式。 -n 显示匹配行及行号。 -v 显示不包含匹配文本的所有行（求反）。 -i 忽略大小写。 常用的模式查找： ^a 行首，搜寻以 a 开头的行。 ke$ 行尾，搜索以 ke 结束的行。 其它echo 文字内容 echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用。 重定向 &gt; 和 &gt;&gt; Linux 允许将命令执行结果 重定向到一个 文件。 将本应显示在终端上的内容 输出/追加 到 指定文件中。 &gt; 表示输出，会覆盖源文件内容。 &gt;&gt;表示追加，会将内容追加到已有文件。 12ls &gt; a # 把列表内容输出到 a 文件里echo Hello World &gt;&gt; a # 把 Hello World 追加到 a 文件里 管道 | Linux 允许将一个命令的输出 可以通过管道做为 另一个命令的输入。 [写入的内容] | [读取的内容] 12ls -lha ~ | more # 将 home 下所有的文件通过 more 进行分屏显示ls -lha ~ | grep DO # 将 home 下所有的文件中 包含 DO 的文件输出 远程管理命令拓展关机/重启 命令 对应英文 作用 shutdown 选项 时间 shutdown 关机、重新启动 shutdown拓展 shutdown 命令可以安全关闭或者重新启动系统。 -r 重新启动。 -c 取消关机 注意： 不指定选项和参数，默认表示 1分钟后关闭电脑。 远程维护服务器时，最好不要关闭系统，应该重新启动系统。 12345shutdown -r now # 立即重启shutdown now # 立即关机shutdown 20:25 # 在这个时候关机shutdown +10 # 十分钟后关机shutdown -c # 立刻取消上一个关机动作 查看或配置网卡信息 命令 对应英文 作用 ifconfig configure a network interface 查看、配置计算机当前的网卡配置信息 ping ip地址 ping 检测到目标 ip 地址的连接是否正常 概念网卡：是一个专门负责网络通信的硬件设备。 IP地址：设置在网卡上的地址信息。 将电脑比作电话，那么网卡相当于 SIM 卡，IP地址 相当于 电话号码。 ipconfig拓展1ifconfig | grep inet # 查看配置信息中包含 inet 的内容，及IP信息 ping拓展工作原理类似雷达：我们给目标IP地址发送一个数据包，对方返回一个数据包，根据返回的数据包及时间确定目标主机的存在。 1ping 127.0.0.1 # 检测本地网卡是否工作正常 SSH基础（重点）SSH（Secure Shell）安全外壳协议，Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境，及创建安全隧道。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。 Linux之SSH Linux 中 SSH 是非常常用的工具，通过 SSH客户端 我们可以连接到 SSH服务器 的远程机器上。 正确的使用SSH可以有效地避免信息泄露（进行加密）、提高传输速度（对数据进行压缩）。 域名端口号域名是为了方便记忆，端口号可以找到计算机运行的程序。SSH服务器的默认端口号是 22。 常见服务端口号： SSH服务器：22 Web服务器：80 HTTPS：445 FTP 服务器：21 SSH 客户端的简单使用Linux 大多自带SSH，可在终端命令使用。Windows 系统需要安装客户端软件PuTTY、XShell、MobaXterm。 123456# 使用 ssh 连接登录ssh [-p port] user@remote# user 用户名，不指定默认为当前用户# remote 远程机器地址，可以是IP/域名/别名# port 是 SSH Server 监听的端口，如果不指定，默认值为 22# -p 就是指定端口号的选项 exit 退出当前用户的登录。 1ssh -p 22 home@172.16.140.138 SCP（掌握）安全复制（英语：Secure copy，缩写SCP）是指在本地主机与远程主机或者两台远程主机之间基于Secure Shell（SSH）协议安全地传输电脑文件。 12345# 路径：如果不是绝对路径，则为用户家路径的相对路径# 将本地目录下的文件复制到远程家目录下scp -P port 01.py user@remote:Desktop/0.1py# 将远程家目录下的文件复制到本地目录下scp -P port user@remote:Desktop/0.1py 01.py -P P要大写。 1234# 将当前目录下的demo文件夹复制到家目录下的Desktopscp -r demo user@remote:Desktop# 将家目录下的Desktop复制到当前目录下的demo文件夹scp -r user@remote:Desktop demo windows 中可以安装 PuTTY，使用pscp命令传输，或者安装FileZilla使用FTP进行文件传输。 FileZilla 在传输文件时，使用的是 FTP服务而不是SSH服务，因此端口号应该设置为21。 SSH高级（知道） 有关 SSH 配置信息都保存在用户目录下的.ssh目录下 免密码登录 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote 可以让远程服务器记住我们的公钥。 原理 第一条命令在本地SSH客户端生成两条秘钥（公钥、私钥）。 第二条命令将公钥复制到SSH服务器。 本地使用私钥对数据进行加密、解密。 服务器使用公钥对数据进行加密、解密。 非对称加密算法： 使用公钥加密数据，需要使用私钥解密。 使用私钥加密数据，则需要使用公钥解密。 配置别名当我们想用 ssh user 来代替经常输入的 ssh -p port user@rermote 时，可以在配置文件~/.ssh/config （没有该文件就创建）里面追加一下内容： 1234Host mac HostName ip地址(remote) User userName(user) Port 22 scp 同样也可以使用。 用户权限命令拓展基本概念权限 用户管理包括 用户 与 组 管理。 每个系统都拥有一个账号，对于不同的系统资源拥有不同的使用权限。 每一个用户针对不同的文件或目录也有不同的权限。 这些不同的权限包括： 权限 英文 缩写 数字代号 读 read r 4 写 write w 2 执行 excute x 1 ./my.py 表示执行当前文件夹下 my.py 文件。 组给用户分组，方便进行用户管理。 文件/目录-rwxrw-r-- 1 user user 43 5月 9 00:00 user.txt - 开头代表是文件。 d 开头代表是目录。 接下来三个分为一组，一共三组，分别为：拥有者权限、用户组权限、其他用户权限。 接下来是硬链接数（cd 可以切换到该文件的方式种数），子目录越多硬链接数越大。 拥有者、组、大小、时间、名称。 权限修改chmod（重要） chmod 可以修改 用户、组 对文件、目录的权限。 命令格式为：chmod +/-rwx 文件名|目录。 超级用户 Linux系统中的root账号通常用于系统的维护和管理，对操作系统的所有资源都具有访问权限。 不推荐直接使用 root 账号登录系统。 在Linux安装过程中，系统会自动创建一个用户账号，这个默认用户称为“标准用户”。 sudo su是 substitute user的缩写，表示使用另一个用户身份。 sudo 用来以其他身份来执行命令，预设的身份为 root。 用户使用 sudo 必须先输入密码，有5分钟的有效期，过期限必须重新输入密码。 未授权的用户使用sudo ，会发出警告邮件给管理员。 组管理相关命令 创建组、删除组的终端命令都需要通过 sudo 执行。 命令 英文 作用 groupadd 组名 略 添加组 groupdel 组名 略 删除组 cat /ect/group 略 确认组信息 chgrp -R 组名 文件/目录名 change group 修改文件/目录的所属组 提示： 组信息保存在 /etc/group 文件中。 /etc 目录是专门用来保存 系统配置信息 的目录。 1234sudo groupadd dev # 创建一个dev组cat /etc/group # 查看是否创建成功sudo groupdel dev # 删除组 分组12345mkdir fileName # 创建 fileName 文件sudo groupadd dev # 创建 dev 组cat /etc/group # 查看是否创建成功ls -l # 查看文件夹下文件权限sudo chgrp -R dev fileName/ # 修改所属组 用户管理相关命令创建用户/设置密码/删除用户 命令 作用 说明 useradd -m -g 组新建用户名 添加新用户 1. -m 自动建立用户家目录。2. -g 指定用户所在组，负责会建立一个同名的组。 passwd 用户名 设置用户密码 如果是普通用户，直接用 passwd可以修改自己的账户密码。 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录。 cat /etc/passwd \ grep 确认用户信息 新建用户后，用户信息会保存在/etc/passwd文件中。 12sudo useradd -m -g dev userName # 创建新用户userName,并将其指定给dev组sudo passwd userName # 设置用户密码 创建用户时忘记添加 -m 选项指定新用户家目录，可以删除用户重新创建。 查看用户信息 命令 作用 id [用户名] 查看用户 UID 和 GID 信息。 who 查看当前所有登录的用户列表 whoami 查看当前登录的账户名 /etc/passwd文件存放的是用户的信息，由6个冒号:分组成的7个信息： 用户名、密码（x表示加密的密码）、UID（用户标识）、GID（组表示） 用户全名或本地账号、家目录、登陆之后，使用的终端命令—Shell（ubuntu默认是dash） usermodusermod 可以用来设置用户的主组、附加组和登录Shell： 主组：通常在新建用户时指定，在etc/passwd 的第4列 GID 对应的组。 附加组：在 etc/group 中的最后一列表示该组的用户列表，用于指定用户的附加权限。 12345678# 修改用户主组（passwd 中的 GID）usermod -g 组 用户名# 修改用户附加组usermod -G 组 用户名# 修改用户登录 Shellusermod -s /bin/bash 修改用户附加组要重新登陆生效 例如： 123# 默认使用 useradd 添加用户是没有权限使用 sudo 即以 root 身份执行命令的。# 可以使用以下命令，将用户添加到 sudo 附加组中usermod -G sudo 用户名 which（重要） /etc/passwd 可用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 which 命令可以查看执行命令所在位置。 123which passwd # 输出 /usr/bin/passwdwhich ls # 输出 /bin/lswhich useradd # 输出 /usr/sbin/useradd bin和sbin在 Linux 中，绝大多数可执行文件都保存在/bin、sbin、/usr/bin、/usr/sbin。 /bin（binary）是二进制执行文件目录，主要用于具体应用。 /sbin（system binary）是系统管理员专用的二进制代码存放目录、主要用于系统管理。 /usr/bin （user commands for applications）后期安装的一些软件。 /usr/sbin（super user commands for applications）超级用户的一些管理程序。 切换用户相关命令 命令 作用 说明 su - 用户名 切换用户，并且切换目录 可以切换到用户家目录，否则位置保持不变 exit 退出当前登录账户 su 后不接用户名，可以切换到 root，不推荐因为不安全。 exit 退回到前一用户 12su userName # 切换到userName的当前目录su - userName # 切换到userName的家目录 修改文件权限相关命令 命令 作用 chown 修改拥有者 chgrp 修改组 chmod 修改权限 12345chown 用户名 文件名|目录名 # 修改文件|目录的拥有者chgrp -R 组名 文件名|目录名 # 递归修改文件|目录的组chmod -R 755 文件名|目录名 # 递归修改文件权限 755：7代表拥有者权限、5代表组权限、5代表其他用户权限。 -R 递归执行所有文件 可读（read） 可写（write） 可执行（excute） 值 字母代号 4 2 1 7 rwx 4 2 0 6 rw- 4 0 1 5 r-x 4 0 0 4 r– 0 2 1 3 -wx 0 2 0 2 -w- 0 0 1 1 –x 0 0 0 0 — 755： 7指 拥有者具有可读可写可执行权限。 5指 组拥有可读可执行权限。 5指 其他用户拥有可读可执行权限。 系统信息相关命令查询系统信息即通过远程终端维护服务器，查看服务器上当前系统日期和时间、磁盘空间占用情况、程序执行情况 时间和日期 命令 英文 作用 cal calendar 查看日历，-y选项可以查看一年的日历 date 略 查看系统时间 磁盘和目录空间 命令 英文 作用 df -h disk free 显示磁盘剩余空间 du -h[目录名] disk usage 显示目录下的文件大小 -h 以人性化的方式显示文件大小 进程信息 进程，当前正在执行的程序。 命令 作用 ps a/u/x process status 查看进程的详细情况 top 动态显示运行中的进程并且排序 kill [-9] 进程代号 终止指定代号的进程，-9表示强行终止。 ps拓展 ps 只会显示当前用户通过终端启动的应用程序。 a 选项 显示终端上所有进程，包括其他用户的进程。 u 选项显示进程的详细版本。 x 选项显示没有控制终端的进程（不是终端启动的进程）。 %cpu/%mem：分别为cpu占用率和内存占用率。 PID 表示进程代号，kill中会用到。 top拓展 退出top可以直接输入q。 kill拓展 使用 kill 命令时，最好指终止当前用户开启的进程，不要终止 root 身份开启进程， 否则可能导致系统崩溃。 其他命令查找文件find 通常用来在特定的目录下 搜索符合条件的文件。 1find [路径] -name "fileName.txt" 如果省略路径表示在当前文件夹下查找。 可以使用通配符。 例： 12find -name "*name*"find -name "*.txt" 其他用法：按权限、时间等去搜索 软链接 建立文件的软链接，就类似于Windows下的快捷方式。可快速访问。 命令 作用 ln -s 被链接的源文件 链接文件 建立文件的软链接 没有 -s 则创建的是一个硬链接文件。（由于两个文件占用相同的硬盘大小，因此一般不会建立硬链接） 源文件要使用绝对路径，不要用相对路径。（方便软链接移动后仍然可以正常使用） 12345678cat fileName.py # 查询文件内容tree # 查看目录结构mv fileName.py demo/a/b # 移动文件tree # 检查移动结果ln -s /home/user/Desktop/demo/a/b/fileName.py Link # 给fileName创建软链接 Linkcat Link # 查看软链接内容ls -l # 查看列表显示 Link—&gt;demo/a/b/fileName.py 硬链接（知道） 硬链接，有多少种方式可以访问文件或目录。 ln创建链接时，如果没有 -s选项，则会创建一个硬链接文件。 ls -l可以查看硬连接数。 相当于复制了一份文件名指向文件数据，源文件删除了，依然可以访问硬链接文件。 在Linux中，文件名和文件的数据是分开存储的，文件名指向文件数据。 创建软链接文件名—&gt;软链接文件数据—&gt;文件名—&gt;文件数据。 打包压缩在不同的操作系统中，常用的打包压缩方式是不同的： Windows 常用 rar、Mac常用zip、Linux常用tar.gz。 打包/解包tar 是 Linux 中最常用的备份工具，这个命令可以把一系列文件打包到一个大文件中，也可以把打包文件恢复成一系列文件。 12345# 打包文件tar -cvf [name].tar 被打包文件/路径...# 解包文件tar -xvf 打包文件.tar c ，生成档案文件，创建打包文件。 x ，解开档案文件。 v ，列出归档解档的详细过程，显示进度。 f ，指定档案文件名称，f后面一定是.tar文件，所以必须放在选项最后。 f 要放在最后 12345678910rm -r *touch 01.txttouch 02.txt # 创建文件tar -cvf name.tar 01.txt 02.txt # 打包ls -lh # 查看文件mkdir tarmv name.tar tartreecd tartar -xvf name.tar # 解压文件 压缩/解压缩gzip tar与gzip命令结合使用，实现文件 打包和压缩。 tar命令中有个选项-z可以调用gzip，从而可以方便的实现压缩和解压缩的功能。 在Linux中，最常见的压缩文件格式就是xxx.tar.gz。 12345678# 压缩文件tar -zcvf [name].tar.gz 被打包压缩文件/路径... # 解压文件tar -zcvf [name].tar.gz # 解压缩到指定路径tar -zcvf [name].tar.gz -C 目标路径 -C 解压到指定路径，该目录必须存在。 bzip2（two） 和 gzip 用法一样，扩展名为xxx.tar.bz2。 在tar命令中用-j选项调用bzip2来实现。 12345678# 压缩文件tar -jcvf [name].tar.bz2 被打包压缩文件/路径... # 解压文件tar -jcvf [name].tar.bz2 # 解压缩到指定路径tar -jcvf [name].tar.bz2 目标路径 软件安装通过 apt 安装/卸载软件 apt （全称：Advanced Packaging Tool）是Linux下的一款安装包管理工具。 可以在终端中方便的 安装/卸载/更新软件包。 12345678# 安装软件sudo apt install 软件包# 卸载软件sudo apt remove 软件名# 更新安装包sudo apt upgrate 例如： 123sudo apt install sl # 安装小火车提示sudo aot install htop # 作用类似 top 命令 配置软件源希望在ubuntu更加快速的安装软件，可以设置镜像源。]]></content>
      <categories>
        <category>技术</category>
        <category>计算机基础</category>
        <category>计算机系统</category>
        <category>Linux 基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机系统</tag>
        <tag>Linux 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2020%2F03%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构还是要逐步拾起数据结构，以及记录一下面试遇到的一些算法题。 排序快速排序123456789101112131415161718192021var arr = [10,28,25,38,20,35,56]function quickSort (arr) &#123; if (arr.length&lt;=1) &#123; // 结束递归条件 return arr; &#125; let left = []; // 声明 左 let right = []; // 声明 右 let pivot = arr[0]; // 声明 基准数 for (let i=1;i&lt;arr.length;i++)&#123; if (arr[i]&lt;arr[0])&#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(pivot,quickSort(right)); // 递归 拼接&#125;quickSort(arr)/* 缺点：声明了两个数组，不是原地排序，增加了空间复杂度。*/ 阮一峰快速排序 去重暴力法12345678910111213141516171819202122232425var nums = [1,2,3,1];var containsDuplicate = function(nums) &#123; var res = []; var flag = true; for (var i = 0;i&lt;nums.length-1;i++) &#123; for(var j= i+1;j&lt;nums.length-1;j++)&#123; if (nums[i] == nums[j]) &#123; flag = false; break; &#125; &#125; if (flag === true) &#123; res.push(nums[i]); &#125; else &#123; flag = true; &#125; &#125; return res;&#125;;containsDuplicate(nums);/*break 跳出本次循环continue 跳出本次迭代 继续执行return 跳出函数返回函数值*/ 算法解密问题题目字符串解密问题，一个单词奇数位抽出来做前半部分，偶数位倒序后做后半部分，拼接起来，形成一个串，你要解密出原来的字符串。加密过程 Welcome—&gt; Wloe + mce，你要做加密算法 答案123456789101112131415var str = 'Welcome';function changeCode(str)&#123; var arr = str.split(''); // split('') 转为数组 var left = []; var right = []; for(var i = 0;i&lt;arr.length;i++)&#123; if((i%2) == 0)&#123; // 0、2、4...在奇位 left.push(arr[i]) // 尾部压入 W l o e &#125; else &#123; // 1、3、5...在偶位 right.unshift(arr[i]) // 头部写入 m c e &#125; &#125; return left.concat(right).join('') // 拼接转字符串&#125;changeCode(str) // "Wloemce" 三数之和题目给定一个包含 n 个整数的数组 arr，判断 arr 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 爬楼梯题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 答案12345678910function upStairs(n)&#123; if (n===1) &#123; // 结束递归条件 return 1 &#125; else if (n===2)&#123; // 结束递归条件 return 2 &#125; else if (n&gt;2)&#123; return upStairs(n-1) + upStairs(n-2) // 递归 &#125;&#125;upStair(8) // 34 割绳子题目总共有n条长度不等绳子，可以任意切割，不能拼接。要求切割后得到m条长度相等的绳子，求问得到的m条绳子长度L的最大值？ 思路：m*n 进行排序 圆桌分奖品题目圆桌n个人，每一个人有一个得分，相邻两人中得分高的人得到的奖品比得分低 的人多。每个人至少获得一个奖品，问一桌人至少需要准备多少奖品？ 思路：只有一个极小点 最多，极小点越少就越少。 字符串相加数组最大深度]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function 理解]]></title>
    <url>%2F2020%2F03%2F26%2FJS_Function%2F</url>
    <content type="text"><![CDATA[Function 类型每一个函数都是 Function 类型的实例。 内部属性this、arguments、caller thisthis引用的是函数执行的环境对象。 arguments类数组对象，包含着传入函数的所有参数。这里指的是实参。 cellee其中的，cellee属性指向arguments对象的函数。 callerECMA 5。caller 中保存着调用当前函数的函数的引用。 函数属性函数是对象，因此函数也有属性和方法。其中，属性包括：length、prototype length表示函数希望接收到的命名参数的个数。即，形参个数 prototype保存着实例方法的真正所在。 函数方法函数是对象，因此函数也有属性和方法。其中，方法包括：call()，apply()、bind()。 call()在特定的作用域调用函数。不传参指向全局作用域，即：等于设置函数体内 this 对象的值。 apply()与 call() 功能相同，传参方式不同 bind()ECMA 5。不是立即调用的 创建函数使用Function构造函数、函数声明、函数表达式 使用Function构造函数只是为了理解。最后一个参数为 函数体 。 1var a = new Function("num1","num2","return num1 + num2"); 函数声明函数声明形式会存在 函数提升 1234function sum (num1,num2) &#123; return num1 + num2;&#125;sum(); 函数表达式不存在 函数提升 1234var sum = function () &#123; return num1 + num2;&#125;; // 像声明其它变量一样这里要有 ;sum(); 闭包闭包是指有权访问另一个函数作用域中的变量的函数。 作用域链步骤： 执行流进入执行的环境，会将执行环境压入环境栈中（先进后出）。 而在环境中执行时会有一个变量对象，这里存储着所在环境的所有的变量或者函数或其它可访问的数据。 如果执行环境是函数，会将活动对象作为变量对象。其中包括 arguments 对象。 作用域链被保存在内部的 [[Scope]] 属性中。 向上就近原则，即，向上查询变量名和函数名，找到后就停止。 注意： 使用 with 语句（不建议使用）和 try-catch 语句的 catch 语块 作用域链。 没有块级作用域。 if 语句变量声明会添加到当前执行环境。 for 执行结束依然存在外部执行环境。 var 声明的会添加到最近的环境。未声明的会添加到全局作用域 ES6： 引入了块级作用域。 引入了 let 、const 声明。 理解闭包函数在全局中执行，执行完毕后，局部作用域就会被销毁，内存中仅保存全局作用域。闭包是一个函数中定义了另一个函数，内部函数的作用域链就存在了三层：全局（全局变量）、外部函数（外部函数变量）、内部函数（活动对象，内部变量）。内部函数可以根据作用域链访问外部函数里的变量和函数就称为 闭包。 变量问题闭包只能取得外部函数中变量的最后一个值。 返回一个 函数数组 每个函数都返回自己的索引值。 1234567891011function createFunctions () &#123; var result = new Array(); for (var i=0;i&lt;10;i++)&#123; result[i] = function()&#123; return i; &#125; &#125; return result;&#125;createFunctions()// (10) [ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ] 都 return 10 解决：再创建闭包，并将值立即传入。 12345678910111213function createFunctions () &#123; var result = new Array(); for (var i=0;i&lt;10;i++)&#123; result[i] = function(num)&#123; return function ()&#123; return num; &#125;; &#125;(i) &#125; return result;&#125;createFunctions()// (10) [ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ] 各自 return 0~9 this问题this 指向调用它的函数的作用域。且在调用时就会取得这个指向当前调用的作用域的 this ,并将其放到自己的活动对象里去，在自己活动对象中找到后就不再继续向上查找了，因此 this 值是永远不可能向上查找的。 123456789101112 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; function c()&#123; console.log(this.b) console.dir(this) // Window 对象 &#125; c() &#125; &#125;object.a() // 全局作用域 解决：保存变量var that = this 12345678910111213 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; var that = this; function c()&#123; console.log(that.b) console.dir(that) // Object 实例对象 &#125; c() &#125; &#125;object.a() // 局部作用域 箭头函数123456789 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; return ()=&gt;&#123; console.log(this.b) &#125; &#125;&#125;object.a()() // 局部作用域 call()/apply()/bind()12345678910 var b = "全局作用域"; var object = &#123; b : "局部作用域", a : function () &#123; return ()=&gt;&#123; console.log(this.b) &#125; &#125;&#125;object.a.call()() // 未传值 打印全局作用域object.a.call(object)(); // 局部作用域 内存泄漏垃圾回收机制原理JavaScript 具有自动垃圾回收机制。原理：垃圾收集器会按照固定的时间间隔，并周期性的执行，即，找出不再继续使用的变量，然后释放其占用的内存。 策略标记清除： 各个浏览器垃圾收集的时间间隔不同。 引用计数： 循环引用造成内存泄漏。 IE中BOM/DOM是COM对象，其采用的机制就是基于引用计数策略，当涉及COM对象，就会造成内存泄漏。 解决：在不使用时，将循环引用的变量置为空 null。 管理内存局部变量在其离开执行环境时会自动被解除引用。对于全局变量和全局对象我们需要手动将其置为 null，解除引用。 闭包中的内存泄漏问题1：IE 中闭包的作用域链中保存一个 HTML 元素，由于引用计数和循环引用，导致该元素无法被销毁。 解决： 将该元素副本保存在变量中，在闭包中引用该变量，解除循环引用。 使用结束后将该元素置为空，解除对DOM元素对象的引用。 问题2：内部函数引用外部函数，外部函数活动对象无法及时销毁。 解决：只有将 内部函数 设置为 null ，解除对内部函数的引用，通知垃圾回收机将其清除，才能够将整个作用域安全销毁，除了全局作用域。 递归自身调用自身。 12345678var factorial = (function f(num) &#123; if (num&lt;=1) &#123; return 1; &#125; else &#123; return num * f(num-1) &#125;&#125;)// 计算阶乘 模仿块级作用域ES5 中没有块级作用域（私有作用域），但是可以用 匿名函数来模仿。 123456789(function()&#123; // 这里是块级作用域&#125;)();// 理解var a = function()&#123; // 这里是块级作用域&#125;;a(); 使用场景12345678function outputNumbers (count) &#123; (function () &#123; for (var i=0;i&lt;count;i++) &#123; alert(i); &#125; &#125;)(); alert(i); // 报错&#125; 在函数内部，限制向全局作用域添加过多的变量和函数。 可以避免命名冲突而导致全的局污染。 可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。函数执行完毕，就立即清除了其作用域链。 私有变量在函数中定义的变量，称为私有变量。私有变量包括：函数参数、局部变量、函数中定义的其他函数。 特权方法有权访问私有变量和私有函数的公有方法称为特权方法。 构造函数中即，在构造函数中定义函数，根据闭包的原理访问私有变量。 静态私有变量通过在私有作用域中 定义私有变量或函数创建特权方法。 模块模式为 单例 创建私有变量和特权的方法。 增强的模块模式ES6中的变化 let const 声明 块级作用域 {} 箭头函数 高级函数函数的一些高级使用方法： 安全的类型检测、作用域安全的构造函数、惰性载入函数、函数绑定、函数柯里化 引用 《JavaScript 高级程序设计》 MDN 箭头函数 阮一峰ES6块级作用域 阮一峰ES6函数扩展]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>Function</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object 理解]]></title>
    <url>%2F2020%2F02%2F14%2FJS_Object%2F</url>
    <content type="text"><![CDATA[Object 对象a person or thing to which a specified action or feeling is directed. 翻译：指定的动作或感觉针对的人或事物。 理解对象123456789101112var person = &#123; "name": "Nicholas", // 基本值 "age": "18", look: &#123; // 对象 "height": 182, "weight": "60kg" &#125;, sayName: function () &#123; // 函数 alert(this.name) &#125;&#125;;console.dir(person.age) 定义对象是 一组无序属性的集合。这里的属性可以包括 基本值、对象、函数。（ECMA-262） 属性类型而这些属性分为两种 数据属性，访问属性。它们拥有一些特性，用来给JS引擎解析，告诉浏览器这个对象可以进行哪些操作，这些特性均有默认值。 属性特性以下是它们的特性： 是否：[configurable]可删除及定义 [enumerable]枚举 [writable]更改 [value]值 [get]读取 [set]写入 数据属性 ：[configurable]、[enumerable]、[writable]、[value] 访问属性：[configurable]、[enumerable]、[get]、[set] 内置对象定义：对象是一组数据和功能的集合。 理解：数据类型：值类型(基本类型)7种：字符串（String）、数字(Number)、大整数（BigInt）、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（符号、代表）。 引用数据类型 Object此处列举了部分 内置对象 目的：提供这些原生的引用类型，是为了 方便开发人员实现常见的计算任务。 对象(Object)、数组(Array)、函数(Function)、日期（Date）、正则（RegExp）。 Object是一个基础类型，其他所有类型都从Object继承了基本行为。 基本包装类型（Boolean/Number/String）。 JavaScript 中的基本类型的值，可以被当做 对象 来访问。 单体内置对象（Global/Math）。 Global 全局对象，在浏览器中是window对象 Math 用于计算 就像其他基本数据类型一样，比如，字符串类型可以使用内置对象所有操作字符串的方法。同样，任何对象类型也都继承了所有 Object 的原型方法。而接下来讨论的 自定义对象 就讨论了它是如何实现的。 自定义对象顾名思义，定义自己的对象。 原始方法:原始方法1：使用 Object() 构造函数。 12var o = new Object();o.name = ... 原始方法2：使用 字面量 。 123456789101112var person = &#123; name: "Nicholas", // 基本值 age: "18", look: &#123; // 对象 height: 182, weight: "60kg" &#125;, sayName: function () &#123; // 方法 alert(this.name) &#125;&#125;;console.dir(person.age) 缺点：多次创建时，会产生许多重复代码。因此引入了函数（工厂模式） 工厂模式1234567function createPerson(name,age,&#123;height,weight&#125;)&#123; var o = new Object(); o.name = ... return o;&#125;var person1 = person("Nicholas","29",&#123;160,"60kg"&#125;)var person2 = person("Tom","18",&#123;182,"70kg"&#125;) 缺点：无法识别对象的类型。因此引入了 new 构造函数模式 构建函数模式构造函数模式（1）123456789function Person(name,age,&#123;height,weight&#125;)&#123; this.name = name this.age = ... this.sayName: function () &#123; // this.sayName = new Function("alert(this.name)") alert(this.name) &#125;&#125;var person1 = new Person("Nicholas","29",&#123;160,"60kg"&#125;)var person2 = new person("Tom","18",&#123;182,"70kg"&#125;) 当使用 new 操作符的时候，实际上进行了一下4个步骤： 创建一个新的对象。 将构造函数的作用域赋给了新的对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为新对象添加属性） 返回新对象 缺点：每次都要把构造函数中的方法在实例上再创建一遍。因此引入了（2）。 构造函数模式（2）123456789101112function Person(name,age,&#123;height,weight&#125;)&#123; this.name = name this.age = ... this.sayName = sayName;&#125;function sayName() &#123; alert(this.name)&#125; var person1 = new Person("Nicholas","29",&#123;160,"60kg"&#125;)var person2 = new person("Tom","18",&#123;182,"70kg"&#125;) 将函数挂载到全局，共享。 缺点：全局污染、没有封装性可言了。因此引入原型模式 原型模式原型模式（1）1234567891011function Person()&#123;&#125;Person.prototype.name = "Nicholas";...Person.prototype.sayName = function () &#123; alert(this.name)&#125;var person1 = new Person()alert(person1.name)var person2 = new person()person2.name = "Tom"alert(person2.name) 原型模式（2）简写： 12345function Person()&#123;&#125;Person.prototype= &#123; name:"Nicholas", ...&#125; 缺点：引用类型被共享，不利于部分数据私有化。引入混合模式 混合模式最常见的方式 12345678910function People(name,eye)&#123; this.name = name; this.eye = eye;&#125;People.prototype.say = function ()&#123; alert (this.name); console.log(this)&#125;var man4 = new People("Flancer一号","small");man4.say(); 其它除此之外还有，寄生构造函数模式、稳妥构造函数模式。 继承组合继承是如今最常见的继承方法。 1234567891011// 使用 混合模式 People 对象function People(name,eye)&#123; this.name = name; this.eye = eye;&#125;People.prototype.say = function ()&#123; alert (this.name); console.log(this)&#125;var man = new People("Flancer一号","small");man.say(); 使用 组合继承 123456789101112131415161718/* * 使用 混合模式 构建 Manman 对象 * 使用 组合继承 实现 Manman对象 继承 People对象*/function Man (name,eye,huzi) &#123; this.huzi = huzi; People.call(this,name,eye) // 属性继承&#125;Man.prototype = new People() // 原型继承Man.prototype.sayhuzi = function () &#123; alert(this.huzi) console.log(this)&#125;var boy = new Man("Flancer二号","big","胡子");boy.sayhuzi();boy.say(); 寄生组合传承12345function inserit(son, father) &#123; var obj = Object.create(father.prototype); son.prototype = obj; obj.constructor = son&#125; 123456789101112131415161718/* * 使用 混合模式 构建 Manman 对象 * 使用 组合继承 实现 Manman对象 继承 People对象*/function Man (name,eye,huzi) &#123; this.huzi = huzi; People.call(this,name,eye) // 属性继承&#125;inserit(Man,People) // 寄生继承 原型Man.prototype.sayhuzi = function () &#123; alert(this.huzi) console.log(this)&#125;var boy = new Man("Flancer二号","big","胡子");boy.sayhuzi();boy.say(); 关于原型链 任何对象在创建时都会有一个__proto__内置属性，它指向创建这个对象的构造函数的原型prototype = {}。除了 undefined 和 NULL，没有构造他们的东西。 任何 函数 (虽然只有函数，也就是除了基本数据类型的所有东西) 在创建时都会给予拥有一个名为prototype的属性，这个属性指向该函数的 原型对象。 在创建 prototype 的同时会在其内部放一个 constructor 指向它的构造函数。 高级技巧可以让开发人员定义 防篡改对象。 防篡改对象通过改变对象属性的特性来指定对象行为。一旦把对象定义为防篡改，就无法撤销了。 方案它们分别为，不可扩展对象、密封对象、冻结的对象。 ES6 中的对象Class一种建立在 原型链原理 上的语法糖。 12345678910111213141516171819202122232425262728293031323334class A &#123; static myMethod() &#123; // 静态方法 不会继承到实例，可以继承到子类，通过调用类调用 return 'hello'; &#125; constructor()&#123; // 构造函数 this.num = 1; &#125; toValue () &#123; // 原型 console.log(this.num) &#125;&#125;A.myMethod(); // 调用静态方法// 子类 B 继承 Aclass B extends A &#123; static myMethod() &#123; // 静态方法 super.myMethod(); // 继承父类静态方法，通过调用类调用，this指向子类而不是实例 &#125; constructor()&#123; super(); // 继承构造函数 this.num = 2; &#125; m () &#123; super.toValue() // 继承原型 &#125; &#125;// 子类 B 实例let b = new B();b.m() // 2 注意 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 方法后面不要加 逗号，会报错。 默认为严格模式。 不存在变量提升。 新扩展Object.assign方法 引用 《JavaScript 高级程序设计》 原型链图片 内存图]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>原生JS</category>
        <category>Object</category>
      </categories>
      <tags>
        <tag>原生JS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float 相关]]></title>
    <url>%2F2019%2F03%2F28%2FcssFloat%2F</url>
    <content type="text"><![CDATA[float 相关定义float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反） 如何定位当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。 理解display首先 float 属性会影响到页面的布局，所以涉及到一些 display 的一些块级元素（block），内联元素（inline）及内联块级（inline-block）的知识。 因为 float 元素 定义： “允许文本和内联元素环绕它” 可以使文本和兄弟内联元素环绕，也是设计该属性的初衷。 因为 float 元素定义： “该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性” 对于该句我是这样理解的： 首先 block元素 的默认宽度是 width:auto; 自动调整宽度。在不带float的情况下，block元素 的宽度会自动调整至最大化占据整行，而float元素会自动调整至最小化，在不设置宽高的情况下会被内容撑起。 float元素仅会对自身（宽高默认自适应但可设置），文字及内联兄弟元素（inline元素）环绕，下一个兄弟float元素产生影响。 对于块级（block元素会另起一行）、兄弟父元素（忽略其高度） 及 父兄元素（相对父元素排列，与float元素无关）。 因此： 它会将 float 元素当做 display：block 元素去计算宽高（像是自动添加了 block 框），包裹性 即可设置宽高。 block元素默认高度也是 height:auto 由内容撑起，在计算高度（height 值）时，会忽略浮动的元素的高度，而基于此父元素的下一个文档流的父兄弟元素就也会忽略该浮动元素，及为其父亲 带来 高度塌陷问题。 float 特性总结img div float 使用 float 可以带来 ： 将元素浮向左或右、宽高默认自适应、文字及内联元素环绕、包裹性（可设置宽高）、高度塌陷（高度被父忽略）。 清除浮动为什么要清除浮动根据 float 的 特性，当这些特性影响了我们的布局，即，超出了我们的设计的预期时，我们就想要清除浮动。主要是为了解决 清除文字环绕，和高度塌陷带来的布局问题。 如何清除 利用 clear 属性 利用 BFC 全文参考 float：https://developer.mozilla.org/zh-CN/docs/CSS/floatdisplay：https://developer.mozilla.org/zh-CN/docs/Web/CSS/displayposition：https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#Absolute_positioning块级元素：&lt;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements float对内联元素和块元素的影响 清除浮动的四种方式及其原理理解 完全理解float之“不完全脱离文档流” 理解为何需要清除浮动及清除浮动的方法 行内元素在为什么设置浮动后可以设置高宽 inline-block和float的共性和区别]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>CSS</category>
        <category>float</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Position]]></title>
    <url>%2F2019%2F03%2F28%2FcssPosition%2F</url>
    <content type="text"><![CDATA[position 定位问题position：static position:static,静态定位，这种定位是默认的，即正常的文档流，一般没有实际作用 特点 静态定位的元素不会受到 top right bottom left 的影响 position：relative position:relative,相对定位，不会脱离文档流，类似于static,默认按照顺序排列，可以通过 margin-top / top margin-right / right margin-bottom / bottom margin-left / left来改变元素的位置，（注意在简写的时候也是按照这个顺序，顺时针），可以看出，都只是相对于正常位置的偏移。 特点 相对于它原本的正常位置偏移，因此它原本的所占的空间不会改变。也就是说，在它之下的文档流元素依然按照它原本的位置排列。 经常被用作绝对定位的容器块。 position：absolute position:absolute,绝对定位，脱离文档流，可以用 top right bottom left​ 来控制元素的位置，需要注意的是，它是相对于最近祖先为非static定位来定位的，如果它的父级元素定位是默认的，它会继续向上找，直到找到为止，如果页面上没有，就相对于 html 。 特点 由于它是脱离文档流的，因此它的变动是不会对文档流的其他布局产生影响的。 在 absolute 定位下，float: left/right ,对它是不起作用的 子绝父相 即，父元素是相对定位（position：relative），子元素是绝对定位（position:absolute），被经常用来定位元素。因此相对定位经常被用作容器块。 position : fixed position : fixed,固定定位，它是相对于浏览器窗口来进行定位的，例如我们经常在网页中见到的 回到顶部 按钮就是利用这种定位，一般使用 top right bottom left,进行操作。 特点 它同样也脱离了文档流，它的位置与文档流无关。 fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才会支持 position：sticky—– 这个定位好好玩啊啊啊，之前没有用过（暴露了我的无知、浅薄、傻了吧唧）。o(╥﹏╥)o position:sticky ,粘（zhan）性定位,基于用户的滚动位置来定位的。它有一个由 top/right/bottom/left构成的特定阀值，也必须有他们才能使粘性定位生效。在跨越特定阀值之前为相对定位（position：relative）,之后为固定定位（position:fixed）,固定在目标位置。 特点： Internet Explorer,Edge 15 及 更早的 IE 版本不支持 sticky 定位。 Safari需要使用 position: - webkit-prefix;来做兼容 。]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>CSS</category>
        <category>position</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6——Readme]]></title>
    <url>%2F2019%2F03%2F27%2FJS_ES6%2F</url>
    <content type="text"><![CDATA[简介：ES6 在这里就不给详细科普了 ES6 全称ECMAScript 6.0 ,是JavaScript的新的一个版本标准，说是为了： 适应更复杂的应用； 实现代码库之间的共享； 不断迭代维护新版本； 兼容性，各大浏览器基本上都支持 ES6 的新特性。（时代在进步，这里对于这个必然趋也不进行过多叙述了） Chrome Firefox 兼容的最好 IE 7~11基本不支持（万恶的兼容之源） 本文是在老的基础上对比新的来学习，毕竟在项目里并不都是ES6。顺便温故而知新。 新的声明方式：old: ver 不支持封闭作用域，会声明到全局作用域 12345for (var i = 0;i&lt;3;i++)&#123; console.log(i); // 0 1 2&#125;console.log(i); //结果是 3 3 3//意思是在for循环里声明的变量，在全局也可以拿到 old 解决方法，把它放到一个匿名函数里去 (function(){ for (var i = 0;i&lt;3;i++){ console.log(i) } })(); console.log(i);// 0 1 2 以及定时器问题 for(var i = 0;i&lt;3;i++){ setTimeout(function(){ console.log(i); },1000); } //for循环是同步代码，setTimeout()是异步代码。根据事件环，同步代码执行完毕之后，才执行异步代码，此时变量i已经是全局的变量i且为3，因此结果为3 3 3 3 3 ... //by the way : 在项目开发中要记得清理定时器: var flag = setTimeout(fn,1000); clearInterval(flag); //后面准备专门写一篇关于内存泄露的，这里打个标记 (#^.^#) old 解决方法： for(var i = 0;i&lt;3;i++){ (function(i){ setTimeout(function(){ console.log(i); },1000); })(i); } // 结果 ：0 1 2 new: let let 和 {} 配合可以产生一个作用域 let 支持块级作用域，声明的变量只会声明在当前作用域内 for(let i = 0;i&lt;3;i++){ setTimeout(function(){ console.log(i); },1000); // 结果 ：0 1 2 } console.log(i); // undefined let 可以解决作用域污染问题和局部作用域问题 new 不可以在同一作用域下多次声明 let a = 3 //不同作用域，因此可以 function fn(){ let a = 1; let a = 2; // 报错 } old 可以 var a = 3 function fn(){ var a = 1; var a = 2; //不会报错 } 域解释问题 ——变量提升 new 没有变量提升，以及要避免暂存死区（避免） console.log(b) let b = 1; // undefined let a = 1; { console.log(a); // undefined let a = 2; } old 变量提升只提升变量名，并不赋值 console.log(a); //undefined var a = 1; console.log(a); // 1 new : const const 与 let 基本一致 const声明的变量不能被修改，指的是不能被修改引用空间 const a = 1; a = 2; //报错，不能给常量赋值 const a = {name:’xyz’} a.age = 9; console.log(a); //没有修改引用空间，因此可以。 解构赋值 解构赋值 声明和赋值都放到了一起 解构 表示等号左边和右边解构类似 数组的位置必须相同 1let [,age] = ['十八'，18] 对象解构时的名字必须相同 12let &#123; length &#125; = ['十八'，18];console.log(length); // 2 如果有关键字可以采用 : 的形式进行更改名字 12let &#123;name,age,default:d&#125; = &#123;name:'十八'，age:18,default:'灰喵'&#125;console.log(d); // 灰喵 多层取数/取默认值 如果想设置某个属性的默认值 必须采用 = 号的形式 12345let [, &#123;address: [,a]&#125;,hobby='挠人'] = [ &#123; name:'十八' &#125;, &#123; age: 15,address:[1,2,3] &#125;,]console.log(hobby); // 挠人 解构的应用 12345678910111213function ajax(&#123;url=new Error('url without'),type="get",data=xxx&#125;) &#123; console.log(url,type,data);&#125;ajax(&#123; url:'/test', type:'get', data:&#123;&#125;&#125;)function test() &#123; return [1,2,3];&#125;let [a,b,c] = test(); 模板字符串模本字符串 取代了 原有的字符串拼接 1234let name = '十八';let age = 15;let str = `hello~'$&#123;name&#125;'今年$&#123;age&#125;岁了`console.log(str); // hello~'十八'今年15岁了 支持换行 和 取值 ${} 1234let str = `&lt;ul&gt; &lt;li&gt;$&#123;name&#125;&lt;/li&gt; &lt;li&gt;$&#123;age&#125;&lt;/li&gt;&lt;/ul&gt;` 如何实现 一个类模板字符串的功能 12345str = str.replace(/\$\&#123;([^]*)&#125;\)/g,function () &#123; console.log(arguments) return eval(arguments[1]); //with&#125;);console.log(str); 带标签的模板字符串 自定义模板字符串的实现 1234567891011121314function meStr()&#123; console.log(arguments) // &#123;'0':['hello~','今年','岁了'],'1':'十八','2':15&#125; let strings = arguments[0]; // Array.prototype.slice.call() let values = [].slice.call(arguments,1) // 将后两项转为数组 ['十八'，15] let str = '' for(let i = 0;i&lt;values.length;i++)&#123; str += `$&#123;strings[i]&#125;*$&#123;values[i]&#125;*` &#125; str += strings[strings.length-1]; return str&#125;let str = meStr`hello~'$&#123;name&#125;'今年$&#123;age&#125;岁了`;console.log(str); 补充：常用字符串方法 123456789101112131415161718let url = 'http://F-lancer.io/node.html'// includes 是否包含console.log(url.includes('lancer'))// startsWith 以xxx开头console.log(url.startsWith('http://'))// endsWith 以xxx结尾console.log(url.endsWith('.html'))// 进制转换 padStart padEnd 补全setInterval(function () &#123; let date = new Date(); let hour = date.getHours(); let minutes = date.getMinutes(); let seconds = date.getSeconds(); let str = `$&#123;hour.toString().padStart(2,0)&#125;:`; // 不满两位 补 0 str += `$&#123;minutes.toString().padStart(2,0)&#125;:`; str += `$&#123;seconds.toString().padStart(2,0)&#125;`; console.log(str)&#125;,1000) 箭头函数优点 ：箭头函数写起来简单，解决了 this 的问题。 与高阶函数的对比： 箭头函数没有 function 的关键字 小括号和大括号之间有个箭头 123456function fn(a) &#123; return a;&#125;let fn = (a) =&gt; &#123; return a&#125; 如果参数是一个，可以省略小括号 123let fn = a =&gt; &#123; return a&#125; 如果没有 return 可以不写大括号 1let fn = a =&gt; a; 例： 12345678910111213141516function a(c) &#123; return function (d) &#123; return c+d; &#125;&#125;// 等价于let a = c =&gt; d =&gt; c+d;console.log(a(1)(2));// 注意 返回一个对象时 加个括号（）function a(c) &#123; return function (d) &#123; return &#123;sum:c+d&#125;; &#125;&#125;let a = c =&gt; d =&gt; (&#123;sum:c+d&#125;); 解决 this 问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// old way // (1) 谁调用指向谁let obj = &#123; b:1, a:function()&#123; console.log(this) &#125;&#125;console.log(obj.a()); // this为,&#123; b:1, a:[Function:a] &#125; ,第二个 console为 undefine// (2) window 调用 指向windowlet fn = obj.a;fn(); // (3) 同理 定时器 也指向 windowlet obj=&#123; b:1, a:function () &#123; setTimeout(function()&#123; console.log(this); &#125;,1000) &#125;&#125;obj.a(); // 指向window// (3.1) 想要使其指向 obj (old way) var that = this;let obj = &#123; b:1, a:function () &#123; let that = this; setTimeout(function()&#123; console.log(that); &#125;,1000) &#125;&#125;obj.a(); // 指向 obj// (3.2) 使用 bind() 方法 改变指向 或 call() apply() (备选);let obj = &#123; b:1, a:function () &#123; setTimeout(function()&#123; console.log(this); &#125;.bind(this),1000) &#125;&#125;obj.a(); // 指向 obj 箭头函数没有 this 指向，因此会向上找 this，就解决了 this指向被改变的问题 12345678910111213141516171819let obj=&#123; b:1, a:function () &#123; setTimeout(()=&gt;&#123; console.log(this); &#125;,1000); &#125;&#125;obj.a() // &#123;b:1,a:f&#125;let obj=&#123; b: 1, a: () =&gt; &#123; setTimeout(()=&gt;&#123; console.log(this); &#125;,1000); &#125;&#125;obj.a() // window 例： 1234567891011121314151617let a = 1;let obj = &#123; a:2, b:()=&gt;&#123; console.log(a); &#125;&#125;obj.b(); // a = 1; 对象不是作用域，所以会找到外面let a = 1;let obj = &#123; a:2, b:()=&gt;&#123; console.log(this); &#125;&#125;obj.b(); // this = window;this.a = undefined 对象不是作用域，所以会找到外面,let不会声明到全局 箭头函数中 没有 arguments 可以使用 剩余运算符 ... 只能放到最后一个（剩余全部） 1234567891011let fn = (x,...args) =&gt; &#123; console.log(args)&#125;fn('x',1,2,3,4) // [1,2,3,4]//等同于let fn = (...arguments) =&gt; &#123; let arg = arguments.slice(1); console.log(args);&#125;fn('x',1,2,3,4) 可以设置默认值 1234let fn = (x=1,y=2) =&gt; &#123; console.log(x+y);&#125;fn() 展开运算符例 1： 123456789// apply 可以把参数用数组的方式传，即可以一个个传function spread(x,...args)&#123; // sum.apply(null,agrs); 等价于 sum(...args); // 展开预算符&#125;function sum(a,b,c,d)&#123; console.log(a,b,c,d);&#125; spread('x',1,2,3,4) 例 2： 123// concat 拼接转换let arr = [1,2,3].concat([4,5,6]); // 等价于let arr = [...[1,2,3],...[4,5,6]]; // 展开两个数组拼接到一起 例 3： 12// 展开求最小值Math.min(...[1,2,3,4]) 例 4： 1234// 展开对象let name = &#123;name:'十八'&#125;;let age = &#123;age:'15'&#125;;let cat = &#123;...name,...age&#125;; 例 5：深浅拷贝 123456789101112131415161718192021// 利用 slice 拷贝 为浅拷贝 一维数组就是深拷贝let b = [1,2,3];let a = [b];let c = a.slice(0);console.log(c); // [[1,2,3]]b[0] = 100;conosle.log(c); // [[100,2,3]] 随之改变为浅拷贝// ...运算符也是浅拷贝 一维数组就是深拷贝let name = &#123; name: &#123;name:'十八'&#125;&#125;;let age = &#123; age: 9 &#125;;let cat = &#123; ...name, ...age &#125;;name.name.name = '喵喵';console.log(cat); // &#123; name: &#123; name: '喵喵' &#125;, age: 9 &#125;// 深拷贝的实现 // 补充：JSON.Stringify() 用于将 对象/值 转为JSON格式 // JSON.parse() 解析JSON字符串// 以下不支持 函数 ，且都会强制性都变为对象，无法继承let obj = &#123;a:1,fn:function(params) &#123;&#125;,t:/a/,d:new Date,b:null&#125;;console.log(JSON.parse(JSON.stringify(obj))); 实现深拷贝（保留继承关系，实现各种类型的拷贝）123456789101112131415function deepClone(obj) &#123; if(typeof obj !== 'object') return obj; if(obj == null) return null; if(obj instanceof Date) return new Date(obj); if(obj instanceof RegExp) return new RegExp(obj); Object.prototype.toString.call(obj) === '[object Array]' let o = new obj.constructor(); // 保留类的继承关系 for(let key in obj)&#123; //是对象就递归 o[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key] &#125; return o;&#125;let o = &#123; a: &#123; a: 1 &#125; &#125;;let newObj = deepClone(o);console.log(newObj); 数组新增及常用方法map() some() every() filter() forEach() es5 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1) forEachArray.prototype.forEach = function (fn) &#123; for(let i = 0;i&lt;this.length;i++) &#123; fn(this.[i],i); &#125;&#125;;[1,2,3].forEach((item,index)=&gt;&#123; console.log(item,index);&#125;)// 2) map返回值 返回值是一个新数组Array.prototype.map = function (fn) &#123; let arr = []; for (let i=0; i &lt; this.length; i++) &#123; arr.push(fn(this[i],i)); &#125; return arr;&#125;let arr = [1,2,3].map(item =&gt; &#123; return item*2;&#125;);console.log(arr);// 3) filter 过滤 如果返回true表示留下 返回false表示删除let arr = [1,2,3];let filterArr = arr.filter(item=&gt;&#123; return item&gt;2;&#125;);console.log(filterArr);// 4) find 查找 返回查找的那一项，找到后就不会继续找了，没有返回 undefinedlet f = [1,2,3].find(item=&gt;&#123; return item === 2;&#125;);console.log(f);// 5) some 找到后返回true，找到false可以用every （找到第一个不为条件的截止）let r = [2,1,3].some(item =&gt; &#123; console.log(item); return item === 1;&#125;);console.log(r);// 6) includes 是否包含console.log([1,2,3].includes(3)); find() findIndex() es6 reduce() 收敛 叠加 123456789101112131415161718192021222324252627282930313233343536373839// 1) reduce 返回的结果是叠加后的结果 迭代根据设置叠加// prev 第一项 next第二项 currIndex循环次数 ary传入的数组[1,2,3,4].reduce((prev, next, currIndex, ary) =&gt; &#123; return prev+next; // 返回的结果会给予下一次迭代的 prev&#125;,0) // 加 0 多循环一次// 2) 求平均数[1,2,4,3].reduce((prev,next,currIndex,ary) =&gt;&#123; if (ary.length-1 === currIndex)&#123; return (prev+next)/ary.length &#125; return prev+next;&#125;);// 3) 对象[&#123;price:10&#125;,&#123;price:20&#125;,&#123;price:30&#125;].reduce((prev,next,currIndex,arr) =&gt; &#123; return prev +next.price // 若为 prev.prive + next.price 结果为 NaN&#125;,0) // 0 设置初始值，使得第一次遍历为 0+10,不设置就从第一项开始// 4) 原理Array.prototype.myReduce = function (fn,prev) &#123; for (let i = 0;i&lt;this.length;i++)&#123; if(typeof prev === 'undefined')&#123; prev = fn(this[i],this[i + 1],i + 1,this); i++; // 保证不错乱 &#125;else&#123; prev = fn(prev,this[i],i,this); &#125; &#125; return prev;&#125;[1,2,3].myReduce((prev,next,currIndex,ary) =&gt; &#123; return prev + next&#125;)// 5) 利用 reduce 展平二维数组let flat = [[1,2,3],[4,5,6]].reduce((prev,next,index,ary)=&gt;&#123; return [...prev,...next];&#125;) for of() Array.form () 1234567// 将类数组转化为数组function a()&#123; //此处不能传参，传残就表示只能一个或指定个数 console.log(eval(Array.from(arguments).join('+')))&#125;a(1,2,3);// 常见的类数组有 htmlCollection（html的元素集合）、arguments、&#123;0:1,1:2,2:3,length:3&#125; of() 12345let ary = new Array(3);console.log(ary); // 声明的数组为三个空项 [ empty , empty , empty ]let ary = Array.of(3);console.log(ary); // 声明的数组为 [3] 对象Object.assign() 1234let name = &#123;name:'十八'&#125;;let age = &#123;age:9&#125;;let obj = Object.assign(name,age); // 浅拷贝console.log(obj); // 等同于 console.log(&#123;...name,...age&#125;) ; __proto__ 链 Object.setPrototypeOf() 可以在对象内直接操作 __proto__ 123456789101112131415161718192021let obj1 = &#123; name: "十八" &#125;;let obj2 = &#123; age: 9 &#125;;obj1.__proto__ = obj2;console.log(obj1.age);// 等价于Object.setPrototypeOf(obj1,obj2);console.log(Object.getPrototypeOf(obj1));// 子中获取父的名字let obj = &#123; age: 9, name: '十八'&#125;;let obj = &#123; name:'喵喵', getPName () &#123; // 可以通过 super 关键字获取父属性 return super.name &#125;, __proto__:obj2&#125;console.log(obj.name) // 喵喵console.log(obj.getPName()) // 十八 类 class在 es5 中没有类的概念，通过 构造函数 模拟类 类的继承三种属性: 公有属性（__proto__）、私有属性、静态方法（静态属性） 如何实现一个类：(es5) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Parent () &#123; // 构造函数中的 this 通过 new 调用，那么 this 指代的是实例 this.name = 'parent'; //私有属性&#125;Parent.prototype.eat = function()&#123; console.log('eat'); // 公有属性 // 这里有个 constructor 属性指向 Parent&#125;let parent = new Parent(); // 实例上有 __proto__ 指向 Parentconsole.log(Parent.prototype.constructor === Parent); // trueparent.__proto__.eat(); // eat 会先去私有属性中找，找不到去公有属性里找function Child () &#123; this.age = 9; // 构造函数中的 this 通过 new 调用，那么 this 指代的是实例 Parent.call(this); // 等价于 this.name = 'parent' 实现继承私有属性&#125;Child.prototype.smoking = function()&#123; console.log('smoking')&#125;let child = new Child();console.log(Child.age) // undefined// 继承私有属性 Parent.call(this);console.log(child.name)// 继承公有属性// 使用 Child.prototype = Parent.prototype; 使其互相影响变成兄弟关系，非继承关系Child.prototyoe.__proto__ = Parent.prototype; // es5中的方法Object.setPrototypeOf(Child.prototype,Parent.prototype); // es6Child.prototype = Object.create(Parent.prototype) // 可以实现只继承公有属性// 原理：function create(parentPrototype,props)&#123; function Fn()&#123;&#125; Fn.prototype = parentPrototype; let fn = new Fn(); for(let key in props)&#123; Object.defineProperty(fn,key,&#123; ...props[key], enumerable:true &#125;); &#125; return fn;&#125;Child.prototype = Object.create(Parent.prototype,&#123;constructor:&#123;value:Child&#125;&#125;);let child = new Child();console.log(child.constructor) // 会指向 parent 的 Constructorlet a = &#123;&#125;;a.name = 1;// 等价于Object.defineProperty(a,'name',&#123; enumerable:true, // 使其可枚举 configurable:true, // 可删除 writable:true, // 可编辑 get()&#123;&#125;, // 这两个就不能写 write 和 value set()&#123;&#125;, value:1 // 只定义这个是看不到的，及不可枚举型&#125;); class（类）12345678910111213141516171819202122232425262728293031// 类 可以继承 公有 私有 和 静态方法class Parent&#123; constructor()&#123; this.name = 'parent'; return &#123;&#125;; // 如果在父类返回一个引用空间，则子类中的 this 指向了这里 &#125; static b()&#123; return 2; &#125; eat()&#123; console.log('eat'); &#125;&#125;class Child extends Parent&#123; // 要求继承父亲的私有和公有 constructor()&#123; super(); // Parent.call(this); this.age = 9; // 私有属性 &#125; static a()&#123; // 静态方法 return 1; &#125; smoking()&#123; // 原型上的方法 console.log('smoking') &#125;&#125;let child = new Child();console.log(child.b())// 总结：1.类只能 new// 2.类可以继承公有私有和静态方法// 3.父类的构造函数中返回了一个引用类型，会作为子类的this。及可以指定继承对象 原理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 类的调用检测function _classCallCheck (instance,constructor) &#123; if (!(instance instanceof constructor))&#123; throw new Error('抛出错误，未用你 new 调用') &#125;&#125;// 创建类function definePropertys(target,arr) &#123; for(let i = 0;i&lt;arr.length;i++)&#123; Object.defineProperty(target,arr[i].key,&#123; ...arr[i], configurable:true, enumerable:true, writeable:true &#125;) &#125;&#125;/* construtor 构造函数 protoPropertys 原型方法描述 staticPropertys 静态方法的描述*/function _createClass(constructor,protoPropertys,staticPropertys) &#123; if (protoPropertys.length&gt;0)&#123; definePropertys(constructor.prototype,protoPropertys) &#125; if (staticPropertys.length&gt;0)&#123; definePropertys(constructor,staticPropertys) &#125;&#125;let Parent = function () &#123; // 写逻辑 function P() &#123; _classCallCheck(this,P); //类的调用检测 如果this是P的实例，则是 new 出来的 this.name = 'parent'; return &#123;&#125;; &#125; _createClass(P, // 属性描述器 [ &#123; key: 'eat', value: function()&#123; console.log('吃') &#125; &#125; ],[ &#123; key: 'b', value: function()&#123; return 2; &#125; &#125; ]); // 创建类 return P;&#125;();let p = new Parent();p.eat(); 继承： 12345678910111213141516171819202122232425// 子类继承父类function _inherits(subClass,superClass) &#123; // 继承公有属性 subClass.prototype = Object.create(superClass.prototype,&#123;constructor:&#123; value:subClass&#125;&#125;); // 继承静态方法 Object.setPrototypeOf(subClass,superClass);&#125;let Child = (function(Parent)&#123; // 先实现继承父类的公有属性和静态方法 _inherits(C,Parent); function C()&#123; _classCallCheck(this.C); let obj = Parent.call(this); let that = this; if(typeof obj === 'object')&#123; that = obj; &#125; that.age = 9; // 解决了父类返回一个引用类型的问题 return that; &#125; return C;&#125;)(Parent)let child = new Child();console.log(Child.b()); Promise基本语法在 es6 中新出现的。generator async await 都是基于 promise 的。 比如：kao axios redux-saga fetch …。 promise 是一种异步流程的控制手段 promise 链式调用解决回调地狱。 promise 可以支持多个并发的请求，获取并发请求中的数据。避免返回快慢错乱问题。 promise 可以解决异步问题，但本身并不能称为 异步。 promise 可以实现不再传递回调函数了。 promise 函数new一个实例可以then多次，及调用多次。 promise （承诺）的关键字 及 三个状态一个执行器 resolve 成功 reject 失败 pending 等待 （只有它可以转为其它状态） excutor 执行器（隐） then 然后 （带两个参数，成功和失败两个函数） throw new Error() （promise 中发生错误 就会执行失败态） 123456789101112131415let p = new Promise((resolve,reject)=&gt;&#123; // 默认 promise 中的 excutor 执行器是同步执行的 console.log(1); throw new Error(); // 如果代码报错，走失败 setTimeout(() =&gt; &#123; // 原来实现这一点需用回调函数 resolve('买'); &#125;,1000);&#125;);console.log(2); // 1,2// then方法是异步调用的，事件环p.then((value)=&gt;&#123; // value成功的原因 console.log('value',value)&#125;,(err)=&gt;&#123; // err 失败的原因 console.log('err',err)&#125;) 回调地狱（参考 node.js 回调地狱篇） 现象：12345678let fs = require('fs'); // 导入文件模块fs.readFile('1.txt','utf8',function(err,data)&#123; if (err) return console.log(err); fs.readFile(data,'utf8',function(err,data)&#123; if (err) return console.log(err); console.log(data); &#125;)&#125;) 改进：12345678910111213141516171819202122232425262728293031// 链式调用let fs = require('fs');function read(url) &#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(url,'utf8',function (err,data) &#123; if (err) reject (err); resolve(data); &#125;) &#125;)&#125;// 如果返回的是一个 promise 的结果，会将结果作为下一个 then 的参数传入read('cat.txt').then((data)=&gt;&#123; return read(data); //如果成功，传给下一个 then 的 data&#125;).then(data=&gt;&#123; console.log('data');&#125;,err=&gt;&#123; console.log('err');//如果不出存在或失败走到这里&#125;); // promise 实现链式调用返回的并不是this,而是一个新的promise,及失败了可以继续向下运行read('1.txt').then(data=&gt;&#123; return 100;&#125;).then(data=&gt;&#123; throw new Error(); // 标明执行错误，下一步走错误逻辑&#125;).then(data=&gt;&#123; console.log(data);&#125;,(err)=&gt;&#123; console.log(err); // error&#125;).then(data=&gt;&#123; console.log(data,'1213') // undefined '1213' &#125;) 捕获异常：（.catch）12345678910// catch 如果有任何一个出错，会走到 catch 里去read('1.txt').then(data=&gt;&#123; &#125;).then(data=&gt;&#123; throw new Error();&#125;).catch(err=&gt;&#123; console.log(err); // 获取失败，走到下一个成功里去&#125;).then(data=&gt;&#123; console.log('catch');&#125;) 多次调用：12345678910111213let p = new Promise((resolve,reject)=&gt;&#123; resolve('成功');&#125;);// 一个promise的实例可以then多次p.then(data=&gt;&#123; console.log(data); // 成功 &#125;);p.then(data=&gt;&#123; console.log(data); // 成功 &#125;);p.then(data=&gt;&#123; console.log(data); // 成功 &#125;) 并发请求：（.all）12345678910111213141516let fs = require('fs'); function read(url) &#123; return new Promise((resolve,reject) =&gt; &#123; fs.readFile(url,'utf8',function(err,data)&#123; if (err) reject(err); resolve(data); &#125;) &#125;)&#125;// promise.all方法调用后会返回一个新的promise// 并发请求Promise.all([read('1.txt'),read('2.txt')]).then(([r1,r2])=&gt;&#123; console.log(r1,r2);&#125;,err=&gt;&#123; console.log(err); // 有一个失败结果就为失败 &#125;); 赛跑：（.race）123456// 处理多请求，只取最快的Promise.race([read('1.txt'),read('2.txt')].then((data)=&gt;&#123; console.log(data); // 取1或2&#125;,err=&gt;&#123; conosle.log(err);&#125;)); 其他：(.resolve，.reject)12345678// 返回一个成功的promisePromise.resolve('123').then(data=&gt;&#123; console.log(data);&#125;)// 返回一个失败的promisePromise.reject('123').then(null,data=&gt;&#123; console.log(data);&#125;) 源码实现：123456789101112131415161718192021222324252627282930313233class Promise&#123; constructor(executor)&#123; this.status = 'padding'; this.value = undefined; this.value = undefined; let resolve = value =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; this.value = value; &#125; &#125;; let reject = reason =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'rejected'; this.reason = reason; &#125; &#125;; try&#123; executor(resolve,reject); &#125;catch(e)&#123; reject(e); &#125; &#125; then(onFuFilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFuFilled(this.value); &#125; if(this.status === 'rejected')&#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise; 解决异步的方案 高阶函数 函数是一等公民，函数可以当作参数，函数可以当作函数，函数可以返回函数（偏函数，函数柯里化）callback Promise generator + co库 async + await 高阶函数 函数返回函数 123456// 类型判断function isType (type,content) &#123; let t = Object.prototype.toString.call(content).replace(/\[object]\s|]/g,''); return t === type;&#125;console.log(isType('String','adc')); 123456789// 需要批量生产的一些方法 isString('abc') isNumber(123);function isType (type) &#123; // 闭包 不会释放 的变量 return function (content) &#123; // 用完后即清除的变量 let t = Object.prototype.toString.call(content).replace(/\[object]\s|]/g,''); return t === type; &#125;&#125;let isString = isType('String');isString('abc'); 12345678910111213// 扩展function isType (type) &#123; return function (content) &#123; let t = Object.prototype.toString.call(content).replace(/\[object]\s|]/g,''); return t === type; &#125;&#125;let arr = ['String','Number','Array','Object','null'];let util = &#123;&#125;; // 对象，一般有这个工具类arr.forEach(item =&gt; &#123; util['is' + item] = isType(item)&#125;);console.log(util.isString('123')); 高阶函数 函数当作参数传递 典型的 callback。例如： loadash after 1234567891011121314// 当达到某个条件的时候，执行 callbackfunction after (times,callback) &#123; return function () &#123; if (--times === 0) &#123; callback(); &#125; &#125;&#125;let eat = after(3,function()&#123; console.log('吃完了');&#125;);eat();eat();eat(); // 到第三次才执行 应用 12345678910111213141516171819let fs = require('fs');function after (times,callback) &#123; let arr = []; return function (d) &#123; arr.push(d); if(arr.length === times) callback(arr); &#125;&#125;;let out = after(2,function(data)&#123; console.log(data);&#125;);fs.readFile('./2.promise.js/a.txt','utf8',function (err,data) &#123; console.log(data); out(data);&#125;);fs.readFile('./2.promise.js/b.txt','utf8',function (err,data) &#123; console.log(data); out(data);&#125;);]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>ES6</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>ES6.js</tag>
        <tag>前端端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js——Readme]]></title>
    <url>%2F2019%2F03%2F27%2FJS_Node%2F</url>
    <content type="text"><![CDATA[README后端语言 后端当然有：Java PHP Python Ruby .Net … Node.js。 啊，作为前端进入后台的切入口，当然是Node.js了。 Node.js是一个 JavaScript 运行时的环境，可以解析执行 js 代码，摆脱了浏览器来运行。 js与node.js的区别：​ - js : EcmaScript语法（if/ for/ var…）、 BOM、 DOM。​ - Node.js : 没有 BOM DOM ，有 EcmaScript 及其一些服务器级别的操作 API，比如：文件读写、网络服务的构建、网络通信、http服务器…等处理。 构建于 Chrome 的 V8 引擎之上（公认的最快的 JS 解析引擎）。 特性：event-driven 事件驱动。​ - non-blocking I/O model 非阻塞IO模型（异步）。​ - lightweight and efficient 轻量高效 等。 相关：基于node开发的npm是放着js相关的绝大多数的包。node.js官方网站 能做什么 Web 服务器后台 命令行工具 npm (node) git (c语言) hexo (node,嘻嘻就是本博客啦(～￣(OO)￣)ブ） 对于前端来说，接触node最多的是它的命令行工具 webpack gulp npm 简单命令行操作 cd 切换目录 dir 列出目录 ls 列出目录 mkdir rm cls //clear 清屏 资源推荐 《深入浅出Node.js》 朴灵，偏理论 《Node.js权威指南》 API讲解 《编写可维护的 JavaScript》 《JavaScript 语言精粹》 《JavaScript 高级编程》 JavaScript 标准参考教程(alph)（阮一峰o(╥﹏╥)o大佬） Node入门 官方API文档 CNODE社区 CNODE-新手入门 中文文档（较老） 在线查看各个文件格式 比较被人熟知的代码规范 重点关注 B/S编程模型 Browser - Server / back-end 模块化编程 RequireJS SeaJs12@import(&apos;文件路径&apos;)//即，node中可以像@import（）一样来引用加载 JS脚本文件 Node常用API 异步编程 回调函数 Promise async generator Express Web 开发框架 Ecmascript 6 … 安装 Node 环境 这里不再赘述，网上一大堆教程（傻瓜式下载安装） 需要注意的是在官网上 LTS 稳定版 Current 最新版 对于已经装过的 输入 node –version 可以更新 node -v ( node –version ) 查看安装是否成功 起步读写 写一个js脚本文件 注意：文件名不要使用 node.js 命名，最好也不要使用中文 如果想要解析某个文件在该文件目录终端输入： 1node xxx.js 没有BOM DOM，有 EcmaScript 及具有文件读取能力等服务器级别的 API。 其中 fs 就是 file-system 的简写，Node想要进行文件操作，必须引入 fs 的这个核心模块。 fs 中提供了与所有文件操作相关的API，例如： fs.readFile 用来读取文件 第一个参数：读取文件路径 第二个参数：回调函数 error错误对象data为null，成功data显示数据error为null 使用 require 方法加载 fs 核心模块12345678var fs = require('fs')fs.readFile('./data/xxx.txt',function(error,data)&#123; if(error)&#123; console.log('读取文件失败') &#125; else &#123; console.log(data.toString()) &#125;&#125;) fs.writeFile 用来写文件 第一个参数：文件路径 第二个参数：文件内容 第三个参数：回调函数 文件写入 error 为null ,未写入打印123456789var fs = require('fs')fs.writeFile('./data/xxx.txt','大家一起加油呀！',function(error)&#123;// console.log('文件写入成功')if (error)&#123; console.log('写入失败')&#125; else &#123; console.log('写入成功')&#125;&#125;) 简单的http服务 使用 node 构建一个 Web 服务器 在 node 中提供了一个核心模块 : http 它可以帮你创建编写服务器 加载 http 核心模块 1var http = require('http') 使用 http.createServer() 方法创建一个Web 服务器，返回一个server 实例 1var server = http.createServer() 提供服务：数据的服务，发/接收请求，反馈（发送响应） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//req: request 请求对象 用来获取客户端的一些请求信息，例如：请求路径//res: response 响应对象 用来给客户端发送响应信息server.on('request',function (req,res) &#123; console.log('受到客户端的请求了，请求路径是：' + req.url) //response 对象有一个方法：write 可以用来给客户端发送响应数据 //write 可以使用多次，但是最后一定要使用 end 来结束响应 否则会一直等待 response.write('hello') response.write('node.js') //告诉客户端，在此处结束了 response.end()&#125;)//注册 request 请求事件，当有请求过来，就会出发服务器的 request 请求事件，执行回调函数//简写合并server.on('request',function (req,res) &#123; //直接 end 的同时发送响应 res.end('hello world')&#125;)//根据不同的请求路径发送不同的响应结果server.on('request',function (req,res) &#123; var url = req.url if (url === '/') &#123; res.end('index page') &#125; else if (url === '/login')&#123; res.end('login page') &#125; else &#123; res.end('404 Not Found...') &#125;&#125;)// end 返回数组server.on('request',function (req,res) &#123; var products = [ &#123; name:'苹果', price:8888 &#125;, &#123; name:'香蕉', price:848 &#125;, &#123; name:'茄子', price:458 &#125; ] //响应内容只能是二进制数据 或者字符串 //数字 对象 数组 布尔值 都不行，因此使用 JSON.stringify 将其转换为 字符串 res.end(Json.stringify(products))&#125;)server.on('request',function (req,res) &#123; //在 服务端 默认发送的数据是 utf8 编码的内容 //浏览器 在不知道的情况下会按照当前操作系统的默认编码去解析 //比如中文的操作系统默认是 gbk //解决：用 res.setHeader Content-Type 内容类型即，告诉浏览器发送的内容用什么编码 res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('hello 你好 world 世界') // text/plain 普通文本 text/html html文件 &#125;) 绑定端口号，启动服务器 12345server.listen(3000,function () &#123; console.log('服务器启动成功，通过 http://127.0.0.1:3000/ 来进行访问')&#125;) //端口号的范围 0~65536//默认端口号最好不要使用，例如 http 服务的 80 如何关闭cmd : Ctrl + C http - fs1234567891011121314151617181920212223242526272829303132333435var http = require('http')var fs = require('fs')var server = http.createServer()server.on('request',function (req,res) &#123; var url = req.url if (url === '/') &#123; fs.readFile('./resourse/index.html',function (err,data) &#123; if (err) &#123; res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('文件读取失败，请稍候再试！') &#125; else &#123; //data 默认是二进制数据 res.setHeader('Content-Type','text/html;charset=utf-8') //在这里不用转 res.end(data) &#125; &#125;) &#125; else if (url === '/image') &#123; fs.readFile('./resourse/image.jpg',function (err,data) &#123; if (err) &#123; res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('文件读取失败，请稍候再试！') &#125; else&#123; //图片不需要指定编码格式 res.setHeader('Content-Type','image/jpeg') res.end(data) &#125; &#125;) &#125;&#125;)server.listen(3000,function () &#123; console.log('服务器启动成功,通过 http://127.0.0.1:3000/ 来进行访问')&#125;) 在线查看各个文件格式 Node 中的 jsEcmaScript 没有 BOM DOM 核心模块Node 为 JavaScript 提供了很多服务器级别的 API ，这些API都被包装到了一个具名的模块中了。例如：文件操作 fs 核心模块，http服务构建的 http 模块，path 路径操作模块，os 操作系统信息模块等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//例子://url 模块用来处理 urlvar url = require('url') //把url每一部分按分割解析出来 var obj = url.parse('/index?name=adfjdfla&amp;message=djskafh',true) console.log(obj) console.log(query)//os 用来获取机器信息var os = require('os') //获取当前机器 CPU 信息 console.log(os.cpus()) //获取 memory 内存 console.log(os.totalmem()) //path 用来操作路径var path = require('path') //获取扩展名 console.log(path.extname('c:/a/d/c/d/hello.txt'))//fs 用来操作文件var fs = require('fs') //得到目录列表中的文件名和目录名 (涉及到手动粗暴制作阿帕奇功能) //同时涉及到ES6 模板字符串`` 及 $&#123;item&#125; 替换server.on('request',function(req,res)&#123; var url = req.url fs.readFile('./template.html',function(err,data)&#123; if(err)&#123; return res.end('404 Not Found') &#125; fs.readdir('D://node/js',function(err,files)&#123; if (err) &#123; return res.end('404 not Found') &#125; var content = '' files.forEach(function(item)&#123; content += `&lt;li&gt;$&#123;item&#125;&lt;/li&gt;` &#125;) data = data.toString() data = data.replace('☺',content) res.end(data) &#125;) &#125;)&#125;) 用户自定义模块 require 是一个方法，作用：（1）用来加载模块（2）获取加载文件模块导出的接口 对象 加载顺序即：遇到 require 便中断执行加载模块 require 加载自定义模块的，其中相对路径 ./ 不能省略，否则会当成核心模块 报错 node 中没有全局作用域，只有模块作用域，因此无法在 加载模块 中调用 上级或下级模块中的 变量 或 方法 exports是一个 对象 解决模块之间的通信 123456//a.js require 里加载另一个文件路径 var bExports = require('./b')console.log(bExports.xyz) // 2. ...console.log(bExports.foo)var fs = require('fs') //核心模块本质上也是使用 fs 模块里的 exports 对象里导出的成员 12345678//在每个文件模块中都提供了一个对象：exports//exports 默认是一个空对象//你要做的就是把所有需要被外部访问的成员挂载到这个 exports 对象中var xyz = '1.我是导出的自定义的变量'exports.xyz = '2.我才是导出的自定义的变量'exports.foo = 'hello' 第三方模块在node中使用模板引擎（art-template） 1234567891011121314151617181920//在浏览器中需要引用 script三连 除了 &#123;&#123;&#125;&#125; 其他都被原模原样输出&lt;script scr=&quot;node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/template&quot; id=&quot;tpl&quot;&gt; &lt;p&gt;我是&#123;&#123;1&#125;&#125;&lt;/p&gt; &lt;p&gt;我是&#123;&#123;2&#125;&#125;&lt;/p&gt; &lt;p&gt;我是&#123;&#123;3&#125;&#125;&lt;/p&gt; &lt;p&gt;我喜欢循环&#123;&#123;each 4&#125;&#125; &#123;&#123;$value&#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/p&gt;&lt;/script&gt;&lt;script&gt; var ret = template(&apos;tpl&apos;,&#123; 1:&apos;a&apos;, 2:&apos;b&apos;, 3:&apos;c&apos; 4:[ &apos;循环value&apos;, &apos;循环value&apos;, &apos;循环value&apos; ] &#125;)&lt;/script&gt; 123456789101112npm install art-template // node 安装//--------------------------------铁血直男分割----var template = require('art-template)var tpl = template.render('模板字符串&#123;&#123;对象&#125;&#125;',&#123; 对象:'替换成我' &#125;)console.log('tpl')//--------------------------------铁血直男分割----var tpl = template.render(data.toString(),&#123; 对象:'替换成我' &#125;) 服务端渲染和客户端渲染的区别： 客户端渲染不利于 SEO 搜索引擎优化，至少两次请求，发起 ajax 在客户端渲染 服务端渲染是可以被爬虫抓取到的，客户端异步渲染难以被抓取到 好的网站是两者结合的，查看源代码可见到的内容就是服务端渲染的 服务端渲染 ：商品列表 客户端渲染：评论列表 静态资源 浏览器在收到 HTML 响应的内容之后，从上至下解析，其中若发现 link、script、img、iframe、video、audio等带有 src 或者 href (link) 属性标签（具有外链作用）的时候，浏览器会自动对这些资源发起请求 为了方便统一处理静态资源，我们把约定的所有的静态资源（css、img、js、lib(第三方包)）都存放在 public 目录里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var http = require('http')var fs = require('fs')var template = require('art-template')var url = require('url')//假信息var comments = [ &#123; name:'张三', message:'说点啥', dateTime:'2020/10/10' &#125;, &#123; name:'李四', message:'说点啥', dateTime:'2020/10/10' &#125;, &#123; name:'王五', message:'说点啥', dateTime:'2020/10/10' &#125;]http .createServer(function (req,res) &#123; var url = req.url var parseObj = url.parse(req.url,true) var pathname = parseObj.pathname if (pathname === '/') &#123; //请求主页 fs.readFile('./views/index.html',function (err,data) &#123; if (err) &#123; return res.end('404 Not Found') &#125; //用模板引擎渲染 var htmlStr = template.render(data.toString(),&#123; comments: comments &#125;) res.end(htmlStr) &#125;) &#125; else if (pathname === '/post')&#123; //a链接请求 fs.readFile('./view/post.html',function(err,data)&#123; if (err) &#123; res.end('404 Not Found') &#125; res.end(data) &#125;) &#125; else if (pathname.indexOf('/public/') === 0)&#123; //请求静态资源 //统一处理：如果请求路径是以/public/开头的，则我认为你要获取 public //中的某个资源，可以将其请求路径当做文件路径来直接获取 fs.readFile('.' + pathname,function(err,data)&#123; if (err) &#123; return res.end('404 Not Found') &#125; res.end(data) &#125;) &#125; else if (pathname === '/pinglun') &#123; //提交评论 var comment = parseObj.query//获取数据 comment.dateTime = '2017-11-12 17:11:22' comments.push(comment) //放入到数组中 //如何通过服务器让客户端重定向？ // 1.状态码设置为 302 临时重定向 statusCode // 2.在响应头中通过 Location 告诉客户端往哪里重定向 setHeader res.statusCode = 302 res.setHeader('Location','/') res.end() //如果客户端发现收到服务器的响应的状态码是 302 就会自动去响应头中找 Location 这样它就会自动跳转了 &#125; &#125;) .listen(3000,function()&#123; &#125;)//注意: 1. 服务端的文件路径就不要写相对路径了，都直接写成：/public/xxx// 2. cmd node enter 可以像浏览器控制台一样走读测试API// 3. 301 永久重定向 浏览器会记住是否进行了重定向 比如：每次都从 .com 跳转到 .com.cn的网站// 4. 302 临时重定向 浏览器不记忆 每次都会尝试访问不通的路径 1234567891011121314151617181920212223242526272829&lt;!--index展示列表--&gt;&lt;ul&gt; &#123;&#123;each comments&#125;&#125; &lt;li&gt;&#123;&#123;$value.name&#125;&#125;说：&#123;&#123;$value.message&#125;&#125; &lt;span&gt;&#123;&#123;$value.dateTime&#125;&#125;&lt;/span&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt;&lt;!--简单的H5表单验证--&gt;&lt;!--以前的表单是如何提交的？表单中需要提交的表单控件元素必须具有 name 属性。表单提交分为： 1.默认提交行为 2.表单异步提交action 表单提交的地址，就是请求的 url 地址method 请求方法 get post--&gt;&lt;form action="/pinglun" method="get"&gt; &lt;div&gt; &lt;label for="input_name"&gt;name&lt;/label&gt; &lt;input type = "text" required minlength="2" maxlength="10" id="input_name" name="name" placeholder="Email"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="textarea_message"&gt;message&lt;/label&gt; &lt;textarea cols="30" rows="10" required minlength="5" maxlength="20" id="textarea_message" name="message"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/form&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041// 补充:// ES5 .forEach IE8不支持 遍历 数组 的方法// 伪数组是对象 对象原型链中没有 forEach;['abc','d','efg'],function(item,index)&#123; console.log(item)&#125;// jQ实例对象，伪数组 转 数组;[].slice.call($('div'))// 补充模拟 .slice 原型Array.prototype.mySlice = function () &#123; var start = 0 var end = this.length if (arguments.length === 1)&#123; start = arguments[0] &#125; else if (arguments.length === 2)&#123; start = arguments[0] end = arguments[1] &#125; var tmp = [] for (var i = start; i &lt; end; i++)&#123; tmp.push(this[i]) &#125; return tmp&#125;var fakeArr = &#123; // 伪数组 0:'abc', 1:'efg', 2:'haha', length:3&#125;[].mySlice.call(fakeArr) // 由此得到 数组// 遍历 jQ 元素 .each 在jQ的原型链中 可以遍历jQ实例对象(元素/伪数组),也可以兼容问题$.each(['abs','b','egf'],function(index,item)&#123; console.log(item)&#125;)// art-template 模板引擎&#123;&#123;each 数组&#125;&#125;&lt;li&gt;&#123;&#123;$value&#125;&#125;&lt;/li&gt;&#123;&#123;/each&#125;&#125; 什么是模块化 具有文件作用域 通信规则有 加载、导出 CommonJs 模块规范在 Node 中的 JavaScript 的一个重要概念：模块系统 模块作用域 避免了命名污染 使用 require 方法来加载模块 优先从 缓存加载（提高加载模块效率） 判断模块标识 12345678// 语法:var 自定义变量名 = require('模块标识/文件路径')// 作用：1.执行被加载模块中的代码// 2.得到被加载模块中的 exports 导出接口对象// 模块标识：1.非路径 模块标识 （核心模块，第三方模块）// 2.路径形式模块 ./(当前目录) ../(父级目录) /xxx (磁盘根路径)//第三方加载：1.node_modules/art-template/package.json 中的 main 属性记录了 art-template 的入口模块，然后加载使用这个第三方包// 2.找不到会逐级向上查找 index 加载项，直到根目录，因此兄弟文件中无法以第三方包加载的方式加载 node_modules 中的文件 使用 exports 接口对象用来导出模块中的成员 由于模块作用域，默认文件中的所有成员只在当前文件模块中有效 导出需要公开的成员，导出多个成员必须在对象中 123456789// 语法：exports.a = 123exports.b = 'hello'exports.c = function () &#123; console.log('ccc')&#125;exports.d = &#123; foo:'ddd'&#125; 使用 module.exports 可以 只导出某一个成员 12345678910111213141516171819// 语法：module.exports = 'hello'module.exports = function () &#123; return x + y&#125;// 此时 require 文件中导出的直接为该值var fun = require('./xfs')console.log(fun)// 注意：一个文件中同时出现两个 后面的 会覆盖 前面的，即 重新赋值// 导出多个成员的方式module.exports = &#123; str:'hello', fun:function () &#123; return x + y &#125;&#125; module 和 exports 原理 在 Node 中，每个模块内部都有一个自己的 module 对象，该 module 对象中的一个成员叫：exports ，其也是一个对象。 每个文件都默认在代码的最后一句：return module.exports，另一个文件通过 require 得到。 12345678910111213141516var module = &#123; exports:&#123; foo:'bar' &#125;&#125;// 等同于 module.exports.foo = 'bar'// 等同于var exports = module.exportsexports.foo = 'bar'// 省略声明，简化为exports.foo = 'bar'// 注意：exports = 'bar' //无法执行 因为 exports 被重新赋值 而最后返回的是 module.exports// 重新建立引用关系的正确方法exports = module.exports package.json 包描述文件 12345npm install art-template --save # --save 写进包依赖文件npm init # 初始化 具有引导作用npm install # 根据 package.json 里 dependencies 定义好的安装依赖 npm 包管理工具 在其官网上发布 npm 命令行工具，伴随着 node 安装 1234567891011121314151617npm --version # 查看版本npm install --global nppm # 升级版本 --global 安装到全局npm init -y # 跳过向导 快速生成npm install # 简写 npm inpm install --save # 简写 npm i -Snpm uninstall 包名 # 只删除 有依赖项依然会保存 简写 npm unnpm uninstall --save 包名 # 同时删除依赖项 简写 npm un -Snpm help # 使用帮助npm uninstall --help # 查看具体命令简写 解决被墙问题 （淘宝镜像 cnpm） 123456789101112npm install --global cnpm # 安装淘宝镜像 之后都将 npm 改为 cnpm# 如果不想通过淘宝服务器来下载npm install jquery --registry=http://registry.npm.tobao.org# 手动配置选项 避免每次都要输入链接npm config set registry https://registry.npm.taobao.org# 查看 npm 配置信息npm config list# 补充：mkdir cnpm-demo # 创建文件 cnpm-demormdir cnpm-debo # 删除文件 Express原生的 http 不足以应对开发需求，需要使用框架加快开发效率。 起步npm install express --save 安装 hello word1234567891011121314151617181920212223242526272829// 1.引包var express = require('express')// 2.创建服务器应用程序 等价于 http.createServervar app = express()// 3.公开指定目录 用户可以直接通过 /public/xx的方式访问 public 目录中的资源了app.use('/public/',express.static('./public/'))// 4.当服务器收到 get 请求 / 的时候，执行回调处理函数app.get('/',function (req,res) &#123; res.send('hello express!')&#125;)app.get('/about',function (req,res) &#123; res.send('你好 express!') // 不用声明 请求头&#125;)// 5.相当于 server.listenapp.listen(3000,function()&#123; console.log('app is running at port 3000.')&#125;)// 补充：// 1. 在文件操作的相对路径中// ./data/a.txt 等价于 data/a.txt 相对于当前目录// /data/a.txt 绝对路径 当期文件模块所处磁盘根目录// 2. 模块加载路径中用的是 相对路径 但是不能省略 ./ require('./data/foo.js') 修改完代码自动重启使用第三方命令行工具：nodemon 12345#安装npm install --global nodemon #使用 nodemon app.js 代替 node app.jsnodemon app.js express 基本路由路由器：请求方法、请求路径、请求处理函数 get：当你用 GET 方法请求 / 时，指定对应的处理函数 123app.get('/',function()&#123; res.send('Hello World!')&#125;) post：当你用 POST 方法请求 / 时，指定对应的处理函数 123app.post('/',function()&#123; res.send('Hello World! With Post')&#125;) 路由也可以看成是一张表，里面有具体的映射关系。 1234app .get('/',函数名) .get('/login',函数名) .post('/about',函数名) express 之 static-server 的静态资源服务1234567891011// 当以 /public/ 开头的时候，去 ./public/目录访问资源app.use('/public/',express.static('./public/')) // 推荐方式 易辨识// 以 /a/ 开头 相当于 publicapp.use('/a/',express.static('./public/'))// 也可以省略，省略时 不加 public 相当于 为空嘛app.use(express.static('./public'))// __dirname 指的是当前文件夹app.use('static',express.static(path.join(__dirname,'public'))) express 之 使用 art-template安装： 12npm install --save art-templatenpm install --save express-art-template 配置： 123456789101112131415161718192021222324// 第一个参数：表示当用 .art 文件渲染时，使用 art-template 模板引擎// express-art-template 就是指 express 里的 art-template app.engine('art',require('express-art-template'))// Express 为 Response 提供了一个 render 方法，仅在配置模板引擎时使用// 第一个参数不能写路径 express 默认所有的视图文件会去 views 目录查找，因此 view可省app.set('views',render函数默认路径) //修改默认文件夹// res.render('html模板名',&#123;模板数据&#125;)app.get('/',function(req,res)&#123; res.render('404.art') //第二个参数可选&#125;)//或者将两个都改回 .htmlapp.engine('html',require('express-art-template'))app.get('/',function(req,res)&#123; res.render('404.html') //第二个参数可选&#125;)// 第二个参数是模板数据app.get（'/admin',function(req,res)&#123; res.render('admin/index.html',&#123; title:'管理系统' &#125;)&#125;) 使用时的 html 不变： 1&lt;h1&gt;admin &#123;&#123;title&#125;&#125;&lt;/h1&gt; 用 express 修改案例案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 引包var express = require('express')// 创建服务器应用程序 等价于 http.createServervar app = express()// 假数据var comments = [&#123;&#125;,&#123;&#125;,&#123;&#125;]// 公开指定目录 用户可以直接通过 /public/xx的方式访问 public 目录中的资源了app.use('/public/',express.static('./public/'))// 配置模板引擎app.engine('html',require('express-art-template'))// 当服务器收到 get 请求 / 的时候，执行回调处理函数app.get('/',function (req,res) &#123; res.render('index.html'),&#123; comments:comments &#125;&#125;)app.get('/post',function (req,res) &#123; res.render('post.html') // 不用声明 请求头&#125;)app.get('/pinglun',function (req,res) &#123; // Express 内置了一个 API 可以直接通过 req.query 来获取 var comment = req.query // 直接获取 name message comment.dateTime = '20017-22-5' // unshift() 方法可向数组的开头添加一个或更多元素,并返回新的长度 comments.unshift(comment) res.redirect('/') // 重定向&#125;)// 相当于 server.listenapp.listen(3000,function()&#123; console.log('app is running at port 3000.')&#125;)// 补充：// 1. 在文件操作的相对路径中// ./data/a.txt 等价于 data/a.txt 相对于当前目录// /data/a.txt 绝对路径 当期文件模块所处磁盘根目录// 2. 模块加载路径中用的是 相对路径 但是不能省略 ./// require('./data/foo.js') Express 获取表单 POST 请求体数据Post 无法使用 req.query 获取参数，需使用第三方插件 （Express 中间件）。 1npm install --save body-parser 配置： 123456789101112131415161718192021// 获取var express = require('express')var bodyParser = require('body-parser')var app = express()// 配置 body-parser 中间件// 只要加入这个配置，则在 req 请求对象上会多出来一个属性：bodyapp.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())// 使用app.post(function(req,res)&#123; var comment = req.body comment.dateTime = '2020/02/02' comments.unshift(comment) res.redirect('/')&#125;)// 补充：在输入框输入 url 获取页面的请求都是 get 请求// Express 会自动结束请求 end() Express 之 crud 增删改查起步1234567891011121314151617181920212223242526272829303132var express = require('express')var app = express()app.use('/node_modules',express.static('./node_modules/'))app.use('public',express.static('./public/'))app.engine('html',require('express-art-template'))app.get('/',function(req,res)&#123; // readFile 的第二个参数是可选的，传入 utf8 指按其编码 fs.readFile('./db.json','utf8',function(err,data)&#123; // 此时 data 转为了 字符串 if(err)&#123; return res.status(500).send('Server error.') &#125; // 从文件中读取到的一定为字符串，需手动转成对象 var students = JSON.parse(data).students res.render('index.html',&#123; fruits:[ '苹果'，'香蕉'，'橘子' ], students: students // 将 data 转为 对象 . 出 students &#125;) &#125;)&#125;)app.listen(3000,function()&#123; console.log('running...')&#125;) 路由设计 请求方法 请求路径 get 参数 post 参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生 POST /students name/age/gender/hobbies 处理添加学生 GET /students/edit id 渲染编辑页面 POST /students/back id/age/genter/hobbies 处理 GET /students/delate id 处理删除请求 路由模块提取 模块职责要单一，增强可维护性，提高开发效率 新建文件 router.js 使用 Express 提供了 router 方法 1234567891011121314151617181920212223242526272829303132/** app.js 入口模块 职责：启动服务，做一些服务相关配置 模板引擎 body-parser 解析表单 post 请求体 提供静态资源服务 监听端口启动服务 挂载路由*/var express = require('express')var router = require('./router')var app = express()app.use('/node_modules/',express.static('./node_module/'))app.use('/public/',express.static('./public/'))app.engine('html',require('express-art-template'))// 配置模板引擎和 body-parse 一定要在 app.use(router) 挂载路由之前// 这是中间件的执行流程// parse application/x-www-form-urllencodedapp.use(bodyParser.urlencoded(&#123; extended:false &#125;))//parse application/jsonapp.use(bodyParser.json())// 把路由容器挂载到 app 服务中app.use(router)app.listen(3000,function()&#123; console.log('running 3000...')&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** router.js 入口模块 职责：处理路由 根据不同的请求方法将请求路径设置具体的请求函数*/var fs = require('fs')var express = require('express')var students = require('./student') // 下面数据操作模块// 1. 创建一个路由容器var router = express.Router()// 2.把路由都挂载到 router 路由容器中//首页router.get('/students',function (res,req) &#123; Student.find(function (err,students) &#123; if (err) &#123; return res.status(500).send('Server error') &#125; res.render('index.html',&#123; fruits:[ '苹果', '香蕉', '橘子' ], students:students // 调用封装的 find 调回数据 &#125;) &#125;)&#125;)// 渲染添加数据页router.get('/students/new',function (res,req) &#123; res.render('new.html') &#125;)// 处理添加学生页面router.post('/students/new',function (res,req) &#123; // 1.获取表单数据 ： // 先读取为字符串，转对象，往对象中 push 数据，转字符串再次写入 // 2.处理：将数据保存到 db.json 文件中用以持久化 // 3.发送响应 Student.save(req.body,function (err) &#123; if (err) &#123; return res.studus(500).send('Server error.') &#125; res.redirect('/students') &#125;)&#125;)// 渲染编辑页面// &lt;a herf="/students/edit?id=&#123;&#123;$value.id&#125;&#125;"&gt;编辑&lt;/a&gt;router.get('/students/edit',function (req,res) &#123; res.render('edit.html',&#123; var byId = parseInt(req.query.id) Student.findById(byId,function (err,student) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.render('edit.html',&#123; student:student &#125;) &#125;) &#125;)&#125;)// 处理编辑数据// &lt;input type="hidden" name="id" id="&#123;&#123; student.id &#125;&#125;"&gt; 用来放一些不希望被用户看见，但是需要被提交到服务端的数据router.post('/students/edit',function (req,res) &#123; // 1.获取表单数据 req.body // 2.更新 Student.updateById() // 3.发送响应 Student.updateById(req.body,function (err) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.redirect('/') &#125;)&#125;)// 删除数据 router.get('students/delate',function (req,res) &#123; // 1.获取要清除的 id // 2.根据 id 执行 // 3.根据操作结果发送相应数据 Student.delateById(id,function (err) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.redirect('/students') &#125;)&#125;)//3. 把 router 导出module.exports = router 封装提取数据操作模块 数据操作模块 封装异步API （node 基础重点） 类比 jQ (重点) 1234567891011121314151617181920212223242526272829303132333435363738// 封装异步 API// setTimeout 是异步操作// 如果需要获取一个函数异步操作的结果，则必须通过回调函数来获取function fn (callback) &#123; //var callback = function (data) &#123; console.log(data) &#125; setTimeout(function () &#123; var data = 'hello' callback(data) &#125;,1000)&#125;fn(function (data) &#123; console.log(data)&#125;)// 回调函数：获取异步操作的结果// jQ $.get('dsdf',function(data)&#123; &#125;)$.ajax(&#123; url:'dsd', type:'get', data:&#123; foo:'bar' &#125;, // 使用者只负责传递,封装者需要去调用 success:function()&#123; &#125;&#125;)function ajax(options) &#123; options.success(data)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** student.js 数据操作模块 * 职责：操作文件中的数据，只处理数据，不关心业务*/var fs = require('fs')var dbPath = './db.json'/** * 获取所有数据列表 * callback 中的参数 * 第一个是 err ：成功是null,错误是错误对象 * 第二个是 data ：成功是数组，错误是 undefined * return []*/exports.find = function (callback) &#123; fs.readFile(dbPath,'uft8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; callback(null,JSON.parse(data).students) &#125;)&#125;// 调用：在 router.js 中 find(function (err,data) &#123;&#125;)/** * 根据 id 查找获取 * @param &#123;Number&#125; id 数据id * @param &#123;Function&#125; callback 回调函数*/exports.findById = function (id,callback) &#123; fs.readFile(dbPath,'uft8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students var ret = students.find(function (item) &#123; return item.id === parseInt(id) &#125;) return callback(null,ret) &#125;)&#125;// 调用 Student.findById(id,function (err,student) &#123;&#125;)/** * 添加保存数据*/exports.save = function (students,callback) &#123; fs.readFile(dbPath,'uft8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 处理 id 唯一的，不重复 students.id = students[students.length - 1].id + 1 students.push(student) var fileData = JSON.stringify(&#123; students:students &#125;) fs.writeFile(dbPath,fileData,function (err) &#123; //写入数据 if(err)&#123; return callback(err) &#125; callback(null) &#125;) &#125;)&#125;// 调用：save(&#123;name:'xx',age:18&#125;,function(err)&#123;if(err)&#123;&#125;else&#123;&#125;&#125;)/** * 更新数据 （编辑）*/exports.updateById = function(student,callback)&#123; fs.readFile(dbPath,'utf8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 将 id 改为数字类型 student.id = parseInt(student.id) // EcmaScript 6 中的一个数组方法：find // 即，符合条件终止遍历，同时返回遍历项 var stu = students.find(function (item) &#123; return item.id === student.id &#125;) // 遍历拷贝对象 for (var key in student) &#123; stu[key] = student[key] &#125; // 把对象数据转换为字符串 fs.write(dbPath,fileData,function(err)&#123; if (err) &#123; return callback(err) &#125; callback(null) &#125;) &#125;)&#125;// 调用 updateById(&#123;id:1,name:'xx',age:15&#125;,function(err)&#123;&#125;)/** * 删除数据*/exports.delateById = function(id,callback)&#123; fs.readFile(dbPath,'utf8',function (err,data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // findindex 方法专门用来根据条件查找元素的下标 var delateId = students.findIndex(function (item)&#123; return item.id === parseInt(id) &#125;) students.splice(delateId,1) &#125;)&#125;// 调用 delateById(id,function(err)&#123;&#125;) 案例总结 入口文件 （main.js） 处理模板、配置开放静态资源、配置模板引擎、简单路由渲染静态首页 路由设计 提取路由模块 准备处理文件数据模块 写好结构 实现具体功能 通过路由收到请求 接收请求中的数据 get （req.query） / post （req.body） 用数据操作 api 处理数据 （find）/ （findIndex） 根据操作结果发送响应 12345678- 补充 1 ： + (ctrl + alt) 快捷键 + 函数是一种数据类型，可以作为 参数 返回值。 + 一般情况下，把函数作为参数的目的就是为了获取函数内部的异步操作 + 涉及到 JavaScript 底层概念：单线程、事件循环 - 凡是需要得到一个函数内部异步操作的结果 必须通过 回调函数，比如： + setTimeout/readFile/writeFile/ajax/readdir 1234567891011121314151617181920212223242526272829303132333435363738394041// 例一：function add(x,y) &#123; console.log(1) setTimeout(function()&#123; console.log(2) var ret = x + y return ret &#125;,1000) console.log(3) // 到这里就执行结束了，不会等定时器，没有返回值，默认返回 undefined &#125; console.log(add(10,30))// 例二：function add(x,y,callback) &#123; //形参变量 及 返回值 console.log(1) setTimeOut(function () &#123; // 异步操作 var ret = x + y callback(ret) &#125;,1000)&#125;add(10,20,function (ret) &#123; // 在此处定义 实参变量 ，再把结果传回这里 // 回调函数 console.log(ret)&#125;)// 例三：基于原生 XMLHTTPRequest 封装 get 方法function get(url,callback) &#123; var oReq = new XMLHttpRequest() // 当加载成功后调用指定函数 oReq.onload = function () &#123; // 需要拿到这里的数据 callback(oReq.responseText) &#125; oReq.open("get",url,true) oReq.send()&#125;get('/url.json',function (data) &#123; console.log(oReq.responseText)&#125;) 12345678910111213- 补充2： + javascript 天生不支持模块化 + node.js 支持（require,exports）commonJS + 浏览器中需要第三方库来像在 Node 一样进行模块化编程 * require.js AMD * sea.js CMD + 无论是 CommonJS AMD CMD UMD EcmaScript6 Modules 官方规范 * 都是为了解决 JavaScript 的模块化问题- app.use + 开放静态资源、加载中间件- package-lock.json + 保存了 node_modules 中的所有信息（版本、下载地址），提升下载速度 + lock 即可以避免三方件自动升级版本 123456789// EcmaScript 6 对数组新增了很多方法// find 找元素 和 findIndex 找下标// 控制台 Array.prototype 即可找到操作数组的方法// 其中遍历的还有：// every()，每一个都符合条件 返回布尔值 true// includes()// some()，满足其中一个返回 true// map// reduce MongoDB （node.js）介绍安装关系型数据库 和 非关系型数据库 关系型数据库 表 就是关系，就是指 表与表之间存在关系 所有的关系型数据库都想需要通过sql语言来操作 所有的关系型数据库在操作之前都需要设计表结构 数据表同时支持 约束，为了保证数据的完整性 唯一的 主键 默认值 非空 非关系型数据库 （也可以加入 关系） 有些非关系数据库就是 key-value 对儿 MongoDB 是最像关系型数据库的非关系型数据库 数据库 =&gt; 数据库 数据表 =&gt; 集合（数组） 表记录 =&gt; 文档对象 它不需要设计表结构（没有结构性） mongoDB 数据库的基本概念可以看做是一个大的集合对象： 其中可以有多个数据库 一个数据库可以有多个集合（表） 一个集合可以有多个文档 （表记录） 文档结构很灵活，没有任何限制，不需要像 MySOL 一样先创建数据库、表、设计表结构，这里只需要在你插入数据的时候，指定往哪个库和集合操作就可以了 123456789101112131415161718192021&#123; qq:&#123; // 数据库 users:[ // 数据表 &#123;name:'azhong',age:15&#125;, // 表记录 &#123;&#125;, &#123;&#125;, &#123;&#125; ... ], products:[ ], ... &#125;, taobao:&#123; &#125;, baidu:&#123; &#125;&#125; 安装 下载安装 配置环境变量 查看版本 mongod --version 启动关闭数据库启动： 123# mongodb 默认使用执行 mongod 命令所处盘符根目录下的 /data/db 作为自己的数据存储目录# 所以在第一次执行该命令之前先自己动手建一个 /data/dbmongod 如果想要修改默认的数据存储目录，可以： 1mongod --dbpath=数据存储目录路径 停止： 12在开启服务的控制台，直接 Ctrl + c或者直接关闭控制台 连接和退出数据库1234# 该命令默认连接本机的 mongodb 服务mongodb# 在连接状态输入 exit 退出连接exit 基本命令 show dbs：查看显示所有数据库 db：查看当前操作的数据库 use 数据库名称：切换到指定数据库（如果没有会新建）。例如：use itcast db.students.insertOne({&quot;name&quot;:&quot;Jack&quot;})：插入数据，students 指的是集合 show collections，显示集合 db.students.find()：查询所有数据集合 在 node 中如何操作 MongoDB 数据使用 node mongodb npm 包来操作:1npm install mongodb --save 官方指导流程 使用第三方 mongoose 来操作 MongoDB 数据库第三方包：mongoose 基于 MongoDB 官方的 mongodb包再次做了封装 1npm install mongoose --save mongoose 官网 官方指南 官方 API 文档 1234567891011121314151617181920// 1. 引包const mongoose = require('mongoose');// 2. 连接 MongoDB 数据库 连接本机 test 数据库// 如果没有，在创建第一条数据库时自动创建mongoose.connect('mongodb://localhost:27017/test',&#123;useNewUrlParser: true&#125;);// 3. 之后延伸// mongoose.Promise = global.Promise// 4. 创建一个模型，设计数据库// MongoDB 是动态的，非常灵活，直接在代码设计数据库// mongoose 使其设计编写过程变得简单const Cat = mongoose.model('Cat', &#123; name: String &#125;);// 5. 实例化一个 Catconst kitty = new Cat(&#123; name: 'Zildjian' &#125;);// 6. 持久化保存 kitty 实例kitty.save().then(() =&gt; console.log('meow')); mongoose 入门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var mongoose = require('mongoose')var Schema = mongoose.Schema// 连接数据库mongoose.connect('mongodb://location/itcast',&#123; useMongoClient:true &#125;)// 设计集合结构（表结构），主要是为了 保证数据的完整性，不要有脏数据var blogSchema = new Schema(&#123; title: String, // 字段名称就是表结构的属性名称 author: String, // 指定了值的类型 body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;, username: &#123; type: string, require: true // 该字段必须有，不能为空 &#125;&#125;);// 3. 将文档结构发布为模型 // mongoose.model 方法用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数用来表示数据库名称，mongoose 会自动生成 小写复数 的集合名称 User =&gt; users// 第二个参数：架构 Schema// 返回值：模型构造函数var Blog = mongoose.model('Blog', blogSchema);// 4. 使用操作集合中的数据（增删改查）var admin = new Blog(&#123; ...// 按照表结构写数据&#125;)// 5. 存入数据admin.save(function(err,ret)&#123; if (err) &#123; console.log('保存失败') &#125; else &#123; console.log('保存成功') console.log(ret) &#125;&#125;)// 查询=============铁血直男分割线Blog.find(function (err,ret) &#123; // 查询所有 if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;)// 按条件查询 Blog.find(&#123; username: 'azhong'&#125;,function (err,ret) &#123; // 查询所有 if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret)&#125;)// 按条件查询单个 没有条件查询第一个 查不到为 nullBlog.findOne(&#123; username: 'azhong', password: '12345'&#125;,function (err,ret) &#123; // 查询所有 if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret)&#125;)// 删除=============铁血直男分割线Blog.remove(&#123; username: 'azhong', password: '12345'&#125;,function (err,ret) &#123; if (err) &#123; console.log('删除失败') &#125; else &#123; console.log(ret)&#125;)// 更新=============铁血直男分割线Blog.findByIdAndUpdate('sdafasdfadaf2erwrq',&#123; username: 'azhong', password: '12345666'&#125;,function (err,ret) &#123; if (err) &#123; console.log('删除失败') &#125; else &#123; console.log(ret)&#125;) 使用 mongoose 修改案例1234567891011121314151617181920212223242526272829303132333435363738394041var mongoose = require('mongoose')mongoose.connect('mongodb://localhost/itcast',&#123; useMongoClient:true &#125;) //链接数据库，没有会新建var Schema = mongoose.Schema// mongoose.model('Comment',new Schema(&#123;&#125;))var commentSchema = new Schema(&#123; // 设计结构 name: &#123; type: String, required: true, // 是否为必填项 &#125;, gender:&#123; type: Number, enum: [0,1], // 枚举 必须是 0/1 default: 0 // 默认值 是 0 &#125;, message: &#123; type: String, required:true &#125;, date: &#123; type:String &#125;&#125;)module.exports = mongoose.model('Comment',commentSchema)// mongodb 启动数据库 node app.js 启动服务器// &#123;$value.id&#125; =&gt; &#123;$index + 1&#125;// 处理添加学生 保存数据，其它 API名称一样所以不用改new Comment(req.body).save(function (err) &#123; if (err) &#123; return res.status(500).send('Server error.') &#125; res.redirect('/students')&#125;)// mongodb 的id 默认为 _idComment.findById(req.query.id.replace(/"/g,''),function()&#123;&#125;)// replace 字符串模式 简单，但不支持全局和忽略大小写// 正则模式 支持全局和忽略大小写 MySQL (node.js)安装（npm）入门参考 1npm install mysql 入门12345678910111213141516171819202122// 加载包var mysql = require('mysql');// 创建连接var connection = mysql.createConnection(&#123; host : 'localhost', // 本机 user : 'me', // 用户名 password : 'secret', // 密码 database : 'my_db' // 数据库&#125;); // 连接数据库connection.connect(); // 执行数据操作 增删改查都写在这里connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; //throw err 阻止执行，抛出异常（打印到控制台） console.log('The solution is: ', results[0].solution);&#125;); // 关闭连接connection.end(); Navicat 数据库可视化工具 重难点提取promise问题：callback hell（回调地狱）即，在异步请求中嵌套异步请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445var fs = require('fs')fs.readFile('./data/a.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data)&#125;)fs.readFile('./data/b.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data)&#125;)fs.readFile('./data/c.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data)&#125;)// 问题：三个异步编程，异步编程不一定谁先谁后执行// 需求：希望由自己制定顺序执行// 解决：通过回调嵌套的方式保证顺序性fs.readFile('./data/a.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data) fs.readFile('./data/b.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data) fs.readFile('./data/c.txt','utf8',function(err,data)&#123; if (err) &#123; throw err &#125; console.log(data) &#125;) &#125;)&#125;)// 新问题，嵌套过深，难以维护解决 EcmaScript 6 API promisepromise 承诺 保证 解决上述问题，是 ES6 的 API Promise 容器中存放了一个异步任务 Pending 正在发生 进入以下一种状态 Resolved 已解决 Rejected 未解决 123456789101112131415161718// 创建 Promise 容器// 1.Promise 容器一旦创建，就开始创建里面执行的代码console.log(1)new Promise(function () &#123; console.log(2) fs.readFile('./data/a.txt','utf8',function (err,data) &#123; if (err) &#123; // 失败了，承诺容器中的任务失败了 console.log(err) &#125; else &#123; // 承诺容器中的任务成功了 console.log(data) console.log(3) &#125; &#125;)&#125;)console.log(4)// 输出 1/2/4/3 语法：123456789101112131415161718// Promise 本身不是异步，但是内部往往都会封装一个异步任务var el = new Promise(function (resolve,reject) &#123; fs.readFile('./data/a.txt','utf8',function (err,data) &#123; if (err) &#123; // 这里调用 resolve 方法实际上就是 then 方法传递的第二个函数 reject(err) // 将容器的 Pending 状态改为 Rejected &#125; else &#123; // 这里调用 resolve 方法实际上就是 then 方法传递的第一个函数 resolve(data) // 将容器的 Pending 状态改为 Resolved &#125; &#125;)&#125;)el.then(function (data) &#123; // 指当 promise 实例成功了，然后触发 console.log(data)&#125;,function (err) &#123; console.log('读取文件失败'，err)&#125;) 解决 回调地狱问题1234567891011121314151617181920212223242526272829303132333435363738394041424344var el_1 = new Promise(function (resolve,reject) &#123; fs.readFile('./data/a.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)var el_2 = new Promise(function (resolve,reject) &#123; fs.readFile('./data/b.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)var el_3 = new Promise(function (resolve,reject) &#123; fs.readFile('./data/c.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)el_1 // 异步编程 链式调用 .then(function (data) &#123; console.log(data) return el_2 // return 的 promise 对象可在后面的 then 中接收到 &#125;,function (err) &#123; console.log('读取文件失败'，err) &#125;) .then(function (data) &#123; console.log(data) return el_3 &#125;) .then(function (data) &#123; console.log(data) &#125;) 封装 Promise API封装 readFile1234567891011121314151617181920212223242526var fs = require('fs')function pReadFile(filePath) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(filePath,'utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;pReadFile('./data/a.txt') .then(function (data) &#123; console.log(data) return pReadFile('./data/b.txt') &#125;) .then(function (data) &#123; console.log(data) return pReadFile('./data/c.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) jQ已封装支持1234567891011var data = &#123;&#125;$.get('http://a/s/d/1') .then(function (userData) &#123; data.user = user return $.get('http://a/s/d/2') &#125;) .then(function (jobsData) &#123; data.jobs = jobs var htmlStr = template('tpl',data) document.querySelector('#user_form').innerHTML = htmlStr &#125;) jQ中Ajax使用Promise1234567891011121314$(function () &#123; $('#btn').on('click',function()&#123; $.ajax(&#123; url: './data.json', type: 'get', dataType: 'json', /*success: function (data) &#123; console.log(data) &#125;*/ &#125;).then(function(data) &#123; console.log(data) &#125;) &#125;)&#125;) 自己封装jQ1234567891011121314function get(url) &#123; return new Promise(function (resolve,reject) &#123; var oReq = new XMLHttpRequest() // 当请求加载成功后调用指定函数 oReq.onload = function () &#123; resolve(oReq.responseText) &#125; oReq.onerror = function (err) &#123; reject(err) &#125; oReq.open("get",url,true) oReq.send() &#125;)&#125; 使用场景（分类信息展示）[废弃]12345678910111213141516&lt;form action="js中的一等公民"&gt; &lt;div&gt; &lt;label for=""&gt;职业&lt;/label&gt; &lt;select name="" id=""&gt; &lt;option value=""&gt;学生&lt;/option&gt; &lt;option value=""&gt;老师&lt;/option&gt; &lt;option value=""&gt;码农&lt;/option&gt; &lt;option value=""&gt;老板&lt;/option&gt; &lt;option value=""&gt;演员&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt;//用户表 获取用户信息//职业信息表 获取所有的职业信息&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940&#123; "users":[ &#123; "id":1, "username":"admin", "age":18, "job":2 &#125;, &#123; "id":2, "username":"root", "age":18, "job":1 &#125;, &#123; "id":3, "username":"admin", "age":18, "job":3 &#125; ], "jobs":[ &#123; "id":1, "name":"学生" &#125;, &#123; "id":2, "name":"老师" &#125;, &#123; "id":3, "name":"码农" &#125;, &#123; "id":4, "name":"老板" &#125; ]&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>后端技术</category>
        <category>Node.js</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>node.js 技术栈</tag>
        <tag>后端技术</tag>
        <tag>Express 框架</tag>
        <tag>mongoDB 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[optimization]]></title>
    <url>%2F2019%2F03%2F27%2FWeb_optimization%2F</url>
    <content type="text"><![CDATA[简介：性能优化…… Hexo之性能优化hexo是本博的框架，起初是建立在 github 上的静态页面。但是仅仅只是根据 hexo 建立好博客是远远不够的。因为在一般网络环境下加载速度会很慢，如果自己的知识积累还不如百度来的快，那建立博客的初衷就会大大减少。加载速度慢有很多原因，比如，框架本身的源码中有许多空格，github是外网，图片加载尤其缓慢，字体采用的是 google 字体等等。从这几个方面入手，解决性能优化问题，是本页的初衷。 DNS域名解析DNS域名解析是本博最基础且是最致命的问题。国内访问 本博 so fast 。木钱买域名，凄惨。 移动端删除 live2d-widget在 _config.yml 文件夹下将 live2d 中的 mobile 置为 false。 修改 hexo 样式在该 F:\blog\themes\next\source\css\_custom\custom.styl 文件下修改即可覆盖原本样式。想要复原时，删除该文件内容即可。 注意：修改 header（头部导航栏）的透明度会引发 search 选项调出的弹框被遮挡层遮挡，建议修改 header 内部标签属性实现，可 F12 参考本博。]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>hexo</category>
        <category>性能优化</category>
        <category>DNS 解析案例</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog 论坛]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%96%B0%E5%BB%BAbolg%E8%AE%BA%E5%9D%9B%2F</url>
    <content type="text"><![CDATA[简介该blog论坛基于 node.js Express 框架，mongoDB数据库，mongoose数据库框架，jQuery库等。可以进行一些简单的注册，登陆，评论，发表等功能。 结构：1234567891011121314151617181920212223242526272829303132333435blog |-- public // 公共的静态资源 |-- img |-- JS |-- CSS |-- HTML |-- views // 存储视图目录 |-- _layouts |-- home.html |-- _partials |-- footer.html |-- header.html |-- settings-nav.html |-- settings |-- admin.html |-- profile.html |-- topic |-- profile.html |-- index.html |-- login.html |-- register.html |-- controllers |-- models // 数据库数据模型 |-- comment.js |-- topic.js |-- user.js |-- routes // 路由配置 |-- session.js |-- topic.js |-- app.js // 启动入口文件 |-- README.md // 项目说明文档 |-- .gitignore git // 忽略配置项文件，忽略一些不必要的配置文件 |-- package.json // 包描述文件 |-- package-lock.json // 第三方包版本锁定文件 |-- node_modules // 第三方包 构建：12345678910npm init -y ## 初始化 package.jsongit init ## 初始化发布到 git 的必要文件npm i express mongoose ## 配置核心文件npm i art-template express-art-template ## 配置模板引擎npm install --global nodemon ## 配置第三方命令行工具npm i bootstrapnpm i jquerynpm install --save body-parser ## 配置三方包 获取表单信息npm install blueimp-md5 ## 配置密码加密三方包npm install express-session ## 配置使用 cookie session 三方包 细节：path模块123456path.basename('') // 获取一个路径的文件名（默认包含扩展名）path.dirname('') // 获取一个路径的目录部分path.extname('') // 获取一个路径的扩展名部分path.isAbsolute('') // 判断一个路径是否是绝对路径path.parse('path') // 返回一个路径对象&#123;root dir base ext name&#125;path.join('','') // 当进行路径拼接的时候，推荐使用它，会格式化避免出错 参考文档：http://nodejs.org/dist/latest-v9.x/docs/api/path.html Node 中的其他成员在每个模块中，除了require，exports等模块相关的 API 之外，还有两个特殊成员： __dirname ：可以用来动态获取当前文件模块所属目录的绝对路径。 __filename ：可以用来动态获取当前文件的绝对路径。 path.join(&#39;&#39;,&#39;&#39;) ：当进行路径拼接的时候，推荐使用它，会格式化避免出错 相对路径问题1234567var fs = require('fs')fs.readFile('./a.txt','utf8',function (err,data) &#123; if (err) &#123; throw err &#125; console.log(data)&#125;) 一般情况下：./a.txt 是相对于当前文件路径。 在 node 中是相对于执行 node 命令所处的终端路径。 因此，在文件操作中使用相对路径是不可靠的，相对路径的设计的应该是相对于执行 node 命令所处的路径。 解决：将其换为绝对路径。缺陷，写死不利于项目迁移。 使用 __dirname 和 __filename path.join(&#39;&#39;,&#39;&#39;) 转换为动态的绝对路径。 123456fs.readFile(path.join(__dirname,'./a.txt'),'utf8',function (err,data) &#123; if (err) &#123; throw err &#125; console.log(data)&#125;) 补充：模块中的相对路径（相对当前文件）不受影响，这里仅指文件操作中的相对路径标识。 art-template子模版header.html / footer.html 1234&lt;!-- header.html --&gt;&lt;header&gt;&lt;/header&gt;&lt;!-- footer.html --&gt;&lt;footer&gt;&lt;footer&gt; layout.html 12345678910&lt;!-- 头部组件 --&gt;&#123;&#123; include './header.html' &#125;&#125;&lt;!-- 内容组件 --&gt;&#123;&#123; block 'content' &#125;&#125; &lt;section&gt;我是默认内容&lt;/section&gt;&#123;&#123; /block &#125;&#125;&lt;!-- 尾部组件 --&gt;&#123;&#123; include './footer.html' &#125;&#125; 模板继承index.html 12345678&lt;!-- 继承自 layout.html --&gt;&#123;&#123; extend './layout.html' &#125;&#125; &#123;&#123; block 'content' &#125;&#125; &lt;section&gt; index页面填充内容&lt;/section&gt;&#123;&#123; /block &#125;&#125; 路由设计 路径 方法 get参数 post参数 是否需要登陆权限 备注 / GET 渲染首页 /register GET 渲染注册页面 /register POST email/nickname/password 处理注册请求 /login GET 渲染登陆页面 /login POST email/password 处理登陆请求 /logout GET 处理退出请求 补充： try ... catch try ... catch ：try中包含了由一个或者多个语句组成的try块，catch子句包含try块中抛出异常时要执行的语句。即，你想让try成功，如果其中有任何异常抛出，会在catch中执行，否则继续忽略catch语句。 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch async async：基于ES6 Promise 的异步请求的方式。大多数异步函数也可以使用Promises编写。但是，在错误处理方面，async函数更容易捕获异常错误。 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function 在注册页面表单验证时会用到以上两个语法。 cookie cookie 保存一些不太敏感的数据，且数据量较小。不能用来保存登录状态，比如vip。但是可以保存比如用户名，购物车。 session 你（客户端）、寄存行李处（服务端）、电子票（cookie）、箱子中的内容（敏感信息） 在 Express 中，默认不支持 Session 和 Cookie 但是可以使用第三方中间件：express-session来实现 express-session 的使用 加载：npm install express-session。 配置： 1234567var session = reequire('express-session')app.use(session(&#123; //配置加密字符串，会在原有的加密基础上和这个字符串一起加密 secret: 'itcast', resave: false, saveUninitialized: true // 无论是否使用 session 都会分配钥匙&#125;)) 使用：添加 Session 数据：req.session.foo = &#39;bar&#39;，获取 Session 数据：req.session.foo。 提示：默认 session 数据时内存存储的，服务器一旦存储就会丢失，在生产环境中，会将 session 进行持久化存储。 参考https://www.npmjs.com/package/express-session]]></content>
      <categories>
        <category>node.js 案例</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>js</tag>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学进站]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%A7%91%E5%AD%A6%E8%BF%9B%E7%AB%99%2F</url>
    <content type="text"><![CDATA[嘻嘻，这里是一些进站指南，毕竟花里胡哨得人写地花里胡哨的页面： （1）由于背景是随机图片，所以如果看不清，请点击右上角刷新按钮,更换背景图片。 （2）由于左下角是我的“女儿”，所以我是不会为了移动端客户而抛弃我的女儿的，当然可爱的女儿也挡住了我的“压岁钱”的二维码入口，o(╥﹏╥)o。 （3）有什么意见右下角可以联系我呀~，期待 (#^.^#) （4）页首 Links 项里有许多技术、工具、资源、题库站点 （5）暂时就先这样了，后面有什么隐蔽福利更新再更ヾ(◍°∇°◍)ﾉﾞ &amp; 提示：电脑端右下角,里面有个界面超好看的电影推荐链接，推荐！！！后面会增加更多的资源以及技术博文欢迎PC端订阅呀！（为了女儿，抛弃移动端[○･｀Д´･ ○]）]]></content>
      <categories>
        <category>进站指南 </category>
      </categories>
      <tags>
        <tag>指南 </tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE之webpack项目搭建（移动端UI）]]></title>
    <url>%2F2019%2F03%2F21%2FUI-%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[简介：手动由 webpack 简单搭建的 Vue 移动端项目，使用到的技术主要有 ：vue2.x、webpack4.0、es6模块化、Mint-ui 及 MUI … 项目结构：UIMint-ui类似于移动端的 element-ui 。 官方文档：http://mint-ui.github.io 可以使用按需导入，来减小项目的体积。 注意：CSS需要手动导入 MUI 官方文档：http://dev.dcloud.net.cn/mui/ui 类似于 BootStrap ，配套的CSS HTML，适用于任何项目。相比之下，Mint-UI是真正的 Vue 的组件库。 需要手动下载安装，从 github 上下载现成的包，解压出来后手动拷贝到项目中 lib 文件夹下，使用。 GITgit init 初始化 git status 显示提交的文件的状态 git add . 将提交的文件放入了 文件暂存区 里 git commit -m &quot;init my project&quot; 提交到了本地 尚与远端未有联系 这里使用的是gitee，创建公钥，已有在C盘用户下找 .ssh 文件夹下，.pub文件即为创建过得公钥 创建远程仓库 git config --global --list 查看git用户配置信息 Git 全局设置： 12git config --global user.name "user.name"git config --global user.email "user.email" 提交代码： 传统方式 git add . git commit -m &quot;提交信息&quot; git push vscode默认集成的 GIT 工具。 + 暂存 输入修改记录 点击√提交本地 点击更多里推送选项 GIT 之 vscode: 绿色表示 添加的代码 蓝色表示修改的 红色表示删除的 补充vscode 快捷方式 ： ctrl + D 点击一次选中下一个相同代码 ctrl + shif + L 选中页面所有相同代码 同时选择上一行 (Ctrl + Alt + Up) 或者下一行 (Ctrl + Alt + Down) 的相同位置 错误汇总：mint-ui懒加载组件lazy load的使用 gitwin10环境，中间有修改过远程仓库网址密码会报错： username or password ( access token )。 解决：参考链接 html豆瓣API访问图片403，对于img标签，可使用referrerpolicy属性 1&lt;img src="https://img3.doubanio.com/view/photo/m_ratio_poster/public/p2503578746.jpg" referrerpolicy ="never"&gt; 兼容性不是很好好像。但是chrom这个跑demo没问题 webpack移除严格模式一些框架使用到 caller、callee、arguments会报错，是 webpack 严格模式打包导致的，禁用webpack用严格模式打包 移除严格模式：https://github.com/genify/babel-plugin-transform-remove-strict-mode babel升级问题babel-loader和babel-core版本不对应会产生问题，babel-loader 8.x对应babel-core 7.xbabel-loader 7.x对应babel-core 6.x 12# 安装babel-core 7.xnpm install -D @babel/core babel-preset-stage-0 貌似已弃用，卸载删除 其它的babel插件改为 @babel/...前缀 并以此前缀安装配置 升级命名1234# 安装npm i -g babel-upgrade# 运行命令npx babel-upgrade --write --install 参考链接 ChromeChrome自己的东西 1234* &#123; /* 解除滑动时的警告 Chrome自己的东西*/ touch-action: pan-y;&#125;]]></content>
      <categories>
        <category>技术 - 前端技术 - VUE-UI</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>VUE-UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由 todoMVC 深入 VUE.2x]]></title>
    <url>%2F2019%2F03%2F21%2FVueDetail%2F</url>
    <content type="text"><![CDATA[简介：此处的 Vue 指的是 Vue2… 简易实现： 这里是简易实现其双向绑定等功能的 todoList 。 123.done &#123; color:#ccc;&#125; 1234567891011&lt;div id="app"&gt; &lt;h1&gt;ToDoList&lt;/h1&gt; &lt;p&gt;&#123;&#123; todos.filter(item =&gt; !item.done).length &#125;&#125; of &#123;&#123; todos.length &#125;&#125; remaining [archive]&lt;/p&gt; &lt;p v-for="(item,index) in todos"&gt; &lt;input type="checkbox" v-model="item.done"&gt; &lt;span v-bind:class="&#123;done: item.done&#125;"&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt;tton &lt;button @click="handleRemoveTodoClick(index)"&gt;&lt;/button&gt; &lt;/p&gt; &lt;input type="text" @keydown.enter="handleAddTodoClick" v-model="todoText"&gt; &lt;button @click="handleAddTodoClick"&gt;Add&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344const todos = [ &#123; id: 1, title: '上班', done: true &#125;, &#123; id: 2, title: '撸代码', done: true &#125;, &#123; id: 3, title: '加班', done: true &#125;]const app = new Vue(&#123; el: '#app', data: &#123; todos, todoText: '' &#125;, methods: &#123; handleAddTodoClick () &#123; const todos = this.todos const todoText = this.todoText.trim(); // 非空校验 if (!todoText.length) &#123; return &#125; this.todos.push(&#123; id: todos[todos.length - 1].id + 1, title: todoText, done: false &#125;) // 清空文本框 this.todoText = '' &#125;, handleRemoveTodoClick (index) &#123; this.todos.splice(index,1) &#125; &#125;&#125;) 基础注意：值得注意的基础内容。 el:123new Vue(&#123;el:'#app'&#125;)也可以写为 new Vue(&#123; data... &#125;).$mount('#app')。//将 app 绑定到 window 上以便于使用 localStroage 等window.app = new Vue(&#123;...&#125;).mount('#app') 数据绑定 data：12345678910111213141516171819201. `v-once` 一次性绑定 &#123;&#123; message &#125;&#125;。2. `rawHTML:'&lt;h1&gt;...&lt;/h1&gt;'` - 可以用 `v-html="rawHTML"` - 渲染输出 &#123;&#123; rawHTML &#125;&#125; 转义不渲染。 3. `&#123;&#123; message &#125;&#125;` 接受： - 输出文本字符串及拼接 `&#123;&#123; 'Hello' +word &#125;&#125;`。 - 三元表达式 `&#123;&#123; true ? 123 : 456 &#125;&#125;` 。 - `&#123;&#123; message.split('').reverse().join('') &#125;&#125;` - 不能写进标签绑定属性（使用 v-bind）。 - 不能用于双向绑定 （使用 v-model）。 - 会有闪动问题 （使用 v-text/v-cloak）4. v-bind 之于绑定 标签属性： - v-bind 绑定字符串及拼接 `v-bind:href="'/todos?id=' + item.id"` 。 - v-bind 三元表达式 `v-bind:id="'list'"`。5. HTML 字符串中不能使用 Vue 语法（非组件内）。6. data 中的成员只能修改，不能外部添加。7. v-model 用于表单控件的各种双向绑定。 指令 v-：1234567891011121314151617181. `v-if = "true"` 条件渲染。 - 如果想要渲染多个元素，可以用 template 元素包裹，最终结果 template 将不被渲染。 - v-if 惰性渲染，直接决定是否渲染元素，v-show，决定是否显示元素。2. `v-for="(item,index) in todos"` 循环渲染。 - 可以循环 数组 对象 数字 数组对象。 - 使用 key 绑定到更加牢固。 3. `v-bind:placehodler="tip"` 绑定属性 有参数 缩写 :placehodler。4. `v-model.number="number"`，用户输入的全部都是字符串，需要数字转换可以用该修饰符。5. `v-on:click.prevent="handlelInputFocus"` 绑定事件 有参数 可有修饰符 缩写 @click。 - 指令修饰符可串联 - .stop 阻止事件冒泡。.self只管理自己，嵌套时不阻止外层冒泡。 6. v-pre Vue将跳过被该标记标记的块。7. `v-text = "&#123;&#123; message &#125;&#125;"` 解决单个元素闪动问题。8. v-cloak `[v-cloak]&#123;display:none&#125;`，解决代码块闪动问题，可以继续用 `&#123;&#123; message &#125;&#125;`。 绑定样式：12345671. `:class="&#123;active:false&#125;"` - `:class="[activeClass,errorClass]"` 3. `:style="&#123;backgroundColor: bgc&#125;"` 样式名驼峰命名法 - `:style="[baseStyle,overridingStyle]"` - `:style` 可以自动添加浏览器引擎前缀 - `:style="&#123;display:['-webkit-box','-ms-flexbox','flex']&#125;"`多重值，添加多个浏览器前缀 选项注意：methods/computed/watch 对比： computed 适合一些反复使用简单计算，会作为属性被存储。 methods 适合比较复杂的业务逻辑，方法集合。 watch 适合对一些特殊的数据监听再进行具体的业务逻辑。 方法 methods：123451. methods 中的方法不要使用箭头函数，否则其中的 this 指向 window。 - methods 当传入自己的参数的时候，event 需要手动传入，`@click = "fn(index,$event)"`。 - v-on 注册的方法可以直接通过 this 来访问 data 中的数据成员。 - 模板中使用方法必须调用，即带括号 `&#123;&#123; fn() &#125;&#125;`。 - 一个方法清除另一个方法中的定时器 id，该 id 放到 data 中去。 计算属性 computed:具有行为的属性。 123456789101112131415161718192021// 当想要显示一个数组的副本，而不改原始数组时，可以创建返回过滤或排序的计算属性// ...computed:&#123; //默认只有 getter 'message': function () &#123; return this.number + 1; &#125; //使用 setter oneComputed:&#123; // 取值 get () &#123; // 计算属性被使用时，会调用 get 计算出的值 &#125;, // 赋值 set () &#123; // 当你想要为 oneComputed 重新赋值的时候就会调用 set 方法 // set 中的方法使用 this.oneComputed 就是指向自己的 get() 值 &#125; &#125;&#125;//... 使用到的 data 中的变量改变时，会随即跟着改变重新计算。 当做属性调用不是用调用方法的方式。 使用计算属性出现渲染不对错误：在过滤后再次编辑 完成/未完成按钮 ，出现渲染错误，按官方文档 在 v-for 之后给予 v-bind 解决。 1v-for="item in items" v-bind:key="item.id" 适用于所有列表渲染不正确。 侦听器 watch:可以监听 data 上的所有数据。 12345678910111213141516// ... va1,oldVal2 变化的值的新老值watch: &#123; a: function (va1,oldVal2) &#123; // 用方法侦听 a &#125;, b: "oneMethod", // 调用方法侦听 b c: &#123; handler: function (va1,oldVal2) &#123;...&#125;, // handler 是固定的不能乱写 deep: true // 深度监听 c ——&gt; 监听引用类型的数据时可用 &#125;, d: &#123; onclickIt: function (va1,oldVal2) &#123;...&#125;, immediate: true // 侦听 d 开始后，立即调用 &#125;&#125;// ... 也可以监听非 dom 元素，比如 路由变化，参考 路由 过滤器 |fn ：本质就是格式转化的方法，在需要调用的地方以其要求格式调用。 用作一些常见文本格式化。用在两个地方，双花括号插值和 v-bind 。 123 &lt;!--调用：&#123;&#123; name | 过滤器名称 |...&#125;&#125; 把结果依次向后过滤--&gt;&lt;p&gt; &#123;&#123; message | msgFormat(arg,arg2) | ... &#125;&#125; &lt;/p&gt;&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt; 12345678910// 全局Vue.filter('msgFormat',function (msg,arg,arg2) &#123; return msg.replace(msg,arg+arg2)&#125;)// 组件filters: &#123; formatId: function (msg,arg,arg2) &#123; return msg.replace(msg,arg+arg2) &#125;&#125; 注意：定义全局过滤器一定要在 Vue 实例之前，当全局过滤器和局部过滤器重名时，会采用局部过滤器。 自定义修饰符：键盘码 1&lt;input @keyup.f2="add"&gt; 12// 全局Vue.config.keyCode.f2 = 113; 生命周期函数： 函数名称/进程 进行阶段/执行时机 beforeCreate () {} 实例被创建出来之前 执行，此时实例中的 data 和 methods 还没有创建 created () {} 此时 data和methods 已被初始化，调用其中的值，最早在这里 — 判断环 — Vue 开始执行指令，内存中生成模板字符串，再渲染为内存中的DOM树 beforeMount () {} 在内存中已生成模板字符串，还未渲染（挂载）到页面 — 执行环 — 挂载到页面 mounted () {} 挂载到页面后执行该函数（通过插件执行页面DOM节点的最早时期） — 创建完成 — 组件完全创建 ok 进入 运行阶段** beforeUpdate () {} 数据更新，界面未更新时触发 — 更新界面 — 根据 data 更新界面 updated () {} 界面 以更新 beforeDestroy () {} 组件销毁之前，Vue上的data,methods等还处于可用状态 — 销毁实例 — 销毁实例 destroyed () {} 组件已完全销毁时执行 — 此外 — activated () {} 待补充 deactivated () {} 待补充 errorCaptured () {} 待补充 自定义指令：语法：对普通 DOM 元素进行底层操作，会用到自定义指令。 1234567891011121314151617181920212223242526272829303132333435// 全局Vue.directive('focus',&#123; bind (el, binding) &#123; //el为绑定元素 binding.value 为传入的值 ... &#125;&#125;)// 私有...directives: &#123; 'fontweight': &#123; bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;&#125;... // 私有简写directives: &#123; 'fontweight':function (el, binding) &#123; // 若只关心 bind 和 update 可以简写，直接写函数 &#125;&#125;/** 第一个参数是命名：1. 分为全局（注册）自定义指令、局部（注册）自定义指令。2. 使用时，名字加 v-。3. 驼峰命名 使用时加 v-，且改小写，用 - 连接。4. 组件内定义的自定义指令，只能在被该组件管理的模板中使用。第二个参数需要配置生命钩子函数：1. 生命钩子里有 dom 和 值，即可以进行 DOM 操作。使用时传入的值：1. 需要传入多个值，可以使用 js对象字面量。2. 指令函数可以接受所有合法的 js 表达式。 **/ 钩子函数：123456789101112131415161718192021222324252627282930// 相对于 指令定义对象可以提供如下几个钩子函数bind (el) &#123; // 只调用一次 指令第一次绑定到元素上（加载到内存上）时调用，初始化指令时使用。拿不到父结点 // 和样式相关 放到这里 el.timer = setInterval(function()&#123; console.log(1) &#125;,1000)&#125;;inserted () &#123; // 被绑定元素插入父结点时（渲染到页面上时）调用。可以拿到父节点。 // 和 JS 行为相关，放到这里&#125;;update () &#123; // Vue 管理的模板中的 DOM 更新前调用，若需要改变之前的数据&#125;;componentUpdated () &#123; // Vue 管理的模板中的 DOM 更新后调用，若需要改变之后的数据 &#125;;unbind () &#123; // 只调用一次 // 解绑时使用，及元素移除时。移除其他生命周期中的函数，定时器等。（防止内存泄漏？） window.clearInterval(el.timer)&#125;;/** 可以传四个参数：1. el 作用于该指令的 DOM 对象。2. binding 一个对象,可以获取指令的值等信息，就可以拿指令值和DOM进行比较判断。3. vnode4. oldVnode **/ 手动实现 v-show:12345678910111213141516171819202122232425262728293031//html... v-my-show = "seen" ...// new Vuenew Vue(&#123; data:&#123; seen:true &#125;&#125;).$mount('#app')// 手动实现 v-show 效果Vue.directive('my-show',&#123; bind (el,binding) &#123; // 只能调用一次，也可以绑到其他生命周期上 console.log('my-show bind',el,binding); if (binding.value) &#123; el.style.display = 'block' &#125; else &#123; el.style.display = 'none' &#125; &#125;, update (el,binding) &#123; // 更新时调用 if (binding.value) &#123; el.style.display = 'block' &#125; else &#123; el.style.display = 'none' &#125; &#125;&#125;)// 若只关心 bind 和 update 可以简写，直接写函数Vue.directive('my-show',function (el, binding) &#123; el.style.display = binding.value&#125;) 手动实现 v-bind:1234567891011121314151617181920212223242526272829303132333435// 实现 v-bind:title="message" 效果Vue.directive('my-bind',&#123; bind (el,binding) &#123; el.setAttribute(binding.arg,binding.value) &#125;, update (el, binding) &#123; el.setAttribute(binding.arg,binding.value) &#125;&#125;)// 或简写Vue.directive('my-bind',function (el, binding) &#123; el.setAttribute(binding.arg,binding.value)&#125;)// 进一步实现 v-bind:class = "&#123;&#125;"Vue.directive('my-bind',&#123; bind (el, binding) &#123; if (binding.arg === 'class') &#123; for (let key in binding.value) &#123; if (binding.value[key]) &#123; el.classList.add(key) &#125; else &#123; el.classList.remove(key) &#125; &#125; &#125; else &#123; el.setAttribute(binding.arg,binding.value) &#125; &#125;&#125;)const app = new Vue(&#123; data:&#123; message:"myTitle" &#125;&#125;) vue-resource 之请求: vue-resource: https://github.com/pagekit/vue-resource 也可以用 axios 测试请求资源，我用的是 豆瓣API 123456789101112131415161718192021222324252627...methods: &#123; fnName () &#123; // res 成功回调必须要传，err 可选 this.$http.get(/url/...,[options]).then(res=&gt;&#123; console.log(res) &#125;,err=&gt;&#123; console.log(err) &#125;) // [body] 提交给服务器的内容， // [option]提交的内容格式，数据类型， // 一般为 application/x-www-form-unlencoded this.$http.post(/url/...,[body],[options]).then(res=&gt;&#123; // 比如添加数据，添加完成后手动调用一下获取列表方法刷新数据 if (res.body.status ===0) &#123; getList() &#125; else &#123; console.log('失败了') &#125; &#125;,err=&gt;&#123; &#125;) &#125;&#125;... 全局配置数据接口的根域名：vue-resource: Set default values using the global 123456// 为了避免根域名过多重复，不易维护Vue.http.options.root = '/root';// 使用时必须是以相对路径开头// 配置 POST 提交的内容格式Vue.http.options.enulateJSON = true; 跨域：JSONP：12345678910&lt;!-- 前端页面 --&gt;&lt;body&gt; &lt;div&gt; ... &lt;/div&gt; &lt;script&gt; function showInfo(data) &#123; console.log(data) &#125; &lt;/script&gt; &lt;script src="http://127.0.0.1:3000/getscript?callback=showInfo"&gt;&lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819// 后端代码 node.jsconst http = require('http')const urlModule = require('url')const server = http.createServer()server.on('request',function (req, res) &#123; const &#123; pathname:url, query &#125; = req.urlModule.parse(req.url, true) if (url === '/getscript') &#123; var scriptStr = `$&#123;query.callback&#125;($&#123;JSON.stringify(data)&#125;)` res.end(scriptStr) &#125; else &#123; res.end('404') &#125;&#125;)server.listen(3000,function()&#123; console.log('server listen at http://127.0.0.1:3000')&#125;) 动画：过度的类名： 过度类名 时机 v-enter 定义进入过渡的开始状态。 v-enter-active 定义进入过渡生效时的状态。 v-enter-to 定义进入过渡的结束状态。 v-leave 定义离开过渡的开始状态。 v-leave-active 定义离开过渡生效时的状态 v-leave-to 定义离开过渡的结束状态。 transition （单个）元素：Vue 官方提供的元素。 123456789101112131415.v-enter,.v-leave-to&#123; /* 由于起始状态 样式相同，故写在同一样式中 */ opacity: 0; transform: translateX(150px); /*transform:位移*/&#125;.v-enter-active,.v-leave-active&#123; /* 入场离场的动画的时间段：对象，速度，曲线 */ transition: all 0.4s ease;&#125;.mark-enter,.mark-leave-to&#123; /* 由于起始状态 样式相同，故写在同一样式中 */ opacity: 0; transform: translateY(150px); /*transform:位移*/&#125;.mark-enter-active,.mark-leave-active&#123; /* 入场离场的动画的时间段：对象，速度，曲线 */ transition: all 0.4s ease;&#125; 12345678&lt;input type="button" value="toggle控制动画的控制模块" @click="flag=!flag"&gt;&lt;transition&gt; &lt;div v-if="flag"&gt;我是原始动画模块&lt;/div&gt;&lt;/transition&gt;&lt;transition name="mark"&gt; &lt;div v-if="flag1"&gt;我使用的是mark标识的动画样式&lt;/div&gt;&lt;/transition&gt; 123456...data: &#123; flag:true, flag1:true,&#125;... animate.css 三方类实现：animate.css 三方类库 12345678910111213141516171819202122232425&lt;transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut"&gt; &lt;div v-if="flag2"&gt; 1. animate直接在标签上de属性上add类 2. animated 是基础类 &lt;/div&gt;&lt;/transition&gt;&lt;transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="800"&gt; &lt;div v-if="flag3" class="animated"&gt; 1. animated也可以直接放在元素上 2. :duration="毫秒值" 入场离场总共花费的时间 &lt;/div&gt;&lt;/transition&gt;&lt;transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="800"&gt; &lt;div v-if="flag3" class="animated"&gt; 1. animated也可以直接放在元素上 2. :duration="&#123;enter:200, leave:400&#125;" 传入对象 入场离场各自时长 &lt;/div&gt;&lt;/transition&gt; 钩子函数，半程动画：这里的钩子指的是动画的生命周期，半程动画需要借助 动画钩子函数。 123456789101112&lt;!-- 如果写半程动画，只需要定义 上或下 函数即可 --&gt;&lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter" @enter-cancelled="enterCancelled" @before-leave="beforeLeave" @leave="leave" @after-leave="afterLeave" @leave-cancelled="leaveCancelled"&gt; &lt;div class="ball" v-show="flag"&gt;&lt;/div&gt;&lt;/transition&gt; 12345678910111213141516171819// ... el 控制的元素methods: &#123; beforeEnter (el) &#123; // 起始样式 el.style.transform = "translate(0,0)" &#125;, enter (el,done) &#123; el.offsetWidth // 强制动画刷新，显示过渡效果 // 起始后的样式，这里可以设置结束状态 el.style.transform = "translate(150px, 150px)" el.style.transition = 'all 1s ease' done() // 这里的 done 就是指 afterEnter函数 的应用 &#125;, after-enter (el) &#123; // 动画完成之后 this.flag = !this.flag &#125;&#125;// ... leave () 和 enter () 中写 done() 列表transition-group（多个元素）动画： 当列表是用 v-for 循环渲染的，使用 transition-group 代替 transition元素。 不仅有 transition 的进入和出时的过渡类，另外添加了新的 .v-move 类。可以在元素改变定位的过程中使用。 注意：在 v-for 添加 key 属性:key=&quot;item.id&quot;。 需要平缓过渡除了添加 .v-move 类，还要设置 .v-leave-active 类 position:absolute。 transition-group 上的 appear属性 增添入场效果。 transition-group 上的 tag属性 ，将 transition-group 渲染为什么属性，如果没有默认为 span标签。 组件过渡(动画)：组件：模块化：从代码逻辑划分，保证功能模块职能单一。 组件化：从UI界面划分，方便 UI 重用。 基础：1234561. 组件，在 VUE 中即一个特殊（可复用）的 Vue 实例。 - 组件的 data 是一个 data函数 返回的对象的形式。使得重复使用，也互不影响。 - 组件是独立作用域。 - 组件里 根元素 唯一。 - 全局注册（Vue.component()）。可以在任意组件中（子兄）使用。 - 局部注册（components:&#123;&#125;）。组件实例选项 components 选项。只能在本组件使用。 全局注册:12345678910111213141516171819202122// 第一种方式：内部定义Vue.component('my-component', &#123; // 此处若命名 驼峰，使用时用 - 连接 template: `&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;`, data () &#123; // 组件中使用 data选项 特有形式，保证可重复使用 return &#123; message: '...' &#125; &#125;, methods: &#123;&#125;, ..., components: &#123; hello: &#123; // 键名就是组件名称，值是一个对象，对象中配置组件选项 template: `&lt;div&gt;&#123;&#123;message2&#125;&#125;&lt;/div&gt;` &#125; &#125;&#125;)// 第二种方式：Vue.extendvar vm = Vue.extend(&#123; template: '&lt;h3&gt;这是创建Vue组件的第二种方式&lt;/h3&gt;'&#125;)Vue.component('my-component', vm); 123456789&lt;!-- 第三种方：外部定义 --&gt;&lt;template id="tmpl"&gt; &lt;div&gt;这是创建组件的第三种方式&lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-template', &#123; template: '#tmpl' &#125;)&lt;/script&gt; 局部组件：使用 Vue 实例中的 components 选项。 12345678...components: &#123; my-component: &#123; // 内部定义 template: '&lt;div&gt;我仅在定义内的实例中使用&lt;/div&gt;' &#125;, template: '#mycomponentid' // 外部定义&#125;... 12345&lt;template id="mycomponentid"&gt; &lt;div&gt; 我是局部组件外部定义 &lt;/div&gt;&lt;/template&gt; 组件切换：&lt;component :is=&quot;mycomponentflag&quot;&gt;&lt;/component&gt; 组件通信：12345671. 父子关系 * 属性（prop）向下传递（父传子）。Pass Props * 事件（event）向上传递 （子传父）。Emit Events2. 非父子关系 * Event Bus3. 专业组件通信 * Vuex 状态管理 prop:1&lt;todo-list message="message" v-bind:foo="todos"&gt; 父 &lt;/todo-list&gt; 12345678// 子用 props 选项声明，当做子组件的数据使用...,props:['message','foo'], // 自己组件声明的变量...,// 1. 第一个是字符串形式。// 2. 第二个只有 v-bind 传输是动态数据形式。且为单项数据流，不能修改，只能使用。// 3. 如果是引用类型（对象和数组）则可以修改（不能重新赋值），但是不推荐使用。// 4. 但是子可以用事件（event）把数据给父亲，由父亲改。 event / $emit():子组件内部调用父组件的方法，可以顺便传值 1234567891011121314151617// 1. 在 父组件 中定义一个方法。 ..., methods: &#123; addTodo (titleText) &#123; titleText = titleText.trim() if (!title.Text.length) &#123; return &#125; const todos = this.todos todos.push(&#123; id: todos[todos.length - 1].id + 1, title: titleText, completed: false &#125;) &#125; &#125;, ..., 12345678910111213// 2. 在 子组件 内部调用父组件的方法 ..., methods: &#123; handleKeyDown (e) &#123; const target = e.target const value = target.value.trim() if (!value.length) &#123; return &#125; this.$emit('newTodo',value) &#125;, &#125;..., 1&lt;todo-header v-on:newTodo="addTodo"&gt; 父组件标签 &lt;/todo-header&gt; $ref 引用：ref [ reference : 引用 ] $ref / 获取 DOM 元素：1234&lt;input type="button" value="获取DOM元素内容" @click="getElement"&gt;&lt;div id="myId" ref="myId"&gt; Vue 中推荐用 this.$refs 获取我&lt;/div&gt; 1234567...methods: &#123; getElement () &#123; console.log(this.$refs.myId.innerText) &#125;&#125;... $ref / 组件引用：12&lt;input type="button" value="获取DOM元素内容" @click="getElement"&gt;&lt;my-template ref="mytemlate"&gt; 子组件的data：&#123;&#123; sondata &#125;&#125; &lt;/my-template&gt; 12345678910111213// 子组件...data () &#123; return &#123; sondata: '我代表子组件数据' &#125;&#125;methodes: &#123; show () &#123; console.log('我代表子组件的方法') &#125;&#125;... 12345678910// 根实例...methods: &#123; getElement () &#123; console.log(this.$refs.mytemplate.sondata) this.$refs.mytemplate.show() &#125;&#125;... 路由 vue-router:后端路由是： url 对应 后端资源。 前端路由是： 单页面程序用 hash 实现页面跳转，不会涉及到页面的刷新。 安装使用： 官方入口 : https://router.vuejs.org/installation.html#direct-download-cdn 基本使用：在导入 vue-router 包之后，会在 window 全局对象中创建一个 路由的构造函数 VueRouter。 12345678910111213141516171819202122// 组件var mytpl = Vue.extend(&#123; template:'&lt;div&gt; 我是组件1，组件2省略 &lt;/div&gt;'&#125;)Vue.component('template-name1', mytpl)// 构造路由器 配置对象（路由规则配置）var routerObj = new VueRouter(&#123; routes: [ // component 值只能是组件模板对象，不能是组件名称 &#123;path: '/templateUrl1', component: mytpl&#125;, &#123;path: '/templateUrl2', component: mytpl2&#125;, &#123;path: '/', redirect: '/login'&#125; // refirect 仅修改hash值的 "重定向" ], linkActiveClass: 'myactive' // 修改给予的link-active-class类名&#125;)// Vue 根实例 router 选项挂载，用来监听 url 地址变化...router: routerObj... 123456789&lt;!-- 页面组件导航 &lt;a href="#/templateUrl1"&gt;&lt;/a&gt;--&gt;&lt;!-- 默认为 a标签 可以用 tag属性 修改--&gt;&lt;router-link to="/templateUrl1"&gt;&lt;/router-link&gt;&lt;router-link to="/templateUrl2" tag="span"&gt;&lt;/router-link&gt;&lt;!-- 页面组件入口 --&gt;&lt;transition mode="out-in"&gt; &lt;!-- 动画元素 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 123456/* router提供 CSS 类名 */.router-link-active,.myactive &#123;&#125;/* 动画效果 */.v-enter,.v-leave-to &#123;&#125;.v-enter-active,.v-leave-active &#123;&#125; 路由传参 / $router：12345678910111213141516171819var mytpl = &#123; template: '&lt;div&gt;&#123;&#123; $route.query.id &#125;&#125;&amp;&amp;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;' created () &#123; console.log(this.$route) // console 路径信息 &#125;&#125;var routerObj = new VueRouter(&#123; routes: [ &#123;path: '/templateUrl1?id=10&amp;name=zs', component: mytpl&#125;, &#123;path: '/templateUrl2/:id', component: mytpl2&#125;, &#123;path: '/', redirect: '/login'&#125; ], linkActiveClass: 'myactive'&#125;)/* query 方式传递参数： 1. 如果在路由中使用 ?查询字符串 不需要修改 path 属性，在 query 里 2. :id 是经 matchd 正则解析过得id值，在 params 里*/ $route.path 监听路由：1234567891011... watch: &#123; 'this.$route.path':function (newVal, oldVal) &#123; if (newVal === '/login') &#123; alert('欢迎登录') &#125; else if (newVal === '/register') &#123; alert('欢迎注册') &#125; &#125; &#125;... 路由嵌套/children项：1&lt;router-link to="/mytpl/child1"&gt;&lt;/router-link&gt; 12345678910111213var routerObj = new VueRouter(&#123; routes: [ &#123; path: '/templateUrl1?id=10&amp;name=zs', component: mytpl, // path前面不要带 / 否则会以根路径开始请求，不方便用户理解用户地址 children: &#123; &#123;path:'child1',component: child1&#125; &#125; &#125; ], linkActiveClass: 'myactive'&#125;) 路由布局/router-view name属性：12345678910111213var routerObj = new VueRouter(&#123; routes: [ &#123; path: '/', component: &#123; 'default': header, 'left': leftBox, 'main': mainBox &#125; &#125; ], linkActiveClass: 'myactive'&#125;) 12345&lt;router-view name="header"&gt;&lt;/router-view&gt;&lt;div class="container"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;router-view name="main"&gt;&lt;/router-view&gt;&lt;/div&gt; 基本项目结构：1234567index.html 首页 | main.js 组件化应用启动入口 | app.js APP.js 根组件 | ... 各个组件 webpack之Vue：render：使用 render 方法渲染组件。 1234567891011var mytemplate = &#123; template: '&lt;div&gt;我是一个组件&lt;div&gt;'&#125;var vm = new Vue(&#123; ... render: function (createElement) &#123; var html = createElements(mytemplate) return html &#125; ...&#125;) return 的结果会替换 el 指定的容器。但是之中只能放一个组件。 webpack配置：在webpack构建的项目中进行vue开发。 1npm i vue -S # 将vue安装到项目运行阶段 1234567// main.jsimport Vue from 'vue' // 此处的vue功能不完整，只提供了 runtime-onlyimport Vue form '../node_modules/vue/dist/vue.js' // 比较全var vm = new Vue(&#123; el:'#app'&#125;) 注意：在VUE中package.json文件中查找 main 属性来查找node import导入的包。 如果使用第一种导入方式需要在webpack.config.js 中配置 resolve属性。 12345678// webpack.config.js...resolve:&#123; alias: &#123; // 设置（修改） Vue 被导入包的路径 "vue$": "vue/dist/vue.js" &#125;&#125;... runtime-only 不提供传统创建组件模式，此时将引入 .vue 格式文件。 .VUE：1234567891011121314151617181920212223242526272829&lt;!-- mytemplate --&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;一个组件只能有一个根元素（div）&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 这里写组件的业务逻辑 用ES6规范 export default 导出 export default &#123; data () &#123; // 这里组件中的 data 必须是 function return &#123; msg: &quot;234&quot; &#125; &#125;, methods: &#123; &#125; &#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt; /*1. scoped 指定作用域（给div块自动添加属性） 2. lang=&quot;****&quot; 启用 预编译*/ body&#123; div &#123; color: red; &#125; &#125;&lt;/style&gt; 向外暴露成员的方式 ES6 和 node.js： node中是 module.exports={}`exports.a=’’向外暴露成员，var 名称 = require(‘模块标识符’)` 加载模块，详细参考 node 中3.5.1 CommonJS 模块规范。 ES6 中 import 模块名称 form &#39;模块标识符&#39;、import &#39;标识路径&#39; 导入模块，使用 export default（只允许向外暴露一次，类似于 module.exports） 和 export（import {模块名1，模块名2 as 别名...} form &#39;标识路径&#39; 按需导出）向外暴露成员（两者可以同时使用）。 注意不要混用。 webpack 无法打包 .vue 文件，需要用到相关的第三方 1npm i vue-loader vue-template-compiler -D # 前者内部依赖后者 12345678910// webpack.config.js...module: &#123; rule: [ ... // 处理 .vue 文件 loader &#123; test: /\.vue$/, use: 'vue-loader'&#125; ... ]&#125;... 然后使用 render 实现组件渲染 12345678910// main.jsimport mytemplate from './mytemplate.vue'var vm = new Vue(&#123; el: '#app', data: &#123; msg:'123' &#125;, render: c =&gt; c(mytemplate)&#125;) 总结： 安装配置 vue 及 webpack打包vue的三方包。 导入 vue 模块 创建.vue组件文件并导入 创建实例使用 render 创建实例控制区域… webpack 结合 vue-router：根据 官网 模块化导入安装： npm i vue-router -S 安装。 import VueRouter from &#39;vue-router&#39; 导入。 Vue.use(VueRouter) 手动安装。 import app form &#39;./main/app.vue&#39; 导入组件。 var router = new VueRouter({...}) 创建路由对象。 将 其他组件 router-view 写到 根组件 里去 抽离组件模块，将2 4（除根组件外）5的内容抽出 export default router 并在 main.js 接收 Vuex为了保存组件之间共享的数据而诞生的，是一个公共数据管理工具，方便整个项目调用。 导入使用 官网: https://vuex.vuejs.org/zh/installation.html 123456789101112131415161718192021222324252627282930313233343536// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)//0. 导入import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 1.声明const store = new Vuex.Store(&#123; state: &#123; // 相当于 data count: 0 &#125;, mutations: &#123; // 负责修改数据 相当于 methods increment (state,...) &#123; // 自增方法 最多可传两个参数，但可以是对象，数组。。。 state.count++ &#125; &#125;, getters: &#123; // 负责对外提供数据 optCount: function (state)&#123; // 相当于组建中的过滤器,都不修改原数据 return '当前最新count：'+ state.count &#125; &#125;&#125;)// 2.挂载到实例var vm = new Vue(&#123; el:'#app', store&#125;)// 3.1 组件中使用v-model="$store.state.count" // 3.2 组建中使用方法 //this.$store.commit('方法名') 类似于 this.$emit('父组件中的方法名')this.$store.commit('increment',...) // 3.3 组建中调用getters 调用又类似 计算属性this.$store.getters.optCount 采坑注意 不推荐直接在组件中操作 state 中的数据，容易导致数据紊乱。通过调用 mutations 提供的方法操作。 vuex 中方法第一个参数永远都是 state 小技巧：12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. Console * `console.dir()` 在控制台可以将传入的元素展开。 * 控制台输入 document.body.classList.(...) 可查看操作 className 的方法。 2. JSON * `JSON.Stringify(&#123;key:"value"&#125;);` 对象转为字符串，某些参数只能是字符串。 * `JSON.parse(JSON.Stringify(&#123;key:"value"&#125;));` 在将字符串转为 JSON。 * `JSON.parse('[]');` // [] JSON格式数组 转为 数组 3. H5 新增 * window.localStorage - `window.localStorage.setItem("key","String")` - `window.localStorage.getItem("key")` * autofocus H5新特性在 Vue 中不稳定（因为虚拟 Dom 问题），需要自定义 - focus 在多个列表时，仅在第一个生效。 4. hash * `window.onhashchange = function()&#123;&#125;` 注册hash的改变事件 * `window.location.hash` 获取hash 5. Vue * 自定义 v-my-focus 指令必须写在 inserted 钩子函数中。 * 双击事件 ondblclick,在 vue 中为 `@dblclick`。 * vue 提供的标签一共四个 component, template, transition, transitionGroup * 标签中 `&lt;input name="string"&gt;` 字符串，js中带引号。 * `&lt;input :value="'value'"&gt;`注意区分变量和值，表值，js中不带引号。 6. 涉及的 ES6： * 可以使用 ES6 简写 省去 function 写为 `handleCountClick () &#123; ... &#125;`。 * ES6 语法 当键和值一样的时候，可以简写，只写一个。 * ES6 新添加的操作数组的方法 forEach some filter findIndex - some() 中返回 true 会立即终止循环 - 当循环遍历删除元素的时候不要用 forEach() 用 for 循环,循环结尾 i--。 * ES6操作字符串 + 新添加includes() - 判断数组名字里里是否包含 keywords： - `if (item.name.indexOf(keywords) != -1)` - `if (item.name.includes(keywords))` + 头尾填充字符串 - String.prototype.padStart(maxLength,fillString="") - String.prototype.padEnd(maxLength,fillString="") * 箭头函数 this 指向外部 - 定时器内部使用箭头函数可指向外部。 * 模板字符串变量用 $&#123;&#125; 包裹 * 参数可设置默认值 `function (pattern="") &#123;&#125;` 7. JS * replace() 第一个参数是需要替换的内容，可以是字符串，也可以是正则。 回顾概念：M V VM：M V VM 是前端的视图层的分层开发思想，主要把每个页面分成了 M，V，VM。VM 是两者的桥梁。 123451. M 是保存每个页面的中的单独的数据。 （Vue中的选项 data）2. V 是每个页面中的 HTML 结构。 （DOM 元素）3. VM 是一个调度者，分割了 M 和 V，V 和 M 的通信即是通过 VM。（new 出来的 app实例对象 就是 VM 调度者）注：VM 提供了数据的双向绑定 M V C :MVC 其实是后端的 模块化分层/分发开发 的概念。 123451. M Model 层，负责操作数据库，执行对应的 SQL 语句，进行数据的 CRUD。2. C Controller 层，router.js 路由模块分发，业务逻辑处理，若涉及数据，调用 Model 层。3. V 通过入口文件的调度整合，整个形成的结果就是 View 视图层。注：模块化，是一种思想，使得各个模块职能单一，易于维护。参考本博客 NODE.JS。 工具:涉及用到的工具。 Chrome 浏览器插件工具 Vue Devtools。 todoMVC 模板仓库 。（1）--depth=1 表示只下载最后一次的 commit,不要其历史记录，可以提高下载速度git clone https://github.com/tastejs/todomvc-app-template.git todomvc-vue --depth=1。（2）npm install 浏览器同步测试工具 browser-sync。（1）npm install --save-dev browser-sync （npm install --production）。（2）配置 package.json 中的 script。 1234"scripts":&#123; "dev": "browser-sync start --server --files \"*.html,css/*.css,js/*.js"", "start": "npm run dev"&#125; （3）启动开发服务 npm run start。 团队协作类工具 Worktile / teambition vscode 插件 Debugger for Chrome 本地调试 Bootstrap 4 Snippets bootstrap代码块提示 便捷指令 Ctrl + T 搜索文件标签 Alt + 鼠标点击 选中列 VUE 提示工具 Vetur Vue 2 Snippets element-ui 进行手机 App 开发，需借助 Weex。 nrm工具 nrm维护了一些常用的 npm包镜像 npm i nrm -g，nrm ls，nrm use taobao webpack 见 webpack 文档]]></content>
      <categories>
        <category>技术</category>
        <category>前端技术</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记]]></title>
    <url>%2F2019%2F03%2F21%2Fwebpack%2F</url>
    <content type="text"><![CDATA[简介： 该文基于 nodejs 网页中手写的常用的静态资源： JS（.js .jsx .coffee .ts） CSS（.css .less .sass .scss） Images（.jpg .png .gif .bmp .svg） Fonts （.svg .ttf .eot .woff .woff2） 模板文件 （.ejs .jade .vue） …等等 这些东西会使得网页速度变慢，其中一些会发起二次请求，以及复杂的依赖关系。 解决这些问题需要 合并压缩、精灵图、Base64(适合小图) 、requireJS、webpack（解决依赖问题）。 webpack 和 gulp 的区别： gulp：基于 task 任务。 webpack：基于整个项目，主要用于资源的合并打包、压缩等。 webpack官网：https://www.webpackjs.com/ 安装：正常安装，注意官网说的事项即可 nodejs 版本要和 webpack 某种程度上的匹配。（这里有坑） webpack4+，还需要安装 webpack-cli。 安装：https://www.webpackjs.com/guides/installation/ 基本使用：示例项目基本结构：1234567891011* dist 文件夹 放着我们所有要交付的代码* src 文件夹 放着我们的源代码 - CSS 文件夹 - images 文件夹 - js 文件夹* index.html 首页* main.js 项目 js 入口文件* package.json 导入包时创建的* webpack.config.js 手动创建 webpack 配置文件* bundle.js 打包好的文件* .babelrc babel 配置文件 基本功能 / JS 打包：处理依赖 及 兼容语法：12# npm 导入包npm i jquire 1234// main.js// 使用包，例如JQuery，使用的是 ES6 导入模块的语法import $ from 'jquery' 123# 有些浏览器无法解析 ES6 需要 webpack 处理webpack .\src\main.js .\dist\bundle.js# 将处理后的放入到指定文件下的 bundle.js 文件 1&lt;script src="../dist/bundle.js"&gt;&lt;/script&gt; 配置文件简化打包命令：12345678910111213141516171819// webpack.config.js// 使用 node 语法中的模块语法 导入 path 模块const path = require('path')// node中向外暴露配置对象module.exports = &#123; // 入口，表示要使用 webpack 打包哪个文件 entry: path.join(__dirname,'./src/main.js'), // 字符串形式 // entry: ['./src/index.js','./src/a.js'], // 数组形式打包多个js // entry:&#123;&#125; // 对象形式打包多页应用 参考进阶篇 // 出口，输出文件相关的配置 output: &#123; // 指定路径 path: path.join(__dirname,'./dist') // 指定输出的文件名称 filename: 'bundle.js' &#125;&#125; 123# 直接使用 webpack 即可webpack# 未指定 入口 出口 会直接去 'webpack.config.js' 中找 webpack-dev-server ：自动打包编译。 12# -D 安装到本地开发依赖npm i webpack-dev-server -D 由于无法直接执行非全局安装的 webpack-dev-server，所以需在 package.json 中配置一下。 1234567// package.json 文件..."scripts": &#123; ... "dev": "webpack-dev-server" // 使用 npm run dev 即可代替&#125;... 1npm run dev 注意： 即使在全局安装过 webpack 也要在本地再安装一次（坑）。 引入标签修改为：&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt; 。 打包生成的 bundle.js 并没有存放到 实际的 物理磁盘 上，而是直接托管到了电脑的内存中，因此在项目根目录中找不到。可以当做是一种虚拟的形式托管。这个机制是因为处理速度会更快。 webpack-dev-server 常用参数：第一种方式： 12345678910111213// package.json 文件..."scripts": &#123; ... "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot" /* 设置参数： 1. 自动打开浏览器 2. 设置端口号 3. 直接打开首页 4. 热启动，只更新局部打入补丁，可异步刷新，即不用手动刷新浏览器 */&#125;... 第二种方式：（比较麻烦，不推荐） 1234567// package.json 文件..."scripts": &#123; ... "dev": "webpack-dev-server“&#125;... 1234567891011121314// webpack.config.jsconst webpack = require('webpack') // 2.启用热更新需要导入，配置 plugins...devServer: &#123; // 配置 dev-server 命令参数 open: true, // 自动打开浏览器 port: 3000, // 指定端口 contentBase: 'src', // 指定托管根目录 hot: true, // 1.启用热更新 compress:true, // 启动服务器压缩 &#125;,plugins: [ // 配置插件节点 new webpack.HotModuleReplacementPlugin() // 3.new 一个热更新模块对象，启用热更新]... 基本功能 / HTML ：html-webpack-plugin 插件： 在内存中生成 HTML 页面的插件。 自动追加缺失未引入的打包好的（bundle.js）js文件。 123456789101112131415161718192021// webpack.config.jsconst webpack = require('webpack')// 导入插件使用的包，放入到 plugins 节点中去const htmlWebpackPlugin = require('html-webpack-plugin')...plugins: [ // 配置插件节点 ... new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 指定模板页面 filename: 'index.html', // 指定生成页面的名称 title: 'webpack架构', // title标签内容 hash: true, // 清缓存 minify: &#123; // 压缩 html removeAttributeQuotes:true, // 删除html标签属性的双引号 collapseWhitespace:true, // 从删除空行 &#125; &#125;) ...]... 12&lt;!--index.html EJS模板配置title--&gt;&lt;title&gt; &lt;%=htmlWebpackPlugin.options.title%&gt; &lt;/title&gt; CSS处理/loader：&lt;link&gt; 导入 CSS 会引起二次请求。 CSS 处理 非 JS 类型的文件，需手动安装合适的第三方 loader 加载器。这里分别为 style-loader css-loader。 1npm i style style-loader css-loader -D 在 webpack配置文件中新增 module对象，以及存放着所有的三方文件的匹配和处理规则的rules属性。 12// main.jsimport './css/index.css' 12345678910// webpack.config.js...module: &#123; // 所有三方加载器 rule: [ // 所有三方加载器匹配规则 // test 来源于正则方法 reg.test() &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, // 匹配 .css 结尾的文件，用 所写三方规则打包 处理 ]&#125;... 注：查找到对应的规则从后向前调用，即先css-loader处理再交给style-loader再webpack打包 less同理。 12npm i less-loader -D # less-loader 内部依赖于 lessnpm i less -D 123// main.jsimport './css/index.css'import './css/someone.less' 1234567891011// webpack.config.js...module: &#123; rule: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, // 先 less-loader 处理 &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, ]&#125;... scss同理。 12cnpm i sass-loader -D # sass 是 scss 的前身cnpm i sass -D # cnpm镜像比较好装 1234...&#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;,...// -loader 在webpack1.x之后都必须带上 url（图片、字体库）/loader默认情况下，webpack 无法处理 CSS 文件中的 url 地址的图片、字体库，需要三方 loader。 url / 图片12345html,body&#123; .box&#123; background：url('./images/miao.jpg'); &#125;&#125; 1npm i url-loader file-loader # url 内部依赖 file-loader 1234// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader' &#125;,... 以上可以， 将图片转成 bace64 格式，适用于小图片。如果需要按图片大小判断是否需要，则如下传参： 12345// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader?limit=7632' &#125;,...// 如果图片大于或等于 7632byte（字节）则不会转为 base64 格式 未编码的图片会被强行修改图片名称，防止重名。但有些地方会用到同一张图片，则如下传参： 12345// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader?limit=7632&amp;name=[name].[ext]' &#125;,...// [name]表示不改名称，[ext]表示不改后缀名 当遇到放在不同文件夹下相同名称的图片会出现渲染错误，通过截取hash传参，如下： 12345// webpack.config.js...&#123; test: /\.(jpg|png|gif|jpeg|bmp)$/, use: 'url-loader?limit=7632&amp;name=[hash:8][name].[ext]' &#125;,...// 截取 hash 前 8 位（总长 32 位）拼接名称 url / 字体库以 bootstrap 字体库图标为例： 1npm i bootstrap -D 1234// main.js...import 'bootstrap/dist/css/bootstrap.css'// 引入 node_modules 中的文件 可以不写 ./node_modules，默认会去这里找 12345// webpack.config.js...&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;,...// 处理字体文件loader模块 进阶使用：babel配置： babel：https://babeljs.io webpack中只能处理一部分ES6新语法，一些更高级的ES6或ES7需要借助第三方loader降维。 12345678// main.js ES6简单 Class 类 示例// 静态属性class Person &#123; static info = &#123;name: 'amiao', age:20&#125;&#125;let per = new Person() 注1：static定义静态属性，即通过类名直接访问的属性。相对的，实例属性，通过类的实例访问。 安装如下： 第一套：（转换器） 1npm i babel-core babel-loader babel-plugin-transform-runtime -D 第二套：（字典） 1npm i babel-preset-env babel-preset-stage-0 -D 1234567891011// webpack.config.js...module: &#123; rule: [ ... // 需要把 node_modules 目录，通过exclude选项将其排除掉 &#123; test: /\.js$/, use: 'babel-loader',exclude:/node_modules/ &#125; ... ]&#125;... 在项目根目录中新建 .babelrc 文件，是Babel 配置文件，属于 JSON 格式（不能写注释，字符串必须带双引号）。其中 presets（语法） 和 plugins（插件） 必需配置。 12345// .babelrc&#123; "presets": ["env", "stage-0"], "plugins": ["transform-runtime"] &#125; 多页应用打包配置打包出两个js文件。 12345678910//webpack.config.js ...entry: &#123; index: './src/index.js', a: './src/a.js'&#125;,output: &#123; filename: '[name].[hash:8].js' , path: path.resolve('./build') &#125; 对应两个html 12345678910111213141516plugin:[ new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 指定模板页面 filename: 'index.html', // 指定生成页面的名称 title: 'webpack架构', // title标签内容 hash: true, chunks: ['index'] &#125;) new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 指定模板页面 filename: 'a.html', // 指定生成页面的名称 title: 'webpack架构', // title标签内容 hash: true, chunks: ['a'] &#125;)] 指定热更新1234// index.js if (module.hot) &#123; module.hot.accept();&#125; rulesrules 的 use 用对象方便传参。 12345678910module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123;loader: 'style-loader', options:'...'&#125;, &#123;loader: 'css-loadder'&#125; ] &#125; ]&#125; 抽离样式借助三方插件。但是该配置影响了热更新，仅在上线时使用比较好。 1234567# 抽离样式 抽离到一个CSS文件 通过css文件的方式引用 # webpack3.0 npm i extract-text-webpack-plugin -D # webpack4.0npm i extract-text-webpack-plugin@next -D # 取代版npm i mini-css-extract-plugin -D 1234567891011121314151617181920212223242526272829303132333435363738394041// webpack.config.jslet ExtractTextWebpackPlugin = require('extract-trxt-webpack-plugin')// new两次分别抽离，同时要将rules里的use改成此处的名称LessExtract、CssExtractlet LessExtract = new ExtractTextWebpackPlugin(&#123; filename: 'css/less.css', disable: true&#125;);let CssExtract = new ExtractTextWebpackPlugin(&#123; filename: 'css/css.css' disable: true // 暂时先禁用&#125;);...plugins:[ new ExtractTextWebpackPlugin(&#123; filename:'css/index.css' // 抽离后的文件 &#125;)]...module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: 'style-loader' // 不生效时进入这个打包 use: [ // &#123;loader: 'style-loader'&#125;, 上线是 link 形式插入，故去掉它 &#123;loader: 'css-loadder'&#125; ] &#125;) &#125;, &#123; test: /\.scss$/, use: ExtractTextWebpackPlugin.extract(&#123; use: [ // &#123;loader:'style-loader'&#125;, &#123;loader:'css-loader'&#125;, &#123;loader:'sass-loader'&#125; ] &#125;) &#125;, ]&#125;... mini-css-extract-plugin用法参考：https://webpack.docschina.org/plugins/mini-css-extract-plugin/ webpack 构建 vue 项目参照本博 VUE篇。 注意：关于webpack 和 npm： package.json json文件中不能写注释。 ’不是内外部命令‘，可能是环境变量或未安装的问题。 Webpack 4.0补充安装按照官网安装，注意要多安装个 webpack-cli。 原理npx在 webpack 中所有文件都是模块：js模块、模块化（AMD CMD es6Module commonjs）。 123# 1.新出的 npx 可以执行 node_module 对应的 bin 下的 webpack.cmd 文件npx webpack #（node8.5以上会有）# 2.紧接着会找 webpack.cmd 下定义的 webpack.js 执行 这样直接运行的话是进行默认打包，但通常情况下我们会使用 webpack.config.js 对其进行配置定义。 webpack.config.js该文件是基于 node 的，需要尊循 commonjs 规范 123456789101112131415// config.js 常用配置let path = require('path')module.exports = &#123; entry: '', // 入口 output: &#123; // 出口 filename: 'build.[hash:8].js', // 配置hash为了清缓存 path: path.resolve() // 这个路径必须是绝对路径所以使用path模块 resolve() 方法解析 &#125;, devServer: &#123;&#125;, // 开发服务器 module: &#123;&#125;, // 插件的配置 plugins: [], // 插件配置 mode: 'development', // 可以更改模式 resolve: &#123;&#125;, // 配置解析&#125; 更多webpack.config.js解析可以参考：https://webpack.docschina.org/configuration build.js打包文件此处假设是打包好的文件 上半部分是 自定义函数 是webpack的启动函数，下半部分是执行的参数 12345678910111213141516(function (modules) &#123; // webpackBootstrap webpack的启动函数 // The module cache 缓存模块对象，放着模块de缓存 ... // The require function ... // Check if module is in cache 先检查模块是否存在缓存中 ... // Create a new module (and put it into the cache) ... // Execute the module function 调用方法 执行模块功能 ... // Flag the module as loaded 将模块标记为已加载 ... ...&#125;) package.json这个文件记录一些版本信息等。 12345678"scripts": &#123; "build": "webpack", "dev": "webpack-dev-server“, "...":"...."&#125; // 其中 这个字段可以配置一些我们自定义的脚本 // build 一般为上线打包 // dev 一般为开发打包 插件补充介绍插件。 12# 带hash时清缓存的插件npm install clean-webpack-plugin -D 12# 清除未使用到的样式 注意升级问题npm i purifycss-webpack purify-css glob -D npm purifycss-webpack：https://www.npmjs.com/package/purifycss-webpack 12# 自动加前缀 -webkit- 等npm install postcss-loader autoprefixer -D npm postcss-loader：https://www.npmjs.com/package/postcss-loader 12# copy 插件npm i copy-webpack-plugin -D npm copy-webpack-plugin：https://www.npmjs.com/package/copy-webpack-plugin 123# 引入一个模块既可以全局使用，又想import引入# 可以使用 ProvidePlugin 或 暴露模块的插件npm i export-loader -D ProvidePlugin：https://www.webpackjs.com/plugins/provide-plugin/ export-loader：https://www.npmjs.com/package/export-loader 12# 分析webpack打包内容 性能分析npm install --save-dev webpack-bundle-analyzer webpack-bundle-analyzer：https://www.npmjs.com/package/webpack-bundle-analyzer]]></content>
      <categories>
        <category>技术 - 前端构建工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积小流]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%AD%A6%E4%B9%A0%E5%B7%A5%E4%BD%9C%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[简介不积小流，无以成江海。 javaScriptEvent Loop 参考：http://www.ruanyifeng.com/blog/2014/10/event-loop.html 闭包/引用类型对象 举例： 123456789101112function Foo() &#123; var i = 0; return function() &#123; console.log(i++); &#125;&#125;var f1 = Foo(), f2 = Foo();f1(); // 0f1(); // 1f2(); // 0 涉及知识点： Function 是引用类型，保存在堆中，变量保存在栈中。 闭包：一个函数（产生新的作用域）定义的局部变量、子函数的作用域在函数内部，一旦离开该函数，局部变量就无法访问。通过闭包，即一个函数中定义了一个新的函数，通过此函数使得局部变量得以访问。 过程： （1）执行 Foo() ,返回新的函数 fn，i++ 及先输出 i=0，继而 i+1。 （2）再次执行 f1() 时，i 值已被 i+1 覆盖为 1。即闭包有延续变量的作用。 （3）执行 f2 时，f2 指向堆中新的函数对象，i=0。 深拷贝及浅拷贝概念深拷贝、浅拷贝这个概念讨论是对于 Object 和 Array 复杂类型的。简单来说， 浅拷贝：就是指把一个对象的地址给了另一个对象，他们的指向相同，两个对象之间有共同的属性或者方法。改变其中一个的值，另一个值也会改变。 深拷贝：在另一个对象中开辟相应的空间，一个一个的存储到另一个对象中。 解决方案原生方法浅拷贝：简单的 赋值行为 12345678var obj1=&#123; age:10, sex:"男", car:["浅拷贝","拷贝","地址","属性"]&#125;;var obj2 = obj1;obj1.age = 20;console.log(obj2.age); // 随之改变为 20 深拷贝：jQuery.extend() 函数用于将一个或多个对象的内容合并到目标对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 语法：$.extend( [deep], target, object1 [, objectN ] )。// [deep] 表示是否进行深拷贝jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone,target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === "boolean" ) &#123; deep = target; // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if (deep&amp;&amp;copy&amp;&amp;(jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray( copy ))))&#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 跨域请求 相同的域是指，域名、协议、端口号完全相同。 跨域请求的方法： （1）CORS （2）document.domain （3）图像Ping （4）Jsonp （5）Comet （6）WebSocket call()和apply()的区别 相同点：作用相同，即，在特定的作用域调用函数，等于设置this对象的值，以扩充函数赖以运行的作用域。 1234567891011// 与apply()效果相同，此处仅以 call() 为例window.color = "red";var o=&#123;color:"blue"&#125;;function getColor()&#123; console.log(this.color)&#125;;getColor.call(this); // redgetColor.call(window); // redgetColor.call(o); // blue 不同点： 接收参数的方式不同： （1）call()：第一个参数是运行函数的作用域 ，后面的参数依次传入函数。 （2）apply()：第一个参数是运行函数的作用域 ，另一个参数是参数数组,可以是Array实例或arguments对象。 12345678function add(c, d)&#123;return this.a + this.b + c + d;&#125;var o = &#123;a:1, b:3&#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 阻止默认事件 阻止表单默认行为 1234&lt;form id="add_form"&gt; ... &lt;input type="submit" value="保存"&gt;&lt;/form&gt; 1234567$('#add_form').on('submit',handleAddSubmit)function handleAddSubmit(e)&#123; e.preventDefault() // 阻止表单默认行为 $.post('http://...',$(this).serialize(),function (data) &#123; ... &#125;)&#125; 原因：（1）需要处理逻辑再提交（2）防止跳转链接 ，仅将数据提交给某个url，不需跳转 CSS经典布局双飞翼布局步骤： 两栏和自适应元素都设置统一方向的浮动（如 float: left; )； middle-wrap 元素设置宽度为100%； middle元素设置左右margin值，值为左右两栏的宽度。 左边栏margin-left为负100%； 右边栏margin-left为负自身宽度。 代码： 1234567891011121314151617181920212223.middle-wrap&#123; float: left; width: 100%; overflow: hidden; clear: both;&#125;.middle &#123; height: 200px; background-color:yellowgreen;&#125;.left, .right&#123; float: left; width: 200px; height: 200px;&#125;.left &#123; background-color: #ccc; margin-left:-100%;&#125;.right &#123; background-color: #333; margin-left:-200px;&#125; 12345&lt;div class="middle-wrap"&gt; &lt;div class="middle"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; 理解：（关键点对于margin的理解） margin-left:-100% 是指：子元素（left）的左边框距离父元素（body）右边框的距离。 参考链接：https://segmentfault.com/a/1190000014546205?utm_source=tag-newest border:none; / border:0; 的区别border:none;：表示无边框。 border:0;：表示边框宽度为 0。 性能差异： border:宽度 样式 颜色;顺序不能错，渲染颜色前先获得边框。 border:none;浏览器不进行渲染，不占用内存。 border:0;浏览器对 border-with、border-color进行渲染，占用内存。 浏览器兼容： IE-7不支持border:none; Sprites精灵图优缺点优点： 减少图片字节； 减少http请求； 不同场景下可维护性高（比如只改变图片颜色）； 缺点：（为了性能，繁杂工序的缺点都不构成缺点） 合并麻烦 适应性差 定位繁琐 不同场景下可维护性差，（高边其中图片内容） HTML&lt;a&gt; 标签中的 target 属性 属性值 描述 _blank 在新窗口中打开被连接文档。 _self 默认。在相同的框架中打开被连接文档。 _parent 将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，和_self参数效果一样。 _top 在整个窗口中打开被链接文档。 framename 在指定的框架中打开被链接文档。 _top 和 _partent 不常用，区别为： 比如网A中镶嵌 iframe 了网页B，网页B镶嵌 iframe 了网页C：如果网页C中连接设置target=parent，则将网页B去掉，直接跳入A中嵌入网页C中链接的页面;而如果网页C中target=top ，则直接跳出所有iframe框架，直接转向C中链接页面。 注意：任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将_下划线作为文档中定义的任何框架 name 或 id 的第一个字符。 ES6模块化 export default name 只能导一个，不能写成 export default {name} 的形式 ， 接收时 import name from &#39;./path&#39;，不能写为import {name} from &#39;./path&#39;。 export {name,...} 可以导出多个，但是导出导入都必须加 { }， import {name,...} from &#39;./path&#39;。 安全xssxss攻击，大致原理就是 代码注入，利用漏洞注入代码进行攻击 参考链接：https://tech.meituan.com/2018/09/27/fe-security.html 浏览器渲染机制重绘：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。 回流：当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。 参考：https://blog.fundebug.com/2019/01/03/understand-browser-rendering/ Vue组件封装待更…….]]></content>
      <categories>
        <category>前端积累</category>
        <category>学习积累</category>
      </categories>
      <tags>
        <tag>前端积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美好事物]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%BE%8E%E5%A5%BD%E4%BA%8B%E7%89%A9%2F</url>
    <content type="text"><![CDATA[我望向幽谷，惶恐又欣喜。我试着想象，那里暗藏着的，是一枝花，一团火，还是一颗坠落的星辰。我把经过修饰的想象扔向那里，回声中，溅起了些许涟漪。你问我那里究竟是些什么？可我终究是无法形容的，那些回忆中带着的情绪，那些不甘心的幸运。——王佚——————————————————————谢谢自己走过深渊，穿过黑暗也谢谢你在光亮处翘首以盼]]></content>
      <categories>
        <category>poem - 美好事物</category>
      </categories>
      <tags>
        <tag>poem</tag>
        <tag>美好事物</tag>
      </tags>
  </entry>
</search>
